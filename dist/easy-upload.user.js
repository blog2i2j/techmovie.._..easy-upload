// ==UserScript==
// @name            EasyUpload PT一键转种
// @name:en         EasyUpload - Trackers Transfer Tool
// @namespace       https://github.com/techmovie/easy-upload
// @version         7.0.0-beta.1
// @author          birdplane
// @description     一键转种，支持PT站点之间的种子转移。
// @description:en  Transfer torrents between trackers with one click.
// @license         MIT
// @source          git@github.com:techmovie/easy-upload.git
// @downloadURL     https://github.com/techmovie/easy-upload/raw/master/dist/easy-upload.user.js
// @updateURL       https://github.com/techmovie/easy-upload/raw/master/dist/easy-upload.user.js
// @match           http*://*/torrents.php?id=*
// @match           http*://*/torrents.php?torrentid=*
// @match           http*://*/details.php?id=*
// @match           https://totheglory.im/t/*
// @match           https://ptpimg.me/*
// @match           http*://*/torrents/*
// @match           http*://*/torrents?*
// @match           http*://*/upload*
// @match           https://*/offers.php*
// @match           https://broadcity.in/browse.php?imdb=*
// @match           https://*/torrent/*
// @match           https://piratethenet.org/browse.php?*
// @match           https://teamhd.org/details/id*
// @match           https://hd-space.org/index.php?page=upload
// @match           https://hd-space.org/index.php?page=torrent-details&id=*
// @match           https://speedapp.io/browse/*
// @match           https://*.m-team.cc/detail/*
// @exclude         https://*/torrent/peers*
// @exclude         https://*/torrent/leechers*
// @exclude         https://*/torrent/history*
// @require         https://cdn.jsdelivr.net/npm/preact@10.24.3/dist/preact.min.js
// @require         https://cdn.jsdelivr.net/npm/jquery@3.7.1/dist/jquery.min.js
// @grant           GM_addStyle
// @grant           GM_getValue
// @grant           GM_openInTab
// @grant           GM_setClipboard
// @grant           GM_setValue
// @grant           GM_xmlhttpRequest
// ==/UserScript==

(e=>{if(typeof GM_addStyle=="function"){GM_addStyle(e);return}const t=document.createElement("style");t.textContent=e,document.head.append(t)})(" td.title-td{min-width:80px;vertical-align:middle!important}td.title-td h4{text-align:right;margin:0;font-size:13px;font-weight:500;height:100%;display:flex;align-items:center;justify-content:flex-end}#seed-dom button{line-height:1;white-space:nowrap;cursor:pointer;background:#fff;border:1px solid #dcdfe6;color:#606266;-webkit-appearance:none;text-align:center;box-sizing:border-box;outline:none;transition:.1s;font-weight:500;-moz-user-select:none;-webkit-user-select:none;-ms-user-select:none;padding:6px 16px;font-size:13px;border-radius:4px;margin:0 5px 0 0}#seed-dom button:hover{background:#fff;border-color:#409eff;color:#409eff}#seed-dom button.is-disabled,#seed-dom button.is-disabled:hover{color:#c0c4cc;cursor:not-allowed;background-image:none;background-color:#fff;border-color:#ebeef5}.site-list,.search-list{margin:0;padding:0;list-style:none;display:flex;justify-content:center;align-items:center;flex-wrap:wrap}.site-list .site-icon,.search-list .site-icon{width:12px;margin-right:5px}.ptp-search-list{display:flex;align-items:center;padding-top:10px;justify-content:center}.ptp-search-list h4{margin:0 15px 0 0;min-width:60px}#seed-dom ul li,.search-list li,.site-list li{font-weight:600;line-height:24px;margin:0 5px 0 0;padding:0;display:flex;align-items:center}#seed-dom ul li a,.search-list li a,.site-list li a{padding-right:3px;display:inline-flex;align-items:center;cursor:pointer}.search-list li:last-child span{display:none}.easy-upload-function-list{display:flex;justify-content:space-around;padding:6px 20px;flex-wrap:wrap}.easy-upload-function-list button{line-height:1;white-space:nowrap;cursor:pointer;background:#fff;border:1px solid #dcdfe6;color:#606266;-webkit-appearance:none;text-align:center;box-sizing:border-box;outline:none;transition:.1s;font-weight:500;-moz-user-select:none;-webkit-user-select:none;-ms-user-select:none;padding:8px 20px;font-size:14px;border-radius:4px;margin:0 5px 0 0}.easy-upload-function-list button:hover{background:#fff;border-color:#409eff;color:#409eff}.easy-upload-function-list button.is-disabled,.easy-upload-function-list button.is-disabled:hover{color:#c0c4cc;cursor:not-allowed;background-image:none;background-color:#fff;border-color:#ebeef5}.function-list-item{display:flex;align-items:center;justify-content:space-between;margin-bottom:10px}.function-list-item input{-webkit-appearance:none;background-color:#fff;background-image:none;border-radius:4px;border:1px solid #dcdfe6;box-sizing:border-box;color:#606266;display:inline-block;font-size:inherit;height:34px;line-height:40px;outline:none;width:200px;padding:0 12px;transition:border-color .2s cubic-bezier(.645,.045,.355,1)}.function-list-item select{border:0;font-family:inherit;padding:5px;font-size:14px;border-radius:3px;text-transform:none}.function-list-item input::placeholder{color:#c0c4cc}.function-list-item input:hover{border-color:#c0c4cc}.function-list-item input:focus{outline:none;border-color:#409eff}.hdb-tr{display:flex}.hdb-tr td:last-child{flex:1}.hdb-tr td:first-child>h4{width:100px}.function-list-item h4{margin:0 10px 0 0;padding:0;font-weight:600;font-size:14px}.upload-section,.douban-section,.douban-book-section{display:flex;justify-content:center;align-items:center}.upload-section #nsfw{margin-left:0;position:static}.upload-section label{padding-left:0}#kdescr img{max-width:100%}.easy-upload-setting-btn{display:inline-flex;align-items:center;margin-left:3px}svg.setting-svg{height:20px;width:20px;vertical-align:middle;animation:5s linear rotate infinite;cursor:pointer}@keyframes rotate{to{transform:rotate(360deg)}}.easy-upload-setting-panel{position:fixed;top:0;right:0;bottom:0;left:0;z-index:2000;background:rgba(0,0,0,.5);color:#000}#batch-seed-btn,#auto-fill-douban{border-color:transparent;color:#409eff;background:transparent;padding-left:0;padding-right:0;font-weight:600;cursor:pointer}#batch-seed-btn:hover,#auto-fill-douban:hover{color:#66b1ff;border-color:transparent;background-color:transparent}#batch-seed-btn:active,#auto-fill-douban:active{color:#3a8ee6;background-color:transparent}#auto-fill-douban{font-size:14px;display:inline-block}.easy-upload-setting-panel *{padding:0;margin:0}.easy-upload-setting-panel input[type=text]{-webkit-appearance:none;background-color:#fff;background-image:none;border-radius:4px;border:1px solid #dcdfe6;box-sizing:border-box;color:#606266;display:inline-block;font-size:inherit;height:34px;line-height:40px;outline:none;width:200px;padding:0 12px;transition:border-color .2s cubic-bezier(.645,.045,.355,1)}.easy-upload-setting-panel input[type=text]::placeholder{color:#c0c4cc}.easy-upload-setting-panel input[type=text]:hover{border-color:#c0c4cc}.easy-upload-setting-panel input[type=text]:focus{outline:none;border-color:#409eff}.easy-upload-setting-panel h3,.easy-upload-setting-panel h1{color:#000;margin-bottom:15px}.easy-upload-setting-panel .panel-content-wrap{max-width:800px;box-sizing:border-box;margin:50px auto;border-radius:8px;background:#fff;position:relative;text-align:center;box-shadow:0 1px 3px rgba(0,0,0,.3);padding:20px 10px 10px 20px}.easy-upload-setting-panel .panel-content{height:500px;overflow-y:auto}.easy-upload-setting-panel .panel-content ul{list-style:none;display:flex;flex-direction:row;flex-wrap:wrap;margin:0 auto;padding:0 10px}.easy-upload-setting-panel .panel-content li{width:90px;text-align:left;margin-bottom:10px}.easy-upload-setting-panel .panel-content label{cursor:pointer;color:#000!important;font-size:12px;display:flex;align-items:center}.easy-upload-setting-panel .panel-content label input{margin:0 3px 0 0;padding:0}.panel-content p{display:block;margin-bottom:10px;font-size:12px}.easy-upload-setting-panel button{line-height:1;white-space:nowrap;cursor:pointer;background:#fff;border:1px solid #dcdfe6;color:#606266;-webkit-appearance:none;text-align:center;box-sizing:border-box;outline:none;transition:.1s;font-weight:500;-moz-user-select:none;-webkit-user-select:none;-ms-user-select:none;padding:8px 20px;font-size:14px;border-radius:4px;margin:0 5px 10px 0}.easy-upload-setting-panel button:hover{background:#fff;border-color:#409eff;color:#409eff}.easy-upload-setting-panel .confirm-btns{padding-top:15px}.easy-upload-setting-panel .img-upload-setting{margin-bottom:10px}.easy-upload-setting-panel .img-upload-setting label{justify-content:center}.easy-upload-setting-panel .img-upload-setting label input{margin-left:8px;margin-right:8px}.easy-upload-setting-panel .img-upload-setting label a{color:#000;font-weight:500}.easy-upload-setting-panel .img-upload-setting label a:hover{color:#f7d584}.feature-list{display:flex;flex-wrap:wrap;justify-content:space-between;padding:0 50px}.feature-list .site-enable-setting{width:250px;padding-top:5px;margin-bottom:8px;text-align:center}.easy-upload-setting-panel .save-setting-btn{background-color:#007bff;border-color:#007bff;color:#fff}.easy-upload-setting-panel .save-setting-btn:hover{background:#66b1ff;border-color:#66b1ff;color:#fff}.ptp-api-key-btn{text-align:center}.easy-notification{box-sizing:border-box;position:fixed;transition:opacity .3s,transform .3s,left .3s,right .3s,top .4s,bottom .3s;overflow:hidden;right:0;margin:0 24px 0 0;color:rgba(0,0,0,.85);font-size:14px;line-height:1.5715;z-index:2010}.easy-notification-enter{right:16px;transform:translate(0)}.easy-notification-notice{position:relative;width:300px;max-width:calc(100vw - 48px);margin-bottom:16px;margin-left:auto;padding:16px 24px;overflow:hidden;line-height:1.5715;word-wrap:break-word;background:#fff;border-radius:2px;box-sizing:border-box;box-shadow:0 2px 12px rgba(0,0,0,.1)}.notification-message{margin-bottom:8px;color:rgba(0,0,0,.85);font-size:16px;line-height:24px}.notification-description{font-size:14px;line-height:21px;margin:6px 0 0;text-align:justify;padding-right:10px}.notification-description p{margin:0}.easy-notification-notice-close svg{height:14px;width:14px;font-size:14px}.easy-notification-notice-close{position:absolute;top:13px;right:15px;cursor:pointer;color:#909399;font-size:16px}.easy-notification-notice-close:hover{color:#606266}#transfer-progress{display:none}.custom-site{display:flex;align-items:center;width:100%}.custom-site h4{flex-shrink:0;margin:0 10px 0 0;line-height:initial}.custom-site .easy-upload-function-list{flex:1}.custom-site img{border-radius:0}tr.pad[id*=torrent_]{font-family:Proxima Nova,Lato,Segoe UI,sans-serif}#seed-dom .easy-upload-function-list .copy-img{margin-left:5px}.quick-search{cursor:pointer;color:#409eff;font-weight:600}.ptp-title-wrapper{position:relative}#seed-dom .ptp-title-wrapper h4{position:absolute;left:0;top:0;margin:0!important;display:flex!important;align-items:center;line-height:24px}#seed-dom .ptp-title-wrapper .site-list li:first-child{padding:0 0 0 140px}#seed-dom .ptp-title-wrapper .search-list li:first-child{padding-left:70px}#seed-dom.use-eng .ptp-title-wrapper .search-list li:first-child{padding-left:95px}#batch-search-btn{color:#409eff;padding-left:0;padding-right:0;font-weight:600;cursor:pointer}.douban-config{display:flex;justify-content:center}.douban-config textarea{resize:none;width:300px;height:100px;margin-left:6px} ");

(function (preact, $$2) {
  'use strict';

  var __defProp = Object.defineProperty;
  var __defProps = Object.defineProperties;
  var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
  var __getOwnPropSymbols = Object.getOwnPropertySymbols;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __propIsEnum = Object.prototype.propertyIsEnumerable;
  var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __spreadValues = (a2, b) => {
    for (var prop in b || (b = {}))
      if (__hasOwnProp.call(b, prop))
        __defNormalProp(a2, prop, b[prop]);
    if (__getOwnPropSymbols)
      for (var prop of __getOwnPropSymbols(b)) {
        if (__propIsEnum.call(b, prop))
          __defNormalProp(a2, prop, b[prop]);
      }
    return a2;
  };
  var __spreadProps = (a2, b) => __defProps(a2, __getOwnPropDescs(b));
  var __objRest = (source, exclude) => {
    var target = {};
    for (var prop in source)
      if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
        target[prop] = source[prop];
    if (source != null && __getOwnPropSymbols)
      for (var prop of __getOwnPropSymbols(source)) {
        if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
          target[prop] = source[prop];
      }
    return target;
  };
  var _a;
  var f$1 = 0;
  function u$1(e2, t2, n, o2, i, u2) {
    t2 || (t2 = {});
    var a2, c2, l2 = t2;
    "ref" in t2 && (a2 = t2.ref, delete t2.ref);
    var p2 = { type: e2, props: l2, key: n, ref: a2, __k: null, __: null, __b: 0, __e: null, __d: void 0, __c: null, constructor: void 0, __v: --f$1, __i: -1, __u: 0, __source: i, __self: u2 };
    if ("function" == typeof e2 && (a2 = e2.defaultProps)) for (c2 in a2) void 0 === l2[c2] && (l2[c2] = a2[c2]);
    return preact.options.vnode && preact.options.vnode(p2), p2;
  }
  const PT_SITE = {
    "1PTBA": {
      url: "https://1ptba.com",
      host: "1ptba.com",
      siteType: "NexusPHP",
      icon: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAMAAAC6V+0/AAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAACqVBMVEUAerwqYXVnYVNybF9uaFtjXUxTXlcyYnQOb54Ae7wMcKJYaWi0rqbUz8fTz8fSzcXNycG/urKemY1bcXERb50sYnSOioHf29Lt6d/s6N/m4tnBvLFNcntrb2bFwLjt6eHu6eHt6eDr597q5t3n49qRkINrf3+1t7C5u7W6u7S+urG9urG5urTEw7vj39br59/s6eCuqZ0Qc6Uib5Ijb5EkbIxQZGN8d2qAem6JhXlDaXMibpEwaoGVmpLl4disp5sAe70OcKBscWnEv7fV0MjV0cnMx706a3sAe74IcqdjdnXTzcTq59+Mj4UBe7wBerskZoGSj4bi3dTv6+O5urIibpAAerscZod4enLW0cnu6+PPy8JFcoABebg9Y26zrKLp5dyOl5EMcqUCeLcbZodaY12uqJ/t6uHk4Nh3jY4Pb54JcqZdb27Iwrji3tVggYgKbZ4yX21obGavqaDi3dXd2dF9kJIVcZ0Wa5N/f3Xb1s7Lx70zboYvY3WDfXLFwLft6ODKycFhfYESb50AebouZ36emY6nraYWZolMbXXCvLOdoJcTZ44Cd7VIZGi6tKvr5t14jY4HcqgxbIO6tKm6tqprdG/SzcTs6N7e2dBJc38AebsUa5WOk4vn4tns6ODQy8I+dYoAeLgeZoaMi4Lf2tK+vLMncZISa5R3fnnb1czMx743c40AebkCebg2ZXWrpJno5NuSl44YY4IcZYRHXmCcmI6vsKcabpUHc6pYa2vDvbTk4NecnJNnbWd9eW+po5ra1c1nhIoGc6sRbpt3eG3Z1Mza1cze2dHh3dSAk5UUcJ0qa4ajn5Xn5Nzu6uLt6uLv6+Tp5d7Y1MyxtK1hgIgUcZ8lbYyTkYSxrqOxraOwraOtqp+XlIV9iIFReYUfaowGdKz///88yl8CAAAAAWJLR0TixgGeHAAAAAd0SU1FB+UECgcrNELreWwAAAGKSURBVBjTY2BgZGJGABZWNnYOTgYubh5eOODjFxAUEhZhEBUTl5BEBlLSMgyycvIKCvJgoKCgqKSspKyiyqCmrqGhoamlraWtoaGjq6evrGxgyGBkbGJsamZuYWFpZW1sY2unpCxvz8DJwODg6OTs4urmzuDh6eWtpOTjy+Dn5+8QEBikGBwS6hAWHhGpFBUdAxTkjI2LT1CST0xKTklNk0rPyMwCCjpk5+RKSublFxQWFZcEl5aVMzD4cTpUVFYppVfX1NbVSzU0NjUDrfHjbGltk1JSaO/o7FJWUuru8eD0Bwr29vUnKE2YOGnyFEklxanWDJx+DH4OjtOmz5CcOWv2nLnzlOYvWLgIKMjpsHjJUqX0Zcs9VqxcpSS/es1akOC69Rs2Kslv2rxl67Y8peDtOxyAgg47d+1WUtqzd9/+AweV5EsOHXbwAwoeOXoMGDLHp59Qlg8+eeo0JydQMOzM2XPnL1w4H3zx0uUrV68B7QYKMly/cfPW7ds379y9d//BQwZOf6AgACIJgNAMLRaxAAAAJXRFWHRkYXRlOmNyZWF0ZQAyMDIxLTA0LTEwVDA3OjQzOjUyKzAwOjAwjJgVBwAAACV0RVh0ZGF0ZTptb2RpZnkAMjAyMS0wNC0xMFQwNzo0Mzo1MiswMDowMP3FrbsAAAAASUVORK5CYII=",
      asSource: true,
      asTarget: true,
      uploadPath: "/upload.php",
      seedDomSelector: "#top~table:first>tbody>tr:nth-child(5)",
      torrentDownloadLinkSelector: 'a[href*="download.php?id="]',
      search: {
        path: "/torrents.php",
        imdbOptionKey: "4",
        nameOptionKey: "0",
        params: {
          incldead: "0",
          search_area: "{optionKey}",
          search: "{imdb}",
          sort: "5",
          type: "desc"
        },
        result: {
          list: "#torrenttable>tbody>tr",
          url: '.torrentname td a[href*="details.php?id="]',
          name: '.torrentname td a[href*="details.php?id="]',
          size: "td:nth-child(5)"
        }
      },
      name: {
        selector: "#name"
      },
      subtitle: {
        selector: 'input[name="small_descr"]'
      },
      description: {
        selector: "#descr"
      },
      imdb: {
        selector: 'input[name="url"][type="text"]'
      },
      anonymous: {
        selector: 'input[name="uplver"]'
      },
      torrent: {
        selector: 'input[name="file"]'
      },
      category: {
        selector: "#browsecat",
        map: {
          movie: "401",
          tv: "402",
          tvPack: "402",
          documentary: "404",
          concert: "406",
          sport: "407",
          cartoon: "405",
          variety: "403"
        }
      },
      videoCodec: {
        selector: 'select[name="codec_sel"]',
        map: {
          h264: "1",
          x264: "1",
          hevc: "10",
          x265: "10",
          h265: "10",
          mpeg2: "4",
          mpeg4: "1",
          vc1: "2",
          xvid: "3",
          dvd: "4"
        }
      },
      audioCodec: {
        selector: 'select[name="audiocodec_sel"]',
        map: {
          aac: "6",
          ac3: "18",
          dd: "18",
          "dd+": "18",
          flac: "1",
          dts: "3",
          truehd: "20",
          lpcm: "21",
          dtshdma: "19",
          atmos: "19",
          dtsx: "3",
          ape: "2",
          wav: "22",
          mp3: "4",
          m4a: "5",
          other: "7"
        }
      },
      videoType: {
        selector: 'select[name="medium_sel"]',
        map: {
          uhdbluray: "10",
          bluray: "13",
          remux: "3",
          encode: "7",
          web: "11",
          hdtv: "5",
          dvd: "2",
          dvdrip: "7",
          other: "12",
          cd: "8"
        }
      },
      resolution: {
        selector: 'select[name="standard_sel"]',
        map: {
          "4320p": "11",
          "2160p": "10",
          "1080p": "2",
          "1080i": "2",
          "720p": "4",
          "576p": "5",
          "480p": "5"
        }
      },
      team: {
        selector: 'select[name="team_sel"]',
        map: {
          "1ptba": "1",
          chd: "2",
          mysilu: "3",
          wiki: "4",
          other: "5"
        }
      }
    },
    "3Wmg": {
      url: "https://www.3wmg.com",
      host: "3wmg.com",
      siteType: "NexusPHP",
      icon: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAYAAACNiR0NAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAABmJLR0QA/wD/AP+gvaeTAAAAB3RJTUUH5QQKBykVPLQLsAAABCVJREFUOMuVlctvVVUYxX97n3PPvb0t0BZKSKW0FdpSDCAkViMmjU9kAImaMDVGnOo/4IApGo0xccLQmYkgJhhfCSA4sgUJjz5JsbVwS/q6lN7bc/brc3AanGiiO9mjb+1k7d/KXlvxP9ax04tsfyKmMucatGYrsAysnHln82ON+rfDB967RXU+Zc/hroZSSTeXErVNKfq0Ym8cq6cizQ7rZKyeyYdxxFQ9Fc69u5kYYLxi8Q4aSiq5Mp2VhmZse93SGxS7g7BHK/qiiO44Ui1xRBxppZUC6+TpWMvVjw4WP/n6QeAcoE58s8xCVXZtKKmXTwyUD+/cHHWlTppTK80La7Lxh8ksWloLaKUoFWCwK+HJlhgBRIRI8WtXS3S8oFWlIdHElYWwt6msT0UFdeTStGEpjTnSWySJQIBqKpwfz/AiiFWMzjs2FTWD3QUmFz0/T2StFzxxMcrpxcAhYJ8XmJh3LNQCg90J09VAZ3PEoc4CN+Ys4wsOreBmxZFZ2L8t5uo9y6W7ZkOtJluBPwG0dVzNrCxlRjAOjBVEYHjWMjRr2VLWvNidUECRGcE6wTjBeGGpFgieFgV9CnjliwW0MWHEmjBjTMCagLUCwKO1wPmRlPlVz0BHgYPtMcYEjBXcusYHwXtpEpE9v99ew3tBX3x/S81YGXEu4HzA+wDrwEcrhh/HUwoaXu8t0lZWWJtrRCB4wftACNK/qzPZGIKgj56ex1q5YYxYawRrBRHBeyHNhJ9GUkYfOHraYl7aVUS84JyAgPe52+ClVylpQQT9qBbwPoxZEx46G3A2dxg8eBe4v+w4c61O3QRe6yuye0uMMYIA3gnWBLwLHRJkByLoNBMyIxVj5K5ZZygCzkvOzAhXJte4OJbS2hjxxv4GmhIIQXKNDTgnjc5Jf6wCsXMQhCpaJpSSZx4Dd4I1gkJYyeCroRr7ticMdBWp1sPfmkxQSmIvau9vS41o74VStlZzVkZsFoIxOXDvBJMFjMkxjM4azg7XiDS82l9iY0njbH5lawLehv7u0mqLvn6ynVUSrJMxa+WRMzlw5/OArMl3lga+HV5leCqjIdEkETgnmPW5s7IteGnXkKflvUxYK8utZU0hgnKs8OshORvwLlBZcnx5eYVq3aOUwjtZnwvOyR8SWIwBerYWKBfV7As9xeXne0pdm8qa48810dEa8fn3Ve4vO7TK3+rlkTX57lotvPVsky4X9YzzXItidV0JZ0Pq52KAYwfKbGiMaosP7egvt+sHLt6s5Q6CSGokeE8mmorSTNaMjF0YSWfeHGgqHT3YePnkmepQT2diAZn8uD0v2Ia3p+hrU9xbkcGCklME2kQxh2IyKeibkeIWSk2pSC8prR4iuDufdvxjMT9u7O4PpkGhEXYi0opS0yjmAX/3s87//E38BWXDuj9j0ViVAAAAJXRFWHRkYXRlOmNyZWF0ZQAyMDIxLTA0LTEwVDA3OjQxOjIxKzAwOjAws0DWvgAAACV0RVh0ZGF0ZTptb2RpZnkAMjAyMS0wNC0xMFQwNzo0MToyMSswMDowMMIdbgIAAAAASUVORK5CYII=",
      asSource: true,
      asTarget: true,
      uploadPath: "/upload.php",
      seedDomSelector: "#top~table:first>tbody>tr:nth-child(5)",
      torrentDownloadLinkSelector: 'a[href*="download.php?id="]',
      search: {
        path: "/torrents.php",
        imdbOptionKey: "4",
        nameOptionKey: "0",
        params: {
          incldead: "0",
          search_area: "{optionKey}",
          search: "{imdb}",
          sort: "5",
          type: "desc"
        },
        result: {
          list: ".torrents>tbody>tr",
          url: '.torrentname td a[href*="details.php?id="]',
          name: '.torrentname td a[href*="details.php?id="]',
          size: "td:nth-child(5)"
        }
      },
      name: {
        selector: "#name"
      },
      subtitle: {
        selector: 'input[name="small_descr"]'
      },
      description: {
        selector: "#descr"
      },
      imdb: {
        selector: 'input[name="url"][type="text"]'
      },
      douban: {
        selector: 'input[name="pt_gen[douban][link]"]'
      },
      anonymous: {
        selector: 'input[name="uplver"]'
      },
      torrent: {
        selector: 'input[name="file"]'
      },
      tags: {
        chinese_audio: 'input[name="tags[]"][value="16"]',
        diy: 'input[name="tags[]"][value="8"]',
        hdr: 'input[name="tags[]"][value="64"]',
        chinese_subtitle: 'input[name="tags[]"][value="32"]'
      },
      category: {
        selector: "#browsecat",
        map: {
          movie: "401",
          tv: "403",
          tvPack: "402",
          documentary: "404",
          concert: "406",
          sport: "410",
          cartoon: "405",
          variety: "403"
        }
      },
      source: {
        selector: 'select[name="source_sel"]',
        map: {
          uhdbluray: "1",
          bluray: "1",
          hdtv: "4",
          dvd: "3",
          web: "6",
          vhs: "6",
          hddvd: "2"
        }
      }
    },
    "52pt": {
      url: "https://52pt.site",
      host: "52pt.site",
      siteType: "NexusPHP",
      icon: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAABtlBMVEUAAAD/f1D+f1D8f0nrlATcRhAAAP8AAP72vAX2vAX2uwX2vAX2vAX1vAT2vAX2vAX2vAX2uwX/f1D/f1D/f1D/f1D2vAX2vAX2uwX1ugX0tQT/flD/f1D+f1D+fk/+f1D+f1D2vAX1uAXyrQTwpgT+fk//f1D/f1D/flD/f0//f1D1uwX0twTxqgTuoATslgTohAX/f1D/fk/+flD/f1D/f1DwpQTtmwTqkATohQTmfwT+flD/f0//f1D/f1D/f1D/f1DxqgTvogTslQTpigTmfwTldwXiaAr+f1D/f1D/f1D+f1DrlQPqjQTohQTleQXjbQnhYgrgYgr/f1D/f1D/f1D/f1D/f1DqjwTpiwTkcwfiaArfWwvdTw7/f1D+flD+f1D/f1DpiwXkdgbjbwnhYgreVA3cRRDbPRL/f0/hZArgXQveUA7bQRHbOhLbOhPeUQ3cSQ/bOhLbOhPbOhMAAP8AAP4AAP/bPhLbOhLbOhMAAP8AAP4AAP8AAP8AAP8AAP/bORPaORPbOhMAAP8AAP8AAP8AAP8AAP8AAP/bOhPbOhPbOhPbOhP2uwXysATmfwT////emFSbAAAAjnRSTlMAAAAAAAAAACiIUl5wyHjAdsYQChQGvkoOeMawXHYIIjbQ0IjGLDhAKEZS5Hbk+MoygkRUYljmUu78XiJoaFBKVnCo+t5KQghmVEhuVJJi+vrUAgKApERuMt7AaPjGMhIgDAp44u7QvroGdsg+6rjEdsgEdsYiGih2yHhsOlJKTgZqyLo0OlBYPAQWYDo8iaK1gQAAAAFiS0dEkQ8NvpoAAAAHdElNRQflBBUOAAFlgzxgAAAA50lEQVQY02Ng4OBkYODiZkAAHl4GBj5+JAEBkIAgA6OQsAgDoyhIQExcQlKKgUlaRlZOXgEkoNinpKzCwKSqpq6hqQUS0NbR1dM3YDY0MjYxNQEK6PSbmVtYWjFY29ja2TsABRydnF1c3dxFPWztPb28GRhYfHz9/AMCg4LtQ0Jtw8IZGCIiJ0RFx8QyMMTFJ2glJjIwJCWnpKalZ4CdpJUJIrOyc3Lz8sECTIwgsqCQtai4hIGttKycnQ0kUFHJwFAFFKiuqa2rbwAKNDYBBZoZ2Fpa29o7OoECXd0MDD29QAYbCDAAALdvLFoE/tjvAAAAJXRFWHRkYXRlOmNyZWF0ZQAyMDIxLTA0LTIxVDE0OjAwOjAxKzAwOjAwc0mO0gAAACV0RVh0ZGF0ZTptb2RpZnkAMjAyMS0wNC0yMVQxNDowMDowMSswMDowMAIUNm4AAAAASUVORK5CYII=",
      asSource: true,
      asTarget: true,
      uploadPath: "/upload.php",
      seedDomSelector: "#top~table:first>tbody>tr:nth-child(3)",
      torrentDownloadLinkSelector: 'a[href*="download.php?id="]',
      search: {
        path: "/torrents.php",
        imdbOptionKey: "4",
        nameOptionKey: "0",
        params: {
          incldead: "0",
          search_area: "{optionKey}",
          search: "{imdb}",
          sort: "5",
          type: "desc"
        },
        result: {
          list: ".torrents>tbody>tr",
          url: '.torrentname td a[href*="details.php?id="]',
          name: '.torrentname td a[href*="details.php?id="]',
          size: "td:nth-child(5)"
        }
      },
      name: {
        selector: "#name"
      },
      subtitle: {
        selector: 'input[name="small_descr"]'
      },
      description: {
        selector: "#descr"
      },
      imdb: {
        selector: 'input[name="url"][type="text"]'
      },
      anonymous: {
        selector: 'input[name="uplver"]'
      },
      torrent: {
        selector: 'input[name="file"]'
      },
      category: {
        selector: "#browsecat",
        map: {
          movie: "401",
          tv: "402",
          tvPack: "402",
          documentary: "404",
          concert: "406",
          sport: "407",
          cartoon: "405",
          variety: "403"
        }
      },
      videoCodec: {
        selector: 'select[name="codec_sel"]',
        map: {
          h264: "13",
          x264: "11",
          hevc: "1",
          x265: "12",
          h265: "1",
          mpeg2: "4",
          mpeg4: "13",
          vc1: "2",
          xvid: "3",
          dvd: "4"
        }
      },
      audioCodec: {
        selector: 'select[name="audiocodec_sel"]',
        map: {
          aac: "13",
          ac3: "6",
          dd: "6",
          "dd+": "6",
          flac: "1",
          dts: "15",
          truehd: "12",
          lpcm: "14",
          dtshdma: "4",
          atmos: "10",
          dtsx: "3",
          ape: "2",
          wav: "11",
          other: "7"
        }
      },
      videoType: {
        selector: 'select[name="medium_sel"]',
        map: {
          uhdbluray: "1",
          bluray: "11",
          remux: "4",
          encode: "7",
          web: "10",
          hdtv: "3",
          dvd: "6",
          dvdrip: "7",
          other: "9",
          cd: "8"
        }
      },
      resolution: {
        selector: 'select[name="standard_sel"]',
        map: {
          "4320p": "7",
          "2160p": "5",
          "1080p": "1",
          "1080i": "2",
          "720p": "3",
          "576p": "6",
          "480p": "6"
        }
      },
      team: {
        selector: 'select[name="team_sel"]',
        map: {
          beyondhd: "1",
          hdsky: "2",
          ttg: "3",
          mteam: "8",
          coaster: "4",
          chdbits: "9",
          ourbits: "10",
          hdhome: "11",
          cmct: "12",
          hdchina: "14",
          pthome: "15",
          other: "5"
        }
      }
    },
    ACM: {
      url: "https://eiga.moi",
      host: "eiga.moi",
      siteType: "UNIT3D-Legacy",
      icon: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAYAAACNiR0NAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAABmJLR0QA/wD/AP+gvaeTAAAAB3RJTUUH5QQKBjskFFwRbgAAA11JREFUOMvNlM1vlGUUxc+5zzPvfLT2y5a0BqglgAFCcaGIYaEhAYIaTYgxLo1x5wL+BBf+Ay6NceOChYnGjVVj4wchkAhE1AKKWqopTBinZdrpFGbe97nHBSaSqNENiWd3N79zF/f+gP97ePdwfXwbIJFkXxbsfjfVEjwJvmZ5q1luLffyPmBs6T8AFzbuAIASyAmS0wHaJWhURCHghqA5gHNmpYbkPrkw97fACACXJ3aitdhEdXJ8E8nnSDxF6SFBQ3dquQrgssC3Bc6C1vynDePM1iNYT034g/0bPOCAES9JPgUgI5AgQOQoiL2QfqUw7yE254c3czlU9ciBd/Du6eN4YfHMHWD0hOpwjqXO0DSgpwHfSiGn/JRJ35kxJto0iZql4mSlu3alUe6rLo1MjnW7nfrVmx/kM3/AAIDvbX8GvWT9g5X8FUDH5BqN8FPB/UT0dI7GsoDtJMo91+lWebAWgX3mvsGNdYgnvZ1dZTmlo1feR7ydVSBxdDVkmwENy3wpwD8xaNal+q3lFRN4KY/lEIdHNlWYDko6IFOfyKrLrBgMq0RoAEDslPtJoObw+wAESCuSfoCrDRKLGyd94PZKjhCrA0EPJ/k4oWsulZ22X+CTIH+cWm81Xtv/KuJyrAlAj1ACZAAoB+QAjagwoVMbKhm0pfCiL5IysC7P52Vhj2h7BZ7/cqT/bMmxHtusAMItRbZA3JY4koTdAr+FuNauj7B/fHXCSulFSlsMyA06E3udz0tCIw+VZ53Wy5NXE7EeO8wQPLW6sXJN4E0BEw4eKmCNLuM3Ycr7k6r7otJhQg+AnId0pp63ry38ki8e3DnYJJQ7ilsSERvVGrbYSGfZV644eNHBDQIedVpw8KccqOWwPVRpkoRTWofUTpXx8HXnUj7anTj36dnX/zzszB2XrQdaeQ4WPxQ4lqRdIB4H8BggAiShLsGvDJhh8gtZeaD0/L4nihgy3f0p4cLCF5jaeBTd+sCaD/pvhcW1PGZDuWW1gjEWFnu5xUYRsvOJ8YRkH2We/wzFHmESEi4tzPxVDoeOvAmTYqKNJXK303YDnAAEya8bcN7A760ITZnS7Mcv/7u+dhx+Cy4hkOWBEMfMbFAk5Hl7NbXrF7cdy+PF40ifvXHvhHrP8zvmB8JDHarovgAAACV0RVh0ZGF0ZTpjcmVhdGUAMjAyMS0wNC0xMFQwNjo1OTozNiswMDowMLWCrh8AAAAldEVYdGRhdGU6bW9kaWZ5ADIwMjEtMDQtMTBUMDY6NTk6MzYrMDA6MDDE3xajAAAAAElFTkSuQmCC",
      asSource: true,
      asTarget: true,
      uploadPath: "/upload/1",
      needDoubanInfo: true,
      seedDomSelector: '#meta-info+.meta-general>.panel:has(".table-responsive"):first table tr:last',
      torrentDownloadLinkSelector: 'a[href*="/torrents/download/"]',
      search: {
        path: "/torrents",
        params: {
          name: "{name}",
          imdb: "{imdb}"
        }
      },
      name: {
        selector: "#title"
      },
      description: {
        selector: "#upload-form-description"
      },
      imdb: {
        selector: "#autoimdb"
      },
      tmdb: {
        selector: "#autotmdb"
      },
      mediaInfo: {
        selector: 'textarea[name="mediainfo"]'
      },
      anonymous: {
        selector: '.radio-inline:first input[name="anonymous"]'
      },
      torrent: {
        selector: 'input[name="file"]'
      },
      videoType: {
        selector: "#autocat",
        map: {
          movie: "1",
          tv: "2",
          tvPack: "2"
        }
      },
      category: {
        selector: "#autotype",
        map: {
          BD100: "1",
          BD66: "2",
          UHD50: "3",
          BD50: "4",
          BD25: "5",
          remux: [
            "12",
            "7"
          ],
          encode: [
            "8",
            "10",
            "11",
            "13"
          ],
          web: "9",
          hdtv: "17",
          dvd: [
            "14",
            "16"
          ],
          dvdrip: "13",
          other: ""
        }
      },
      resolution: {
        selector: "#autores",
        map: {
          "2160p": [
            "1",
            "1",
            "2",
            "3",
            "12",
            "8"
          ],
          "1080p": [
            "2",
            "4",
            "5",
            "7",
            "10"
          ],
          "1080i": [
            "2",
            "4",
            "5",
            "7",
            "10"
          ],
          "720p": [
            "3",
            "11"
          ],
          "576p": [
            "4",
            "13"
          ],
          "480p": [
            "5",
            "14",
            "16",
            "13"
          ],
          other: ""
        }
      }
    },
    Aither: {
      url: "https://aither.cc",
      host: "aither.cc",
      siteType: "UNIT3D",
      icon: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAABO1BMVEUnPUA0UVVAZWpQfoRTgolJc3lIcXdSgYc5Wl4zUFQfMDIuSExCaG1SgYhckZhimKBbkJdajpVPfIJEa3Bdk5pXiZBLdnxFbXI4WFwvSU1PfYN1paxvoahsn6aGsLZhmKBbj5ZRgIZVho06W182VVlYi5Jgl59elJyLs7miw8eoxsqryMywy8+px8ucvsNrn6ZflZ0yTlJJcng/Y2iavcJtoKeBrbNelJtDaW4rREcxTVE9X2R5qK5KdHoqQkUoP0IsRUiNtbo3VlomOz5NeX8lOj0jNjkeLzEgMjQiNDchMzYkODslOTxYipEoPkEiNTgbKiwZJykcLC4dLS8uR0tBZmsaKCoZJig+YWYSHB0XIyUWIiQWISMfMTMRGhsVICIUHyATHR4cKy0QGRoTHh8YJScQGBkPFxj////TR8cdAAAAAWJLR0Roy2z0IgAAAAd0SU1FB+UEFw4WFlDBxPsAAAEBSURBVBjTFcppX4IwHADgPwmWmuWRVmCZdF9W2mmFlnlWNtBGY7YxWfL9v0H69vk9AMpCRFVVLaotaksxiENiObmymkpnsupaLr++sQmKbhS2UoVtwyjulEx9F/b2Dw6Pjk9Oz87LF1rpMgtXlap5faNG8+nb8l0ldw8PtcenZwvq9Yaiv5jVV2jWI2+tdqfb679bmWQsAR/Nz8FXHNkOGvZH2qgBqPfdH2LXdTFy2j/NLhBc8+iYenP6VbpjYHzgC59zOtOJhSgEojNmbE5c4tafD4RxTKaMCCGkg6WEMAypx8kscdcOwhACSTjFtkddNJFMBMCoCIj0bIq4DKY++wfZwT9SAOOuEQAAACV0RVh0ZGF0ZTpjcmVhdGUAMjAyMS0wNC0yM1QxNDoyMjoyMiswMDowMNu9360AAAAldEVYdGRhdGU6bW9kaWZ5ADIwMjEtMDQtMjNUMTQ6MjI6MjIrMDA6MDCq4GcRAAAAAElFTkSuQmCC",
      asSource: true,
      asTarget: true,
      uploadPath: "/torrents/create?category_id=1",
      needDoubanInfo: true,
      seedDomSelector: ".torrent__buttons+.panelV2",
      torrentDownloadLinkSelector: 'a[href*="download.php?id="]',
      search: {
        path: "/torrents",
        replaceKey: [
          "tt",
          ""
        ],
        params: {
          name: "{name}",
          imdbId: "{imdb}",
          sortField: "size"
        }
      },
      name: {
        selector: 'input[name="name"][class="form__text"]'
      },
      description: {
        selector: "#bbcode-description"
      },
      imdb: {
        selector: "#autoimdb"
      },
      tmdb: {
        selector: "#autotmdb"
      },
      mediaInfo: {
        selector: 'textarea[name="mediainfo"]'
      },
      anonymous: {
        selector: '.form__group input[type="checkbox"][name="anonymous"]'
      },
      torrent: {
        selector: 'input[type="file"][accept=".torrent"]'
      },
      category: {
        selector: "#browsecat",
        map: {
          movie: "1",
          tv: "2",
          tvPack: "2",
          documentary: "1",
          concert: "1",
          sport: "9",
          cartoon: "405",
          app: "10",
          ebook: "11",
          magazine: "11",
          audioBook: "14"
        }
      },
      videoType: {
        selector: "#autotype",
        map: {
          uhdbluray: "1",
          bluray: "1",
          remux: "2",
          encode: "3",
          web: "4",
          hdtv: "6",
          dvd: "1",
          dvdrip: "3",
          other: "7"
        }
      },
      resolution: {
        selector: "#autores",
        map: {
          "4320p": "1",
          "2160p": "2",
          "1080p": "3",
          "1080i": "4",
          "720p": "5",
          "576p": "6",
          "480p": "8"
        }
      }
    },
    Audiences: {
      url: "https://audiences.me",
      host: "audiences.me",
      siteType: "NexusPHP",
      icon: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAQAAAAAYLlVAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAAAmJLR0QA/4ePzL8AAAX2SURBVGje7ZhbbJRFFMd//y+bzaZirbUW01RCSCWE8EDWSrxgo0QJIcRboKJCgkL8SFSCEhHhwRglDcE+EIJxi/UWFYkGFa+YYijSxigBFTVyicjFprY0gWJYWpaOD/t1drbd7drt1heZedg5Z+bM/z/nzMye+eBSuVT+70V5GRVTMUjZZrqHNCoaZNPGuXxZ18sMqvU5jO7AlBvM1eYKM8FcYzDcAeDlAR9iQQb1AoVyWa4EVjKP61jJlYEuDwLMpjyDtpzZuQzHMg8POMpxikZA4OEs+sW5DPfwPgdp41YidAa6YW9ClXOCcCDs5iSV1ARSL9eajqyGUQbukhXsy2P5espuu7hKQaWKW81TeUw4THh0wMJtBdWCtlrNgbxO9bAIVDsHb5bKdEZlmuXoqkebwCYLdUKelslomTydsNpNowsfUZeFWiu0X0b7hdZabZcio0lgvuPsKkWDVlRVjn7+aBLYYWGaQRuD9kZQs+3ZMXrwlbpoYRY54ehSRItsz0VVjhaB1RbkrMao1nF7rcborJVWjw48OmwhGtPCYbQD1Gilw6NyG2i6Azg9LRxGF1WZ1l8zcrzBBF630x+UG47A7UIHrfR64eHdGK+S54Sj3+2eVrl7pNAEUrv8gipVkyEjqlGlLqROSaEJpM75F6A3MxB4E/SZe08UEr7K2XJzVeyE46jj9mLNdbZlVSEJvGAn7lRYS5xwVDtuX6KwOlP/FYWD93TMTrsR1GKlT0CfWKkFtMFKx5RPupeRwEwn0lM1yZHuAd3jyJM01ZFmForAFjvlfqF1VvpLYVBYf1nNuuAvOlm3FAa+xMn5limkP620Phix3mr+VEiPWymukkIQWGon7FGZ5jgunhyMmOzo5qhMPVZamnv+HK8Zudn+dnNKqTfB3zyhVLv/5nvYfKrtzA2kxXrFjHD9U5zVzVK5s7rMtUflaUnqlJEGoD4tvstzwBsZLVfISVJzPVmHDkHaM/Qtk5BHQ07OnknobVYF0gI9YxL5r/8uZ2UTh2E30bG7ayQB+NBO8w1og3r+Vd0A+sZafpg/vLvlHkl7EwxduxTRI+62zJdA6hl6VsVpSWiuWpv2j5nfkzXtGXpRPWk5YK6aPn7IJ2vWPlXzfZauZ9mdUV9DXRaLG8ze4XtgU5bVnVFRFosincliM/wn6xBbboiM18mcB23LbDbZLqKbaaMtY0/jELwbyfZ94Ga+HrYX/ptiN6EPGBrSfgFiuCOSmv5Walxs0Hi/lHLaY6dTdv29fojx9NIWS4D7ma6ZuJqBj4nzCzCDOHHO+gf8tX4JABuIE2cC0EWcOHHtBB4kTqc/gRLixFkO4E/yd9LJAbr8nY9WmGhyNHGeB38aRznIMR5NwloCJkwTESDMVwoDIc7zMq38bmbQ4o8BQjQRwQMivMpu02rCgMdedvEOISI0EQK/gmYifE6TaeIadcgjwkvs5ldCYNZziC853o+bKXPts61p/MA5PMJmyYAx481p+XogkEoo4Tnbt8K0U4Zn3tdJViQdzVR2cD/1QDHdzGYd27ITcEszD2kcP+umAfpuTWMnmwPvVfMTKYrTdZwIdze8Flsc+zLQdfAYLSwFbaaGbaxl4r8jEHhkUGKV4DwJx/o+PrJtjz76HD8C9NJLnwF4mTpzG7vY6heBcw+o1/Spwp/CeH4zvdYwyr10MEkDT38p+1hBKtV4l+mmNXmkzHeKAu/4W7ieo7E3AKg0m/SBzoGZoz3aS4RSouxxPdCqKXxLI78xkdZA9yt3Um66CZlXBxBoN1V8Rku/aNZxUt1JQlrPZA4xhjUmaur8YgBzhIU0Uw/UsZFiOggnL7rUTVhnqnUfp4jyLWsAKDa1CnNK25nXcBqAWRZwPgkg+Wn6RnkkzEL9SBEtEPvDv91s1lROKcohxgFokQmw1MdkzlHNi7Hf0wjEuv07GU8l7RxpAEyTLhf0krBX0ZM8DeY8cFXw7usD3mMbcL6hzx9LKBm82D7/eiZQYdp1JIbvcVlw4yWAW0wVRToSy/5d/VK5VP5n5R+u/MaPySKDiAAAACV0RVh0ZGF0ZTpjcmVhdGUAMjAyMi0wMS0wOFQwNjozNTo1MyswMDowMCAb1gQAAAAldEVYdGRhdGU6bW9kaWZ5ADIwMjItMDEtMDhUMDY6MzU6NTMrMDA6MDBRRm64AAAAAElFTkSuQmCC",
      asSource: true,
      asTarget: true,
      uploadPath: "/upload.php",
      seedDomSelector: "#top~table:first>tbody>tr:nth-child(3)",
      torrentDownloadLinkSelector: 'a[href*="download.php?id="]',
      search: {
        path: "/torrents.php",
        imdbOptionKey: "4",
        nameOptionKey: "0",
        params: {
          incldead: "0",
          search_area: "{optionKey}",
          search: "{imdb}",
          sort: "5",
          type: "desc"
        },
        result: {
          list: ".torrents>tbody>tr",
          url: '.torrentname td a[href*="details.php?id="]',
          name: '.torrentname td a[href*="details.php?id="]',
          size: "td:nth-child(5)"
        }
      },
      name: {
        selector: "#name"
      },
      subtitle: {
        selector: 'input[name="small_descr"]'
      },
      description: {
        selector: "#descr"
      },
      imdb: {
        selector: 'input[name="url"][type="text"]'
      },
      douban: {
        selector: 'input[name="douban_id"]'
      },
      anonymous: {
        selector: 'input[name="uplver"]'
      },
      torrent: {
        selector: 'input[name="file"]'
      },
      tags: {
        chinese_audio: "#tag_gy",
        diy: "#tag_diy",
        cantonese_audio: "#tag_yy",
        chinese_subtitle: "#tag_zz",
        hdr: "#tag_hdr10",
        hdr10_plus: "#tag_hdrm",
        dolby_vision: "#tag_db"
      },
      category: {
        selector: "#browsecat",
        map: {
          movie: "401",
          tv: "402",
          tvPack: "402",
          documentary: "401",
          concert: "408",
          sport: "407",
          cartoon: "401",
          variety: "403",
          app: "411",
          ebook: "405",
          magazine: "412",
          audioBook: "404"
        }
      },
      videoCodec: {
        selector: 'select[name="codec_sel"]',
        map: {
          h264: "1",
          x264: "1",
          hevc: "6",
          x265: "6",
          h265: "6",
          mpeg2: "4",
          mpeg4: "1",
          vc1: "2",
          xvid: "5",
          dvd: "4"
        }
      },
      audioCodec: {
        selector: 'select[name="audiocodec_sel"]',
        map: {
          aac: "6",
          ac3: "18",
          dd: "18",
          "dd+": "18",
          flac: "1",
          dts: "3",
          truehd: "20",
          lpcm: "21",
          dtshdma: "19",
          atmos: "26",
          dtsx: "25",
          ape: "2",
          wav: "22",
          mp3: "23",
          m4a: "24"
        }
      },
      videoType: {
        selector: 'select[name="medium_sel"]',
        map: {
          uhdbluray: "12",
          bluray: "1",
          remux: "3",
          encode: "15",
          web: "10",
          hdtv: "5",
          dvd: "2",
          dvdrip: "15",
          other: "11"
        }
      },
      resolution: {
        selector: 'select[name="standard_sel"]',
        map: {
          "4320p": "10",
          "2160p": "5",
          "1080p": "1",
          "1080i": "2",
          "720p": "3",
          "576p": "4",
          "480p": "4"
        }
      },
      team: {
        selector: 'select[name="team_sel"]',
        map: {
          other: "5"
        }
      }
    },
    AvistaZ: {
      url: "https://avistaz.to",
      host: "avistaz.to",
      siteType: "AvistaZ",
      icon: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABYAAAAWCAYAAADEtGw7AAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAABmJLR0QA/wD/AP+gvaeTAAAAB3RJTUUH5QUPDicuFlMtFwAABCJJREFUOMu1lW1olWUYx3/3/TzPeT9nZ+7NHecr25TFFPFl2UJNtJqURUYFkVFQoCAlTIrCXiDB8IuUFGqCJYn2oZJEhH0Im1NC0G3OaJ7N6Uhzm562s7Oz85w9z3P1wQ2cVh+s/nB9u+7ffV339XLD/yT1L86FgKlAAMgDvYD9t+DtEc11T3SDX5WVKjUjrIg7wtgQ3NiW8VIn87IMeBqYDlSOX5AB9gI7AA/AnAB+ZkHPGMaagLe03G9siMIKS0hoCAh4KNIvofraBqVi2GOKC1lgFDgJ/AI4wHKgBxhSAE1zNKkRL7Jk9sw3SyLxzYFrl0qVYyMo9HieWQ+yAl2O0JyT9JEhOXTRpgC4AMwDHgVc4ArQah6t0fzmEVod5aMSX36TWVxgySCIA0pBly3s7hd+yghBDcvCisqQiq3SrE/2SVNeKAeqgONAB9AC9Jjr3vLTvdd+tVipjUbUsMRyIW6BbYMCx4IZLhQBHRnoTguFGaE6rIoVPD9esIPAaeB34BzgmM0H7Jr5MTabiI8pIVSijHSqlayCMp8wTytqsopnA9AaFE5pQfthSRw1amD4DZLHr9MGnAIuT9TMnFbIC0EflYgCXxroo1PyTI+C6lPY7eDLKkoRUgIRv2LqLKHDgVEPttSqkuIQya+6JHtnd+lIAQ06ipaYQpm3uHnjZ5ygQ7mGs+3w4rDHOQQDiAFeDhLXFLVBiEdgfkIVf1Cvwn+8rm/cCTatmFRhKhABy09vOszMWAp93qUrI3yPUCfCEq1ZrxTPALmssLFdWFmnSJTi681Kdbxi8khoYoSJCCoijJTXMDpnFaUVJciIUCaKEmCf5/GG65IUQQM/ukKbT3iqFiQiECFOzeRBMwkxIiYFWinOX+0gELwMRWl+CEEjLv1AP/CJCM2uy3bD4LAIK2ph9jTwBIBBMjIZPBYkiY/FoqC13+Z0t0tqKE/7tdvACcXHO/851+WBCBx4UKEjkPfI2w7J1NDkiHXG4IQXwsv7hLqFCSrmLuZsLyyqhHfXQti67TgdeF9pChQYU6HTESQIY356BxzO/zp4F/h6Tg7nLLrNMCyoCrPlyRAtO6Pseg3SGpzxDJMKhmqEdUth2IOqWSBBSGv5bvk2udp8afJT6IcbjYsDjux2feStgCZRlKOk2M87h+DTY2A7tx1zAj0zhbpHYGAQBkYgZ0rr1Qx7LuyHt7+8K+JjO13O9LD/Zo49rhFydLSaIy3wbfO9S/hmCuqroSAELUmupF221q+g++sW/lpNu+DIh0R7ji58b/hE1cArj2kB7rENq5Fb3+A+vpQzpYWsBNi1lX/WF42w/WWM059Tv2gu+4BOIF0Ux9aaUaC/oY7mzoNs+XgT5SL39/kYwDTL5KEnlrM2HGQNUOv3Ed25QzF/wX0x/xv9CdGEqkHFq79tAAAAJXRFWHRkYXRlOmNyZWF0ZQAyMDIxLTA1LTE1VDE0OjM5OjQ2KzAwOjAwBxpkNgAAACV0RVh0ZGF0ZTptb2RpZnkAMjAyMS0wNS0xNVQxNDozOTo0NiswMDowMHZH3IoAAAAASUVORK5CYII=",
      asSource: true,
      asTarget: false,
      uploadPath: "/upload.php",
      seedDomSelector: "#content-area .block:last table:first>tbody>tr:nth-child(3)",
      torrentDownloadLinkSelector: 'a[href*="/download/torrent/"]',
      needDoubanInfo: true,
      search: {
        path: "/torrents",
        params: {
          search: "{imdb}",
          "in": "1",
          order: "size",
          sort: "desc"
        }
      }
    },
    BLUEBIRD: {
      url: "https://bluebird-hd.org",
      host: "bluebird-hd.org",
      siteType: "bluebird",
      icon: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAACGVBMVEWotrlCjJo7l6k6laY7l6g/jp6brbE6f41G2vRF2PJF1/FF1/JH3Pc8j54ueok7vdU4tc04ts06vNQ5jZwra3gtnLAtmKwuma0rl6splaoqlqotmK0wnrMzeoclWmYyiJknfY4ieYoieYsheIosgJE2iJg1h5g2iJkwg5Qhd4kgeowsZnIuV2F3rrxBf4wSWGcYXGsXW2oWW2qDt8Oq2OOg0NyVxtOAtcNjnaspbnwiUVswUFh7r747bXkAMDwEN0IENkICNEAFOEOYxM+l0NtjkJtgjplnlaF9sL1nm6gjRk8qRU2Cs8FkkZ1Gb3lOd4FReYNVfYdGbXemztiLs70AHCYAIiwAIStHb3mGucc3UlsqQ0t+rryKvMqcy9ep1uG13+vF7vinztibwsx7oqwAHCUBIywAGyQoTFY7V18uTFR9sL5RgIwjUFsoVmEqWGIgTVgdS1YSQEsTQUwXRE9biZV9sb80VFwzWWF3rLpAeYYJSFYPTlsOTFoPTVt5qbSbxtKNu8iCsb55q7h4rLtWkJ0iTVctXWhgorE6hJQbbX4fcIEecIBsrbqDvcp2ssBtqrhoprVRl6YjdYYoX2ooZnIrk6cpj6IqkKMqj6MmjKAnjKAojaEpjqIojqEli58xdIItdYQ3s8o1rMM1rMI3h5Y2foxE1O9C0OpCz+lE1vE6j56Yqq9DmalAqLpAprhCnrCGn6X////cFElzAAAAAWJLR0SyrWrP6AAAAAd0SU1FB+YDAgQyIDB3PAEAAADuSURBVBjTY2BgZGKGAxZWNgZ2Dk4uOODm4WXg4xcQhAMBIWEGEVExcRCQkJSSkpCWkWWQk1dQVFJSUlZRVVPX0NTSZtDR1dM3MDA0MjYxNTO3sLRisLaxtbN3cHRydnF1c/fw9GLw9vH18w8IDAoOCQ0Lj4iMYoiOiY2LT0hMSk5JTUvPiMxkyMrOyc3Lyy8oLCgqLiktK2eoqKyqrqmpratvaGxqbmltY2jv6Ozq7u7p6e3rnzBx0uQpDFOnTZ8BBDNnzZ4zd978aQsYFi5aDAFLlixZvHjRUoZly1esRIBVqxnWrF23Hg7WbdgIAFw/WUNqMtpuAAAAJXRFWHRkYXRlOmNyZWF0ZQAyMDIyLTAzLTAyVDA0OjUwOjMyKzAwOjAwrsTcpgAAACV0RVh0ZGF0ZTptb2RpZnkAMjAyMi0wMy0wMlQwNDo1MDozMiswMDowMN+ZZBoAAAAASUVORK5CYII=",
      asSource: false,
      asTarget: false,
      search: {
        path: "/browse.php",
        params: {
          search: "{name}",
          incldead: 0,
          cat: 0,
          dsearch: "{imdb}",
          stype: "or"
        }
      }
    },
    BTN: {
      url: "https://broadcasthe.net",
      host: "broadcasthe.net",
      siteType: "gazelle",
      icon: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAABmJLR0QA/wD/AP+gvaeTAAAFR0lEQVRYw72Xa4hVVRTH/2ufM/ecO2rWlI+iLClUyuqLVPSQRDR6CzpjZYUladibUqEv00QfytA0GfEZZhFqokWFEoE9JdIgSEIoyyJxepjPmXvP2evRB7t3zp17Zxyv0IYFh7PX/q/fXnudxT7AGYyofedlAxbuGH4mGlT3yrd/vy62dBUIscAt9fdf0v6/AeTbv78Ig+LdznQoABiRpV4n8qwxO05Xy9W1+zicQpwOhTAgDLCnMKTx9UiFdQEIO5DAKt5pXdnsHWDTnlwuaWwxR5M0jDfKDyu2o61NAQCaVPtTFscI7+wfHxE9oEK7fc69iZaLCrXC1D6C13+M4mK0NiRd36D8YC49sTkYdf+d5XnPANew0lj3w+V54fcC9rMa4JfnE78RKw809g+gfc/AeJAsd7AZJEKkCqeab7BwejeAAt5XGqfl6SiIZjrVs0kVJEJkfEccdW7Bmj1NpwSIG4NnHdlDJExQAVQAU4NPjpWdNAHEV1omA5byLlPV0noSJgeZHIfhwr4Blu0cQypzoUJmipKJyt4i+IWyHycnd1xhxfJ0yic+VOiOrAZUiJRnYO2eCbUBWjfloji/BdAh5Z2rwFTAheJsPDS2o+zbc/c9MoA547qKOWlWkV+yWjCNIpMNWLy9qQogHjriBlIZlU29KYulSSs/Nu7LikwxAz6ttEwNAABmXHXYuPikCXdmj4JEzstFTZOqANSF15LCQQQlMy/7i52HV1QVqq9xBD6tcks6fv0YIt9lNUnFuSCcUAUQFLumgpnAArDAWEBJ4T3Mu+WvagCPrChEAOUqN7S1pHbiyAr7T7NklBRurQS4uTU0F55F2bMHGEf/3gxUNryT6TpFDWRGsbNhg6ketNIxqADOnYX5aweVAZrGnjORlC+FMkrm0s4jhbapX9cSZfHHrSeA+qQmQdsEdoXjR7LaUB48MIzvLQNYQ3QO2AeljmbMoKRo6GX4v45tNJF9xmImYqp6oHisa1Nv/pQWKjum92Sw7gyQ7zKYIGumvcYH3prXWUyP3yjGr6pwe1GK12PVk/t6X2AV2lAB0pMbDAHgH0s+yav8CbOhwMlLggVBI55aPQxLH/mjpuby+R0psAD9GOqCHCRTI84lZvpFdxG2P38IadphFVUtjfl83NyfAH2NAU+snGzkRlLp0xaBpemhrkWzd3UDADBOdkHZuqs6JYvyLZi9srHu6K2tjs89727i1FV+NcnecjK6AexdeK+lWw4Jg5SvCYcMGFc3QDLqEqc8hUo3J2GA2Uz0/SqAROhrmBzKFgvBotCF6zB/9YV1bN9FQbAYaudXFDdpAWYfVQHglZajzH6BiiYQRcmcyMgozK/A42sv6HfsZ9Y0Rc+PXuJM7yIVKmmZqKqXJclL9+yrBgDgX37wTRi/36NpwKncGg9q+DI3743pp4odPL3y9jjKfeXUP0rqKatjqt+k3x16MetffZFcsO6KWGQzuWA0wSrmzWAGfK7stzmTXeX2G4YwR1dR0HA7gSYSUZWuAh3Meh8vnrWjbwAAmNs+PG6MPnPAqJ5T/7UnNYCzb8gQgsjVEjSgo2AyAYvm7O051+tVOvf4sispzK13RFcTWV1XbgOZwX5ho4f5tdmf1fLpW/i59QNyvnONczaNjIKeR9J3YKgRfZpYYRqWPHOkN99TCzY3B9GQm25D6O5ywJ0gGlZroXU/HBaHrUixLQ32foBly5K+5E8vtc2L88EwNyk0NxNhONipjAVAQu5nMj2oIls9H96MVW1d/ZWs/++4uTmIcfEIc+SSn47+hm9X+Xpk/gV3p5H+s+SSlQAAACV0RVh0ZGF0ZTpjcmVhdGUAMjAyMS0wNS0wM1QxNDoyNjowMyswMDowMDXaY4EAAAAldEVYdGRhdGU6bW9kaWZ5ADIwMjEtMDUtMDNUMTQ6MjY6MDMrMDA6MDBEh9s9AAAAAElFTkSuQmCC",
      asSource: true,
      asTarget: false,
      needDoubanInfo: true,
      uploadPath: "/upload.php",
      search: {
        path: "/torrents.php",
        params: {
          action: "advanced",
          imdb: "{imdb}",
          artistname: "{name}"
        }
      }
    },
    BTSCHOOL: {
      url: "https://pt.btschool.club",
      host: "btschool.club",
      siteType: "NexusPHP",
      icon: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAYAAACNiR0NAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAABmJLR0QA/wD/AP+gvaeTAAAAB3RJTUUH5QQKBwQr3f9M9AAAAz1JREFUOMt91M+LHXYVBfDPefPmR2ZeY0tnWoyxVgihrT8KQoo/SmwUN23RKtGdiAsFS7vRko1/QYdUEMGFS90KcSWoBIRY6mS0oRoTqVLjj9bEpI2pjUle5r3j4k1k6sID39W953A599xvbGPpu2dN3yoDu9UeHMRS2RNeR8ogXMCb5BTOM/13suLGM/eCwOLRM7CEfZkJ3UlW6JsYmwkOMIfbKltYoOdbL0jOYWv8zP2yePSM1m2D5PFwD21C5VTa1/Bak6tUarnskaxq908pRq1T1V9qxsNp7Q6fo7vDivhV6oXE65Lp1W/cbwfGK8+d/WcYTJPTaQ+WEfa3dk3rRObXzzySeGgQBpwIm5Kt/xF6G0bPvexmtyRZaPuB1qFpO5nW8cyv/+6BJJPZ82fcvP5/xHZi/uhZWNC+a1LT1iRrz25gEoaPiYMt+GuS5/FiMcQWS+EOLGN3dS+up/6B82K5bA2bqOGd4cnwoRk3I2zgS/TKFo+RR9vux91JRuosTpf3hC3MqeVhZsl5n3ZSvphYxVe2Y/RuPI0n1Mt4EYfxE3wTnxVPkO9rfxSWB22XtYdxCfdVPlNdxc+rH8R8+Gr4PI4luYLvjTN+VWzip9WH8WFsDvGx8ClxDL+pnsA9eAqb1R+QcWKOHK6exrlFiyIbE9OXwpfF18u5QeIRyVLlZOVPZEAen20qGwOD8bYtH8X78UM8VB1NTQ1YDHuxivcO1RtNx/gWuYB5eqF8e2p6cc4cM8LX8DNyLHxh5mEv4z58Eqfwi6w9u3F7kz1YjRTj6ivVNyKTyDw+YhaZ43gLi/g4Hsbd+C1+jFeyur65Fi1RvRyZXDxyAKytb97KcMzu1q3ajvoC1jrr2RpG98286a7MJjiztn6yjFw88sAtbndeyNr6S+qGMqQPhkfxLxwfkNPkUrlUPlE9hHdwNTsmfNtUNR6EVXoYny6Xw+/DH7ZJXS6H1F24FuaanNNeCH8vYyGyq+yl78SB7f9xiBOR5+mN7PBiSXvvLBJGYk41XC/XxBLZhZF2GQuSv23b9EfcvHjkwCxgsPadk1zFwO2tu8SDYV7ta1zByvY5vqq5Rn+d5C/b3v13Wf8BYeJvdWEcGZ8AAAAldEVYdGRhdGU6Y3JlYXRlADIwMjEtMDQtMTBUMDc6MDQ6NDMrMDA6MDC0QHbWAAAAJXRFWHRkYXRlOm1vZGlmeQAyMDIxLTA0LTEwVDA3OjA0OjQzKzAwOjAwxR3OagAAAABJRU5ErkJggg==",
      asSource: true,
      asTarget: true,
      seedDomSelector: "#top~table:first>tbody>tr:nth-child(5)",
      torrentDownloadLinkSelector: 'a[href*="download.php?id="]',
      uploadPath: "/upload.php",
      search: {
        path: "/torrents.php",
        imdbOptionKey: "4",
        nameOptionKey: "0",
        params: {
          incldead: "0",
          search_area: "{optionKey}",
          search: "{imdb}",
          sort: "5",
          type: "desc"
        },
        result: {
          list: ".torrents>tbody>tr",
          url: '.torrentname td a[href*="details.php?id="]',
          name: '.torrentname td a[href*="details.php?id="]',
          size: "td:nth-child(5)"
        }
      },
      name: {
        selector: 'input[name="name"]'
      },
      subtitle: {
        selector: 'input[name="small_descr"]'
      },
      description: {
        selector: "#descr"
      },
      poster: 'input[name="picture"]',
      imdb: {
        selector: 'input[name="imdbid"]'
      },
      douban: {
        selector: 'input[name="doubanid"]'
      },
      tags: {
        chinese_audio: 'input[type="checkbox"][name="span[]"][value="5"]',
        chinese_subtitle: 'input[type="checkbox"][name="span[]"][value="6"]'
      },
      torrent: {
        selector: 'input[name="file"]'
      },
      category: {
        selector: "#browsecat",
        map: {
          movie: "405",
          tv: "406",
          tvPack: "406",
          documentary: "408",
          concert: "409",
          sport: "410",
          cartoon: "407",
          variety: "412",
          music: "411"
        }
      },
      videoCodec: {
        selector: 'select[name="codec_sel"]',
        map: {
          h264: "1",
          x264: "1",
          hevc: "10",
          x265: "10",
          h265: "10",
          mpeg2: "4",
          mpeg4: "1",
          vc1: "2",
          xvid: "3",
          dvd: "4"
        }
      },
      audioCodec: {
        selector: 'select[name="audiocodec_sel"]',
        map: {
          aac: "6",
          ac3: "10",
          dd: "10",
          "dd+": "10",
          flac: "1",
          dts: "3",
          truehd: "11",
          lpcm: "5",
          dtshdma: "3",
          atmos: "3",
          dtsx: "3"
        }
      },
      videoType: {
        selector: 'select[name="medium_sel"]',
        map: {
          uhdbluray: "12",
          bluray: "1",
          remux: "3",
          encode: "7",
          web: "10",
          hdtv: "5",
          dvd: "6",
          dvdrip: "6",
          other: "11",
          cd: "8"
        }
      },
      resolution: {
        selector: 'select[name="standard_sel"]',
        map: {
          "2160p": "5",
          "1080p": "1",
          "1080i": "1",
          "720p": "3",
          "576p": "4",
          "480p": "4"
        }
      },
      team: {
        selector: 'select[name="team_sel"]',
        map: {
          btschool: "1",
          zone: "13",
          btshd: "2",
          btstv: "3",
          btspad: "4",
          wiki: "5",
          hdchina: "6",
          hdbint: "7",
          mteam: "9",
          cmct: "10",
          ourbits: "11",
          other: "12"
        }
      }
    },
    BYR: {
      url: "https://byr.pt",
      host: "byr.pt",
      siteType: "NexusPHP",
      icon: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAYAAABXAvmHAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAABmJLR0QA/wD/AP+gvaeTAAALy0lEQVRo3t2a+W+VV3rHP+e8y/Xdr21svICNsRlD2BogYcnCEkiGIQyQPWnapB21napVpUr9oVWr9m9oNVJVVdOO1GRESZtkGkNmMtAkJBDAmbAn7MbGGOPt+u7vfbfTH66NMbGNgQg0faSr99XVOc95vs9znu2cVyilFL/FJB+0AN85ACGEeNBC3QkJVSKUUvi+wvUUg0MFznakuNKTw7Y8jICktjrMnFkRqmeECAclmlbCLqUcBY5S6r4/9VEkSikyWYcjx/p4670LnLmYJJ2x8TyBJhXRsEllZZA1K6pZv7qO+S1x4lETY8RgD8pwQimlfN+nYLns3tvFP/7baa5ez6FrckLESkFTQ4QtGxrYsKaO5jlxgkEN7QFZQo5q/9ylFD975xzX+vJocnJtCim4fCXLT3ee4Z/+/TSfHeklmSri+aVteL9JB3Bcn4/2d3OuI4WUYkpBBKAAq+jz6aFrDAxZDCWb2PDELKorypD3Oa7pAOmsw8Evr+N5oGnTmzhqwlNnkxQsF9eHzetmUzUjyP30BgkwMGjR25e/K+1JKbjUlWHnLy7w8cEeslmH+7mTSgCSRfKWe0+MLlxOs6vtIu3H+nFdf2Qb+ijfAeXfOUPlAz6304YEyOYcbOfe1KYUfHN+mF1tF+juyZYA+DmUcx7lD98ZI99G+VmUn0H5OZTvolwP37bxXWecj+rAiMbuSX6EENiOzxdf9fHhx1d486VGgrRD4SMoexzCW+B23qE8lJ9GuR3gXgNslIigaMTp03EGB5HBIEZdPSKeACFKADQpvjPHy+Vddu+7zKbVV2kpfxusw+APQvApkMEpFO+i3KtgfYyyDuHn+1C2hTCD+E4zQ+8oCmeuIKMRwmvWkvj+ZvSKyhKAsjIdXQfX+25AWIVO7NTnqOAhhMpD8TjKHwQ5a3LNO12o/Pv4Q3tw+gexzqZx+rLoCRfkEZLvFileyoBhkD9+Ej0aJr5lWwlAPGZgGhKreBfOdguFyiy2rjlMXfwwKKv0pzcIbjfoEwNQXi8quxOn53/IH8+ROWBTODGEM5RDi/gIM43d6aKKgG1hnTjK8HvvEXvqmRKAikQZoaBBOntvkUgIn+WtHbyw/jDxYKGU8YREqTzC7QBWcqsfKL8I+Q9xe3Yx/P5Vhn8lsS5mUdkCylO4EpQAoUpThQDlOhROHMNPp0pRKBEzmVERwPfv3pOVUsRCeTavPIrlGHjjWCmUdQyUO268VyjgJA/g9u4kufsyAz8fJn+iHz+TL0UjeWP6t8hNDuLlcqUhoaBOc2P8nrQPigWNPZiGx9sfPcFAKjyy7ojG7eM3tpTyfbx0isJX+3Gu/QuZ/ScZ3JnF7nZhVImjhrr1OfruFMH3SgB0XbJgXoJ7qYhDAZvlrR3sbV/C7oPL+OzYQ1i2PhKeBbhXwO1F+R7u9V6Gd79Prv0neJ0HGHxnGLvDA8X0ZFBAIASGUQIghWBBSzmxiHHXFWU8ksPQPb443cJgKsIHny/n8NfNpHJlI4smUc557N5rJN97h+H/+glmeTupXyfJHXXgDiOgWTsLGYmVAAgBTQ1Rmhtjdw3AcTUOnppHKhcC4PjFBn62Zx0HT7XiKgk4+JkjZPe9y/C7P8WoOA/KJvXLAqow/XWUAqRGaNkytGh0rCOrSARYs6KGY18P3RWA4WyYExcbUEogBOSLAdq/acY0YcWiDqrDg3gDn1A8W8BIXCK62iS118K+Orpv1ITO+m0EoFdXE9u4EWmaY019wNRZu6qW+plhRnvkOyHX0ynaASoTAVqbE5THy3B8neMXGujsX4yS9aAuEpx3mdh6Hd9SZD6zEUYZwcVLCcx/aGoHGPVtM0B03XpCK1aCEGMApBTMm5vgmXWzMHR5F7WRIBox2LqpkT/+3fn8YP1sImGd4YzJme5n8Ox1CKNAcAGYjTqpfQXcpCC86jGq/+KvqHj19xC6Pil3NZJTyhYvoeK11zGqqkty3zwoEtLZ+nQji+ZXlBKGum01O46WLqzk1e3NPPV4Pa9sb6F1bgLbFZzvaaV4cTZexkevkNjdHtnDDkZDE1V/8mfEv7+FwNzmyTU/EskCc+dR+cYfEnpk9Q2w4wBIKfheU5zXdrTQUB8ptY/TRKBJWLuqlqaGGJGQQd3MELGIiVIwmJY4nXm8dGnF3G9svJROYusPia7fgAiFKJw+ifK+HYpGVzdq6qj8/TeJb9mGFo2OyXzrhICpsXZVLS8+O5ea6tANS9yOdF0yZ3Z05DQDOrrSdPVkiUcNDF3iZ3MgwMspCmcdtBnVxJ/9IVo0htvfR/bz/eBPXItpFZWUv/Qq5S+8jFFVjbipdZzoZI7yeIBtTzfy0ta5NNRNzxK+r3Acf+Td5+ODPdiOx8pl1cypC+EOXUVPaNhdLsUrivCjjxBauATlumQ+/V+s06cnVL2Ml5PY/jyVb/4Io37WOOEnBAClxFZTHeL5HzTx2vYWWptjGLqYMjq5ns+Fy2l8X5HNuXz6xTVmlJfx8rPNPLYwim9fQivXyB118LM60SfXIsJhrHNnSO58Czc5OF5+BTKWILZ5CzP+6McEWuYhpPatA7RJ23hNSupmhtixuYk/fWMhq5bNJBIyJrWAUnCgvZeh4SKdV7OcvZSidmaIRx+uZn6FjdnQC0qQay+CDGLW1lE8d4aBf/1ncocOju3TkYdWXkH5tueo+fO/JPjQIqSmTRhmJ49bI9upsjzA+tV1xCImyXSRU2eSk47/+lySo6cG6OzOYBU9GurCRIMaVr4D+b00xYuK/DcOyikyvKcNdreR3vchfj53kyIkRl098W3bqXz9DYILF4M2uZhTAhgFYRgSARSLUxcsUgqSqSKHvurDNCRNDTGEssE9jFHrM/AfRZw+Ba5Fas8H4HuoXGZsLTOA2dRCYsfzVLzwMmZTM8KYuj67LQDfV3T3ZPnPtot0Xc1OOi4RN9n0xCxqqoIc+2aASFhnbkMU3F5k4AB2t0/qVxY4gFD46eGxyZpEhmOEHl5OYsfzxJ7ejFlXP2VimzaAdKZI274uPj9ynaI9cZiTUrDxsXpe295MR1eWgUGLRa0V1FTpKGs/yjrH0H8XKV4es+BoeBZmAGN2A5HH1xLfvIXwytXoFZVITZtWaTQlAM/zOXkmSdveLjJZByHGjhRHSSkoj5ts3dRI0+wou9o6UAqa58SIlXXgDfyCzP4hUnstcEcEv2FeKFu8lMS254ht2EigZR5aOMLIQtNKQFMCSGdtfvlJF53dmSmZxCImkZDBpc4MR08NIKWgsd7FdD4k/5uTDL1bwBu4qdMalUtB+OHllO94AaO+HmGYCCnvqJCcEsD5jjQHvryO46qRm5iJGWdyDm37OkllbLquZjF0n9kV7ajUJZIfWFhnvXFC3yABxY4ORKAMaQamLfS0AHiez5fH++npzd/WosNpm937urAdH8tyefShARa1DGFfbybbbqNs0GIxjLp6iufPge/dAJD/sp3i+XOYtbXT7CfH06SJzPUUl66kKTr+ba+PPE+RytjEoyZLWgV/8Jyicc4m3IF63P5S5AqvWkPlj36MrKgcOW4p/byhIawzX09aB921BaQoFXaT0c3WqKku48mVtax6uIpYcIAVi1spi8zDLssjI1FEPEb5K68TXvUYyV07yV/vK6muVGTh9PcxvXbsTgBIWLGkig9+3Um+4I1l+tFUr0F5vIxHllbz5KqZLFs0g5qqEJqoxDQDCGlStnApNX/7DwhdJ7p+I1p5OcElS8kf/mLcWtOJ93cMQAjBYytqePPFVj451Ev/QB6f0m1lTXWQBc0Jli+uYsG8cioSgZGLPoEgWtohQqDPnEnlS6+ihEBGIggpiDzxJINvv4UqjiTFgElw0WJue3I9mZyj98S33v4BeJ5HNucxlLKwrJLjabokVKYRCZsEAxLT1G7ME0LciJJCCDzPG8dXCHCuX6f77/6a1J42hKlT8eIr1P7N36PHEyDlnd9WPohvJZz+PqzTJxGmQeh3ViBDobvm9UAAfJf0/+9jj982+j/RCce/QFliVQAAACV0RVh0ZGF0ZTpjcmVhdGUAMjAyMS0wNy0wOVQwNjo1NzowOCswMDowMIxwoSYAAAAldEVYdGRhdGU6bW9kaWZ5ADIwMjEtMDctMDlUMDY6NTc6MDgrMDA6MDD9LRmaAAAAAElFTkSuQmCC",
      asSource: false,
      asTarget: true,
      uploadPath: "/upload.php",
      search: {
        path: "/torrents.php",
        imdbOptionKey: "4",
        nameOptionKey: "0",
        params: {
          incldead: "0",
          search_area: "{optionKey}",
          search: "{imdb}",
          sort: "5",
          type: "desc"
        }
      },
      subtitle: {
        selector: 'input[name="small_descr"]'
      },
      imdb: {
        selector: 'input[name="url"][type="text"]'
      },
      douban: {
        selector: 'input[name="dburl"]'
      },
      torrent: {
        selector: "#torrent"
      }
    },
    BeyondHD: {
      url: "https://beyond-hd.me",
      host: "beyond-hd.me",
      siteType: "F3NIX",
      icon: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAMAAAC6V+0/AAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JQAAgIMAAPn/AACA6QAAdTAAAOpgAAA6mAAAF2+SX8VGAAACMVBMVEUAAAAJIO///wAAAP8IGvAWQ9wWQdsYSNgYSNkWQNgUPd4vgrlGuZU6n6w1kbMVPdwVPdsZRNEYRNUWQtkVQNkGGPGu/zQIHugZStkeV9EhXc4iYcwiYsshYMwgXM4eVdEYRtgSOeEeVtIiYcwkZskkZskiYMwdU9MRNuEVP9wgWs8jZcojZcofWdAUPt4RMt4fWs4kZskkZskQMeMeVc8kZckjZModU9IiYMsiYMwXRdkeVc8fZMcdVNAhW8qxwvNljuBTg9o/dtUgW80iX8n+/v/6+v709f7K1fgiYMsiYMoiYssiYMsiYssiX8siYMsgXMwgW8weVM8kZckdUs8XQtciYMwXQtgdU9MjZModVNEQMeIfWM0fWM0QMOEVOtQfWc0fWM4UOtkSNt4cUtEhXswkZckiYcsdVNARNt4WQNgdUs4gWswhXssiYcoiYcsiYMogXMweVs8YSNUkZ8klaMgkZ8glaMklZ8kkaMglZ8gjZ8hbidxJfNgtbM3B0PSete8kZssiZsgfZMdnkt729/7j5/xGeNkpacw6c9JMf9dnkd7N2vX//////v8ras0jZshKetrL1fjx8/36+v7+/v9GetYnaMp0muLr7/z+/v7k6vpnk9wjZslrk+Du8f3p7vxfi9w0cNDY4PnZ4vk1cdBNgdbu8vzv8f3s7/xJftYhZchgjdzr7f2vwPJVgtxTgtulufDo6/1mkN5GeNhcht4oZ8wmZstUgttHetgkZsmOuILKAAAAdHRSTlMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcbLvo9O3DcR4IXcz6+9JmCQ6N9viWEQeN/P0KXfX4aM3TIm7+dbr+/v7+wOf+/v7+6/T28/fr7L++cvtzIdEhafdjCZGMCA+RjA4IYNL6zF0IH2697Pb057prG30aCesAAAABYktHRI0bDOLVAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH5QQKBwYCrXu2GgAAAXtJREFUGNNjYGBgYGSSkJSSlpGRlZNXYGZhAANWRSVllZJSIChTVVPXYAOJsWtqaZeWlpeXlZWXl5bq6OpxMDBw6hsYllaUl1eWlABlKkqNdI25GLhNTEFiVdU1tdUVIFEzcx4GBQuQWElZXX1DY2U5SNTSisFapbS8rLqpuaW1rd2mqbqsvFTVlsGurLyso7Oru6e3z97B0akfyHVmcCktnzBx0uQpU3t7Xd3cPaZNKC/1ZPAC6p4+Y2bvrN6pU3tnz6kA6vdm8AE5ce68+b1AsGBhE8ixvgx+QMHy6kWLQYJLllZXAQX9GQLKqqrKm5Yt752/onflqiagirJAhqDg0qry1WvWrlu/YeOmzavLq0qDQxhC1UqrSids2bqtqWn7jp0TgI4PC2fgjdABKt0FsqGsCSQWGcXHwB8dAwwQUDABAZARHBsnwMAgGJ8QCRUDBp12YpIQKECFk1NS08pAgVyikp6RKQIJelHmrOyc3Lz8gsKiYjFxoAAAdfCapAG3hnMAAAAldEVYdGRhdGU6Y3JlYXRlADIwMjEtMDQtMTBUMDc6MDY6MDIrMDA6MDCSiKOlAAAAJXRFWHRkYXRlOm1vZGlmeQAyMDIxLTA0LTEwVDA3OjA2OjAyKzAwOjAw49UbGQAAAABJRU5ErkJggg==",
      asSource: true,
      asTarget: true,
      seedDomSelector: ".table-details tr:last",
      torrentDownloadLinkSelector: 'a[href*="/download/"].bhd-fl-button',
      needDoubanInfo: true,
      uploadPath: "/upload",
      search: {
        path: "/torrents/all",
        imdbOptionKey: "4",
        nameOptionKey: "0",
        params: {
          incldead: "0",
          search_area: "{optionKey}",
          imdb: "{imdb}",
          search: "{name}",
          sorting: "size",
          direction: "desc",
          doSearch: "Search"
        }
      },
      sourceInfo: {
        editionTags: {
          "10-bit": "10_bit",
          "2-Disc Set": "2_disc_set",
          "2D/3D Edition": "2d_3d_edition",
          "2in1": "2_in_1",
          "3D": "3d",
          "3D Anaglyph": "3d_anaglyph",
          "3D Full SBS": "3d_full_sbs",
          "3D Half OU": "3d_half_ou",
          "3D Half SBS": "3d_half_sbs",
          "4K Remaster": "4k_remaster",
          "4K Restoration": "4k_restoration",
          "Digital Extras": "extras",
          "Director's Cut": "director_s_cut",
          "Dolby Atmos": "dolby_atmos",
          "Dolby Vision": "dolby_vision",
          "Dual Audio": "dual_audio",
          "English Dub": "english_dub",
          "Extended Cut": "extended_edition",
          "Extended Edition": "extended_edition",
          Extras: "extras",
          HDR10: "hdr",
          "HDR10+": "hdr10_plus",
          "Masters of Cinema": "masters_of_cinema",
          Scene: "scene",
          "The Criterion Collection": "the_criterion_collection",
          "Theatrical Cut": "theatrical_cut",
          "Two-Disc Set": "two_disc_set",
          Remux: "remux",
          Rifftrax: "rifftrax",
          Uncut: "uncut",
          Unrated: "unrated",
          "Warner Archive Collection": "warner_archive_collection",
          Commentary: "with_commentary"
        }
      },
      targetInfo: {
        editionTags: {
          "2d_3d_edition": "2D3D",
          "2_in_1": "2in1",
          "3d": "3D",
          "3d_anaglyph": "3D",
          "3d_full_sbs": "3D",
          "3d_half_ou": "3D",
          "3d_half_sbs": "3D",
          "4k_remaster": "4kRemaster",
          director_s_cut: "Director",
          dual_audio: "DualAudio",
          english_dub: "EnglishDub",
          extended_edition: "Extended",
          extras: "Extras",
          hybrid: "Hybrid",
          scene: "Scene",
          theatrical_cut: "Theatrical",
          uncut: "Uncut",
          unrated: "Unrated",
          webdl: "WEBDL",
          webrip: "WEBRip",
          with_commentary: "Commentary",
          dolby_vision: "DV",
          hdr10: "HDR10",
          "hdr10_plus?": "HDR10+",
          hlg: "HLG"
        }
      },
      name: {
        selector: "#title"
      },
      description: {
        selector: "#upload-form-description"
      },
      imdb: {
        selector: "#imdbauto"
      },
      tmdb: {
        selector: "#tmdbauto"
      },
      mediaInfo: {
        selector: "#mediainfo"
      },
      anonymous: {
        selector: 'input[name="anonymous"]'
      },
      videoType: {
        selector: "#category_id",
        map: {
          movie: "1",
          tv: "2",
          tvPack: "2"
        }
      },
      torrent: {
        selector: 'input[type="file"][accept=".torrent"]'
      },
      category: {
        selector: "#autotype",
        map: {
          BD100: "UHD 100",
          BD66: "UHD 66",
          UHD50: "UHD 50",
          BD50: "BD 50",
          BD25: "BD 25",
          DVD5: "DVD 5",
          DVD9: "DVD 9",
          remux: [
            "UHD Remux",
            "BD Remux",
            "DVD Remux"
          ],
          encode: [
            "2160p",
            "1080p",
            "720p",
            "576p",
            "540p",
            "480p"
          ],
          web: [
            "2160p",
            "1080p",
            "720p",
            "576p",
            "540p",
            "480p"
          ],
          hdtv: [
            "2160p",
            "1080p",
            "1080i",
            "720p"
          ],
          dvd: [
            "DVD 9",
            "DVD 5",
            "DVD Remux"
          ],
          dvdrip: [
            "480p"
          ],
          other: ""
        }
      },
      source: {
        selector: "#autosource",
        map: {
          uhdbluray: [
            "Blu-ray"
          ],
          bluray: [
            "Blu-ray",
            "BD 50",
            "BD 25",
            "BD Remux",
            "UHD 100",
            "UHD 66",
            "UHD 50",
            "UHD Remux",
            "2160p",
            "1080p",
            "720p",
            "576p",
            "540p",
            "480p"
          ],
          hdtv: [
            "HDTV",
            "2160p",
            "1080p",
            "1080i",
            "720p"
          ],
          dvd: [
            "DVD",
            "DVD 9",
            "DVD 5",
            "DVD Remux",
            "480p"
          ],
          web: [
            "WEB",
            "2160p",
            "1080p",
            "720p",
            "576p",
            "540p",
            "480p"
          ],
          hddvd: "HD-DVD"
        }
      },
      resolution: {
        map: {
          "2160p": [
            "UHD 100",
            "UHD 66",
            "UHD 50",
            "UHD Remux",
            "2160p"
          ],
          "1080p": [
            "BD 50",
            "BD 25",
            "BD Remux",
            "1080p"
          ],
          "1080i": [
            "BD 50",
            "BD 25",
            "BD Remux",
            "1080i"
          ],
          "720p": [
            "720p"
          ],
          "576p": [
            "576p"
          ],
          "540p": [
            "540p"
          ],
          "480p": [
            "DVD 9",
            "DVD 5",
            "DVD Remux",
            "480p"
          ],
          other: [
            "Other"
          ]
        }
      }
    },
    Bib: {
      url: " https://bibliotik.me",
      host: "bibliotik.me",
      siteType: "Bib",
      icon: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAYAAACNiR0NAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAABmJLR0QA/wD/AP+gvaeTAAAAB3RJTUUH5QQKBwgUxywuxQAAA51JREFUOMvNlM1rXGUUxn/nvfe99733zkxnmk6bxDRaUGwWUsEiSPcF0X+g24JLN4LbLtwJurXQ7rqxuhTcuKiWWlxJaamC1CRtmpjJfGSSSe6dO/fjfV20paDQgiuf1QPnPL8DB86B/7vkZQ3Xrl0DaAEXRVzH97WNopgkSZib61qt9dfW2j/PnHnr5cDLl7/CWtvRWn+odfCl7/tdrQOiKCRJGiRJo/aU+qyy9vb+5DAYDXr/Bl65cvWZ7YIoa8vzwFXt69CYBqEJiSKNMYaytK6ZRLZG3P7kgMPJHv6z9A8/3sTzPGpbqwf37/u+1l+AOy/iKc9TQbPVxDnBGB9jQmazgtpGUtZ44/GAg4OUY91jz4FKKZTnnZ3l+aWqKn1r7Tta6+NBEJA0EowxhKHBGIPnefh+gOeHjHeHOGfpdueIIvMEeP36N4x62+equv54Vsw+qOpaBcpDeepp2MdEBiWKoigJQyGOI8bjMc5ZWq0WsUmwucX79d5v79+/e+e1qio/cs5eyNJDMSYiSRJ83wdxKOVjTBNbW0QcSinyPKfX69Fut4miiKqo0U7j7+2NvyuKgtFwoOYXFul05gjCgMgYiqIgz6dY65jslxw9GtFoBBwcHPJ4YwNfa5TnkaUZZVXS7R7H//mnG/6gv0OWZQxHu8RxTKvVYmVlhcXFBeq6ZjQa4zjAmAbD4ZCtrS3iOGZhYZE8z8nzKUkco0SQG7d+caPhgI2H6zxaX2c42CH0PY7PL7DwyiLLy6+yvHyKophSVRVpmlKWJe0jRzgxP0+apsxmM+qqYprnyKPersvSlOGgT2/7L3Z2tulvbbLd20bhOP3mKc6++za1i3j4cIP0MCXQAVprmq0mYRjSbrdptloIIKuPd74XkVopddrBG/ks59HaGg/++J29QR8lOUFkUapDv79LlmUA2Nqitc/c3BxLJ0+ytLREp9NB1jb7HlADnzjnPn3qTygRfzLZ597dO9y+dZOqLGi32wBMsynW1pRFQRzHJHGMDgI8z3tyemubfZxzLRFpACeBb4Fla21VFIVMp5ma7E+kKGZM9saMd4eMxyPWV1exRY7WIToMnwOfaW2zD2Ccc+8BsYjKlafO4dylsqy8uq4oi4KimFGWBVmakmUp6WFKmh4wy7MXf5vVxzsAr4vIBRFRAKIUSsSKSEeEi0VZHZlmGdNpSjHLX/4PXzDoGPC5iMyLSAUgIv8N+HQ1AN4/a38DST6z5HJSpzwAAAAldEVYdGRhdGU6Y3JlYXRlADIwMjEtMDQtMTBUMDc6MDg6MjArMDA6MDBZ+4VCAAAAJXRFWHRkYXRlOm1vZGlmeQAyMDIxLTA0LTEwVDA3OjA4OjIwKzAwOjAwKKY9/gAAAABJRU5ErkJggg==",
      asSource: false,
      asTarget: true,
      uploadPath: "/upload",
      name: {
        selector: "#TitleField"
      },
      description: {
        selector: "#DescriptionField"
      },
      anonymous: {
        selector: "#AnonymousField"
      },
      image: {
        selector: "#ImageField"
      },
      format: {
        selector: "#FormatField",
        map: {
          epub: "15",
          mobi: "16",
          pdf: "2",
          azw3: "21"
        }
      }
    },
    Blutopia: {
      url: "https://blutopia.cc",
      host: "blutopia.cc",
      siteType: "UNIT3D",
      icon: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAMAAAC6V+0/AAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAC91BMVEUAAAAAgfQAcdoAacMAbNcAduMAascAZ8UAZbsAct0AaMMAc98AacUAdOAAdeEAacYAdeAAe+4AcdsAaMEAbtMAd+cAiP8AjP8AbMsAduQAaskAd+QAdeEAdOAActoAascAaMUAacYAasoAd+UAdeEAdOAAdN8Ac90Ac90AaMMAaMMAaMQAacUAascAa8kAduMAdeIAdOAAdN8Ac94Ac90AZ8IAZ8MAaMQAacYAascAbckAdeEAc94Ac90AaMMAaMQAacYAdOAAc90AaMMAacUAdOAAc90AaMMAacYAdeEAc94AaMQAacYAdeIAc94AaMQAaccAdeMAc94AaMQAa8kAc94AaMQAc98AacUAdN8Bc90AaMMAacUAdN8Ac90AaMMAacUAdOAAc90AaMMAacUAdOEAc94AaMMAacYAdeEAdN8AaMMAacUAasgAdeIAdN8Ac94AacUAascAdeEAdN8AaMQAacUAascAeOgAdeEAdN8Ac94AaMMAacUAacYAbMwAd+UAdeEActoAasgAa8oAcNkAZ8UAc90ActwAcdwqiOAsgs8AZsIAZ8IhhOHI4PfM4PIlfcsbd8gmfcsfeckVdMcHa8QAc9wDdN2Uw/Dw9vzv9fuWwOYUcscWdMcwg8230+1cndgAZcIBc90Xft89k+Tj7/uHuuuAs+Pj7vgnfcsEacNenthKktQEdN0nh+Egg+BTn+f6/P7c6/na6ff7/P5Sl9YTccYCc90sieIdgeAAcNxiqOn///9qpdsAZcElfMsQcMYihOElhuFkqepsptsYdMccdsgAaMMEdd05kOQGdt1gpun+/v5ppdsScMYadcgBaMMJeN48kuQdguC72fXD2vAsgMw0juMRfN+nzvOuzusRccYFdd0fg+DY6fn9/v76/P3e6/cgesqs0fOkzPJ2sep3rd+gxei00u1xsOvT5vlPneebxu+cw+hRltXP4vN5r98Ufd8oiOITfN+RwO4YdcgmfssAct0Md9sNcMgAcdkAaMWf5sHbAAAAhXRSTlMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAJOIja2IU2CQQmZ7Lo/f3nsWYlBAIdWqbi/PzhpFgcAkHT+vrRPUby8EEv5uMrHdfTGQ/EwAwFrqkDlpF9d2P+/l5L+fdGNvDtMSTj4CAPr/urDRRs1WoTIIPhgB4BLpfs6pUsAQZJxMEFGRHyhgAAAAFiS0dEvT3V0nkAAAAHdElNRQflBAoHCQGz6vtvAAABlklEQVQY02NgAAJGJmkZWTl5BUUlZhYGCGBVVlFVU9dobdPU0tbR1WMDCukbGBoZm7R3dHZ19/T2mJqZW1haMVjb2LZ3dLR39vVPmDhp8pSp0+zsHRgcnTqmA0VnzJw1e87cefMXLFzk7MLg6tbR3rF4ydJly1esXLVo9Zq1Pe4eDJ5eHR3r1m/YuGnzlq3bFvVuX9Xr7cPg69exY+eu3Xv2AsG+/b0HDvb6BzAEBnUcOtyx+whI8Oj+Y8d7TwSHMLCHnjx1umP3mbNAwXPnL1zsPRHGwcAZfuny4s4rV0Eqr13v6e09EcHFwB0ZdaPv5q29YHD7Tm9vdAwPA29s3N17O+/vfbDp4YO9jx739MYnAAUTkzo6Tj7Z+/TZ8xd7X07r7U1O4WHgS00DevLV6zdv373/8LHnRG96Bj+DQGaWSUfHp89fvs759n1eb292Ti4bg6BQXn6BRkdn55lzPT29mt6FRcIiwMATFSsuMW7/8fNX74nSsnJxCWgwS1ZUVlX//lNTW1cvxYAArA2NTc0JLWwQHgAYPrx3ZPFt4QAAACV0RVh0ZGF0ZTpjcmVhdGUAMjAyMS0wNC0xMFQwNzowOTowMSswMDowMFJr4rUAAAAldEVYdGRhdGU6bW9kaWZ5ADIwMjEtMDQtMTBUMDc6MDk6MDErMDA6MDAjNloJAAAAAElFTkSuQmCC",
      asSource: true,
      asTarget: true,
      uploadPath: "/torrents/create?category_id=1",
      torrentDownloadLinkSelector: 'a[href*="/torrents/download/"]',
      needDoubanInfo: true,
      seedDomSelector: ".torrent__buttons+.panelV2",
      search: {
        path: "/torrents",
        replaceKey: [
          "tt",
          ""
        ],
        params: {
          name: "{name}",
          imdbId: "{imdb}",
          sortField: "size"
        }
      },
      name: {
        selector: 'input[name="name"][class="form__text"]'
      },
      description: {
        selector: "#bbcode-description"
      },
      imdb: {
        selector: "#autoimdb"
      },
      tmdb: {
        selector: "#autotmdb"
      },
      mediaInfo: {
        selector: 'textarea[name="mediainfo"]'
      },
      anonymous: {
        selector: '.form__group input[type="checkbox"][name="anon"]'
      },
      torrent: {
        selector: 'input[type="file"][accept=".torrent"]'
      },
      category: {
        selector: "#browsecat",
        map: {
          movie: "1",
          tv: "2",
          tvPack: "2"
        }
      },
      videoType: {
        selector: "#autotype",
        map: {
          uhdbluray: "1",
          bluray: "1",
          remux: "3",
          encode: "12",
          web: "4",
          hdtv: "6",
          dvd: "1",
          dvdrip: "12",
          other: ""
        }
      },
      resolution: {
        selector: "#autores",
        map: {
          "4320p": "11",
          "2160p": "1",
          "1080p": "2",
          "1080i": "3",
          "720p": "5",
          "576p": "6",
          "480p": "8"
        }
      }
    },
    CHDBits: {
      url: "https://ptchdbits.co",
      host: "ptchdbits.co",
      siteType: "NexusPHP",
      icon: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAMAAAC6V+0/AAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAA81BMVEX/AAD/AAD/AAD/AAD/AAD/AAD/AAD/AAD/AAD/AAD/AAD/AAD/AAD/AAD/AAD0AAAAAAAAAAAAAAAAAAAAAAD/AAD/AAD/AAD/AAAAAAAAAAAAAAAAAAAAAAAAAAARAAAjAADaAAD/ICBmiIgEBAQDAwMBAQEAAAAAAAAAAAD/AAD/3d39/v7GxsYAAAAAAAD/AAD/5OT/////AAAAAAADAwMCAgIBAQG5ubmAgIBaWlq6urq1tbWysrI0NDT///9/f3/7+/tJSUnLy8tRUVFOTk6mpqb19fXe3t7d3d3c3Nzu7u69vb0hISEdHR0XFxeOjo5X4OIMAAAAM3RSTlMAgbIHAnne59jwjna/7aAVK0RCQQ1VtrUFA7L7/PhdGBgDAwW2/unnnQaxGKDt6LawIeA+sl6aAAAAAWJLR0QyQNJMyAAAAAd0SU1FB+UECQo4D4hi7WcAAACoSURBVBjTY2BgYDRGBUzMDCysbGiC7EwMjBzGxpxc3HDAymNszACU4uXjFxAUggBhEVExcZCgmISklIk0GMjIyskrKIIExZWUVUzNTExMzE1NVdXUNTRBglraOroWlkBRK2sbWzsTPX2QoIGhkb29jamJiYO9vaMTUAdc0NnF1ckNXdDdw9PLG13Qx9fPPwBdEKuZ6IJYnYTV8Vi9iRkgWIMOayBjiw4AMGtCDVTI3J4AAAAldEVYdGRhdGU6Y3JlYXRlADIwMjEtMDQtMDlUMTA6NTY6MTUrMDA6MDBQcxNEAAAAJXRFWHRkYXRlOm1vZGlmeQAyMDIxLTA0LTA5VDEwOjU2OjE1KzAwOjAwIS6r+AAAAABJRU5ErkJggg==",
      asSource: true,
      asTarget: true,
      seedDomSelector: "#top~table:first>tbody>tr:nth-child(6)",
      torrentDownloadLinkSelector: 'a[href*="download.php?id="]',
      uploadPath: "/upload.php",
      search: {
        path: "/torrents.php",
        imdbOptionKey: "4",
        nameOptionKey: "0",
        params: {
          incldead: "0",
          search_area: "{optionKey}",
          search: "{imdb}",
          sort: "5",
          type: "desc"
        },
        result: {
          list: ".torrents>tbody>tr",
          url: '.torrentname td a[href*="details.php?id="]',
          name: '.torrentname td a[href*="details.php?id="]',
          size: "td:nth-child(5)"
        }
      },
      name: {
        selector: 'input[name="name"]'
      },
      subtitle: {
        selector: 'input[name="small_descr"]'
      },
      description: {
        selector: 'textarea[name="descr"]'
      },
      imdb: {
        selector: 'input[name="url"][type="text"]'
      },
      anonymous: {
        selector: 'input[name="uplver"]'
      },
      torrent: {
        selector: "#torrent"
      },
      tags: {
        chinese_audio: 'input[name="cnlang"]',
        chinese_subtitle: 'input[name="cnsub"]',
        diy: 'input[name="diy"]'
      },
      category: {
        selector: "#browsecat",
        map: {
          movie: "401",
          tv: "403",
          tvPack: "402",
          documentary: "404",
          cartoon: "405",
          sport: "407",
          concert: "406",
          music: "406"
        }
      },
      videoCodec: {
        selector: 'select[name="codec_sel"]',
        map: {
          h264: "1",
          hevc: "5",
          h265: "5",
          x264: "1",
          x265: "5",
          mpeg2: "4",
          mpeg4: "6",
          vc1: "2",
          xvid: "6"
        }
      },
      audioCodec: {
        selector: 'select[name="audiocodec_sel"]',
        map: {
          aac: "6",
          ac3: "7",
          dd: "4",
          "dd+": "7",
          flac: "1",
          dts: "3",
          truehd: "11",
          lpcm: "13",
          dtshdma: "10",
          atmos: "10",
          dtsx: "3"
        }
      },
      videoType: {
        selector: 'select[name="medium_sel"]',
        map: {
          uhdbluray: [
            "19"
          ],
          bluray: [
            "1"
          ],
          remux: [
            "3"
          ],
          encode: [
            "4"
          ],
          web: [
            "18"
          ],
          hdtv: [
            "6"
          ]
        }
      },
      resolution: {
        selector: 'select[name="standard_sel"]',
        map: {
          "2160p": [
            "6"
          ],
          "1080p": [
            "1"
          ],
          "1080i": [
            "2"
          ],
          "720p": [
            "3"
          ],
          "480p": [
            "5"
          ]
        }
      },
      area: {
        selector: 'select[name="processing_sel"]',
        map: {
          CN: "8",
          US: "3",
          EU: "7",
          HK: "5",
          TW: "9",
          JP: "4",
          KR: "6",
          OT: "0"
        }
      },
      team: {
        selector: 'select[name="team_sel"]',
        map: {
          chdbits: "14",
          sgnb: "13",
          remux: "1",
          chdtv: "2",
          chdpad: "15",
          chdweb: "12",
          chdhktv: "11",
          stbox: "10",
          onehd: "8",
          blucook: "16",
          hqc: "17",
          gbt: "18",
          kan: "19"
        }
      }
    },
    Carpt: {
      url: "https://carpt.net",
      host: "carpt.net",
      siteType: "NexusPHP",
      icon: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAYAAACNiR0NAAAACXBIWXMAAAPoAAAD6AG1e1JrAAAFZUlEQVR4nGWVeTQVaBjGPy5Tlq4lNAzGtNKinJutRlLTJqJmLJPtJEmbasScamZUamomS5pSYUqFa7m4rmS7C4UU10jFvVxxyTIqJVLd7ZnjNpnm9Pzzfn+873Oe95z3/D5CPhaISjSiVcefqaie4lbrFELdS3yWMy2TQlq9W+acpW63Pq+9NXI03PV9Pyb6P5FXjhdlvM6Fl7ZtuuW2PWyv1vThVHladwLY4ixwxQUo7r2muDjwO/Z3hIz41biVBHbssM7Bw88+hPnEjDgTg58EEcLiQTqeKp7IOl4Kpe1jIqlwrE3W+JKvqB2qkd4cKJbm9WTKkrrj5XtbA7FN5B83PhraEKo+saayriHGh6t3PxiQd2JM8lomGm2Xikba0DX6GMJXrWga4uP2IA83egtBF19TpHQkSWNbTsrDhVuw9sbi2PfByPtgMxV21MSe2Aeidy34+82A9NGrh+gcFeH5u2cYlgyj/00/2kYEqH9eh4qBUjB6spDSkYQ4wUkcaAqX+Ak8EdwV9OvEypG8sJAXeAbR2065WDGAZnk7emT9GJGNQgLgmWIYIqkYDa/44PaVImcwD8m9qTj9+DT2t+yTr+evg0utnTi+67ix0rByhMu/N8jBk9Y6+dDVNHR6eqCLx8Tg6z4MCZvQJ6yHqKUS/E4OSsaqcJOTgOzyo7hUdRjHS7YiNHuldHnVXMx77nSAOBXRgjLH6Hi0f7ukb5Mf2vVMICIaaHf8GqL8y+iaaoou468g1jRCt6EFeKw4lLBi0GpLQz/VDGKzWXihPwft08wVgRn2cmJBnx1QxjiKtx47JPfWuIDZlo7K5mzU9XLRmJGAZkNTNJtOR+O6Vajf7I6/HG3BDfXAxZqjqHFciFZdM7BtpqPM1gK+P+qBuNW4pjXm/YE7uWdk11LDUFh0AmVZx8ER5KEy5zRqtfVRazEDJeJClCbsA8/ZDs1EDVcS/JC5ZRkERB+ReyxA6qmYnE9A/Cs9uxmhqxH9IkGR2PIb0o8FoGCfB1j0w2DmxaBMXQulpqbIqT+P8pnG4BKCKqKJuARPJHsvQj2hYtdWA6iyKaDmEBD7N/470v3sEHdktfRE4yGkRW1Acl4EkvtTcf3PcDAok5BraICU+3G4VHoQ5+g7cSojEGFV3yN+lTm4RBP+AZNBKgim5BAZcXkaFHDgkCWYhEgYhCBlgw0u/LAWqTE+SEoMwlVCcEVLA/FNxxDz5BSiHh9EsCAE7ndW47iDHoqJOnx91ZSGs/M/B3HPdF9l3eSA4N0mOGuirUgnKkqTMw5m+PnWLsSc3YgjFzYhsnE3dtZvgV+1J1x5zrArnw/7eB0siSCYcY6iUL9BMJ89X6C8w6UVzhzzBjPYllrJgiItEHRuMbwe+cC/3hsB9/2wuckHXrVuWH9rBZZxbbGgbAZMWFRosFQxqZhAhUGkRhU6oBXTNisN3RpCLWfVzIFuoZrMtM4CVrVWsKuYhyXsRVjKsYED2xq0civMLfkSZix96BWoQyuPQLeAAkInUsc7NnBuWFPzPzhYVTjE6lfpQCuLSPQYFJkBUwPGhVSYs/RhUqgDI6YmphZ8Bp18itJMg6ECkkkkLrdpSGpLHF1R8q3TfzCMJkpIflE6L27q7WnQKiJSHYaqdHIuGU8AlWwClfGToBOQLAKNXKKwKNKTuPOXI/Ru8LsQdqTSbAKD4yk/oMe0wOEktdi4N6jVD+YsXcV31d/AmbMQjhVW8K1ZB/cqJ9hXLsDlgRTpUu56PrlEcRmfozXQ/uXhx+I5qympzXIzV80w+cWYORthdRFw5XljJWcDdt6Nku9qjIIhY7rQ6PqsjdE50Upaf/wN/AMeaUa+v6I4TwAAAABJRU5ErkJggg==",
      asSource: true,
      asTarget: true,
      seedDomSelector: "#top~table:first>tbody>tr:nth-child(3)",
      torrentDownloadLinkSelector: 'a[href*="download.php?id="]',
      uploadPath: "/upload.php",
      search: {
        path: "/torrents.php",
        imdbOptionKey: "4",
        nameOptionKey: "0",
        params: {
          incldead: "0",
          search_area: "{optionKey}",
          search: "{imdb}",
          sort: "5",
          type: "desc"
        },
        result: {
          list: ".torrents>tbody>tr",
          url: '.torrentname td a[href*="details.php?id="]',
          name: '.torrentname td a[href*="details.php?id="]',
          size: "td:nth-child(5)"
        }
      },
      name: {
        selector: 'input[name="name"]'
      },
      subtitle: {
        selector: 'input[name="small_descr"]'
      },
      description: {
        selector: 'textarea[name="descr"]'
      },
      imdb: {
        selector: 'input[name="pt_gen"]'
      },
      torrent: {
        selector: 'input[name="file"]'
      },
      category: {
        selector: 'select[name="type"]',
        map: {
          movie: "401",
          tv: "402",
          tvPack: "402",
          documentary: "404",
          cartoon: "403",
          concert: "445",
          variety: "405",
          music: "406",
          sport: "407"
        }
      },
      videoCodec: {
        selector: 'select[name="codec_sel[4]"]',
        map: {
          h264: "1",
          hevc: "2",
          h265: "2",
          x264: "1",
          x265: "2",
          mpeg2: "3",
          mpeg4: "1",
          vc1: "4",
          xvid: "5"
        }
      },
      audioCodec: {
        selector: 'select[name="audiocodec_sel[4]"]',
        map: {
          aac: "7",
          ac3: "3'",
          dd: "3",
          "dd+": "3",
          flac: "5",
          dts: "2",
          truehd: "1",
          lpcm: "4",
          dtshdma: "2",
          atmos: "2",
          dtsx: "2",
          mp3: "6",
          ape: "8",
          wav: "10"
        }
      },
      videoType: {
        selector: 'select[name="medium_sel[4]"]',
        map: {
          uhdbluray: "7",
          bluray: "8",
          remux: "9",
          encode: "1",
          web: "2",
          hdtv: "3",
          dvd: "6",
          hddvd: "1",
          dvdrip: "4",
          other: "9",
          cd: "6"
        }
      },
      resolution: {
        selector: 'select[name="standard_sel[4]"]',
        map: {
          "2160p": "1",
          "1080p": "2",
          "1080i": "2",
          "720p": "3",
          "576p": "4",
          "480p": "4"
        }
      },
      team: {
        selector: 'select[name="team_sel[4]"]',
        map: {
          carpt: "1",
          wiki: "2",
          cmct: "3",
          mteam: "4",
          other: "5"
        }
      }
    },
    CinemaZ: {
      url: "https://cinemaz.to",
      host: "cinemaz.to",
      siteType: "AvistaZ",
      icon: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAwAAAAMCAQAAAD8fJRsAAAABGdBTUEAALGPC/xhBQAAAAJiS0dEAP+Hj8y/AAAAB3RJTUUH5QwGCikNXab0zAAAAL1JREFUGNNlyi1IA3EAxuFnHzoE3WSw4hBsBpOIzWTUZBaFlctL64LdImJfH1ZBZ7YLNneMQ8OF3dzcQNC/QZGh7y8+bwFbTkVKEg0ndsRScjZdSiR2DS26ta7iSMyFKws4lNnDsjtN8mpeTNGX6SOTqlJQciyzpGlD1bN9B87FzGsZGBvpmhhJReZUoK4nCD4FwYNtZ9qw6kn4bagnuC/6u7IyPvL/4N0bct8wy7HIjdcixrrWhJ/Lo45rK18qoT8Iilms5wAAACV0RVh0ZGF0ZTpjcmVhdGUAMjAyMS0xMi0wNlQxMDo0MToxMyswMDowMGagtagAAAAldEVYdGRhdGU6bW9kaWZ5ADIwMjEtMTItMDZUMTA6NDE6MTMrMDA6MDAX/Q0UAAAAAElFTkSuQmCC",
      asSource: true,
      asTarget: false,
      uploadPath: "/upload.php",
      seedDomSelector: "#content-area .block:last table:first>tbody>tr:nth-child(3)",
      torrentDownloadLinkSelector: 'a[href*="/download/torrent/"]',
      needDoubanInfo: true,
      search: {
        path: "/torrents",
        params: {
          search: "{imdb}",
          "in": "1",
          order: "size",
          sort: "desc"
        }
      }
    },
    Cinematik: {
      url: "https://cinematik.net",
      host: "cinematik.net",
      siteType: "Cinematik",
      icon: "data:image/png;base64,AAABAAEAEBAAAAAAAABoBQAAFgAAACgAAAAQAAAAIAAAAAEACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD///8ACAgIAA0NDQATExMAFBQUABsbGwAfHx8AJycnACoqKgAtLS0AMTExADU1NQA5OTkAPj4+AEFBQQBFRUUASEhIAE1NTQBRUVEAVVVVAFlZWQBdXV0AYWFhAGVlZQBpaWkAbm5uAHJycgB1dXUAenp6AH5+fgCCgoIAhoaGAImJiQCOjo4AkpKRAJSUlACdnZ0ApaWlAKioqACsrKwAsrKyALS0tAC8vLwAxcXFAM3NzQDa2toA6enoAO/u7QD+/v4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/ykgICAfHx8fICv///////8iJiAZGRkYGRgiKf//////IBsZFBQUFBQSIC4p/////yIkGxQQEhISEB0wLib///8gGRUQDQ0NDQ0SFBkfKf//ICIZDBQdEgwMCQwYGxv//x8dFQkZMC0fDQkJFRsZ//8fHxUFGDAwMCwYBxUbGP//Hx8YAhgwMDAwIgUVHxj//x0VDTEVMDAqFQUCEBUV//8dIhgxDSkVAzExMRUgFf//HRAJMTECMTExMTEMEBX//x0lGTExMTExMTExGSQU//8dEgwxMTExMTExMQwQFP//HSAVMTExMTExMTEVIBX//yYYGBUYGBgYGBUYGBQg/4Af//+AD///gAf/P4AD//+AAf85gAH//4AB//+AAf//gAH/P4AB++eAAb5fgAFc6YABvl+AAVc6gAE/v4AB/z8=",
      asSource: true,
      asTarget: false,
      uploadPath: "/upload.php",
      seedDomSelector: "div.odiv_1 + table >tbody tr:nth-child(3n)",
      needDoubanInfo: true,
      search: {
        path: "/browse.php",
        params: {
          search: "{imdb}",
          cat: 0,
          incldead: 1,
          srchdtls: 1
        }
      }
    },
    Concertos: {
      url: "https://concertos.live",
      host: "concertos.live",
      siteType: "UNIT3D-Legacy",
      icon: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABAAgMAAADXB5lNAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JQAAgIMAAPn/AACA6QAAdTAAAOpgAAA6mAAAF2+SX8VGAAAACVBMVEU0mNs0mNv///8qabEFAAAAAXRSTlMAQObYZgAAAAFiS0dEAmYLfGQAAAAJcEhZcwAALiMAAC4jAXilP3YAAAAHdElNRQfnChsDLyO4AL7jAAAHQnpUWHRSYXcgcHJvZmlsZSB0eXBlIHhtcAAAeJztXduuqzgMffdXnE+AOBf4HHaBt5HmcT5/lk0LLfe2WzNGyq7U0pDYXr7FxOeo9M9ff9OfP3/KUJYV8Y37VKUilpHjTwzJuyK6GGKKdey4da7rf35+eucwXkcvIyFx8C0Xvk2FZ8ytYk2+Sk3CwsCp8V3wEZ8gyIxFznHPXdHwLVXcpCpiYWyFWSxdId/jLXaJ5R4JB0jjYy9ycDPcGKerJBMZjP3ICj+ucEWofBsKciJcn3SIg+s4uhbylMxcYSRxjbGSA9dcsWPvbhh1XGAsuh6fNd5L9uRaHWxkSN8h9OzlBN5wDZAOskRugvPexwkgKcLhpoCskser4Aag+qR/rkuY5DqVOyn/Wl4qj8O7w3tLAxHXJk6wkuglVQAHTcn9SZa5RBAHxoNpXKxFdwST9rGDiPcJULwDb6haJISmmwXU+2tmNbHFEpRK1E3WxDVMElvArSBzIQBhhEKsOrCiI14gxSvaKyCzi7dJcyQTIUHAwiDeI3qCNAPHcuJ4xJDgqxWoAgJUJ1fvAR1X02P5EvWxgkW/vkXUgTV9qmQQbJ+Zrij7hSsn70OKgzPsMaU9rpItEtwNc/rg1AF7tRZSh5AfTCOOWzSr5l/I5eG2cS2IJqlooYv7oneVT3C5gK/1Pr85u8eaiR0tA3MMTzUvwlMCM0B74msuCNE+3rh7SW4Fzd1REp3nMXklEEUG1Iw+ZAed6Wq+qXFGVrTG67SEwfvhkzu6c640U3q8I60GLyPIl0iheHfQw48kMc2gxVyWgSg9Uz2QpIW8atNUT2segtCqJPLXaHrfkmRBlE5JoltTHKQol9KIMPSRNCuEdyTS3NjAySUHtjKZO4ARV0gSfYjBLiZhITNpPnUD5jL9NbKxIjywVjQmqVbQsgp/OD1uWpc2uNXi30E2qR4S15LRGZGH/RV5A95feygV25psllG2eTik7u1b8qwS3JJoyr1YKBGvNuk0fcFLIInOcKJqqZAallwBG0fxfCkzWmRIRokFiVsdQhWCwVJ2YrniCIIQHlI4dQWM47ubnGFiT0v+e+55XyjhzWncB2UdcfdSZumUAcCaziA/aiRIhkyDK4CCE2v1ROrXyDvRCVKFJ74OOHDHCt8BBhpBiYGxJahRNpqEOwVKXLceClUwuG0QGq3jB3CQqYBtgkQeroOqH/4g9RTeA+6wgBM3hWcDUhR7CWrcdJLIdFK9ALIpjxB6Bxh2DrUyCKb6dQUtFj6KTbhDKtfJr62Q6L/Feir95BkA/EDmsV1rrT/bsJeb2OaWDU5TASGVJesejE0Tnve0j0D5okmmrclHkObsSEmcCtV9Z6BXbzh0hme4L+xpL1SPNJcSYjCIIljSyAf77Aox+lAWyeS4AplSLOhLkq1FvHteprxbpdBLmbLLc2K5mrNfxXf9+HADfz8fIKj8fydANkNkP0DkU4pjsByDhLYXvGdNuqtWIYHQUGkILwbvqBtj6+RugTlQA+QpH8yg0Qiv9lL50lT6LncNJ4/nvR4crNQgLzZGVbsiybGtltbdzEdz8x5Zl86a98i6tLRWEnXGKfeds+rZVHuY+mirTHm3SqGxTDnkv681WofynPt2Ut9TKU3Hue+cBek4951LffTmE9omSzrOfYeuIRIhaDslAyJ4Pp1bT6dMM/bY0FYQngnY54pl4dmL4mqnJnqCqidaUY+6hmos3I/Hxoi6PxX4o3m0xeGxMFSP3BBvcmA2MmD1vfsLORscH19fOG8ROIQW6nOctxjTFoFDyLNVcsjSBagOtvEaoq8AV5hMs1erWjzDPg5bnp4aA98PqMPDfluz6DFt4wF5XIYgrZNkg1uovNcNSlyAR/Prk84Lp6Ml6yxplUC9RmCXZU3HPJ+ja37UO62glVDUk+rhiF7ibn5If6LQ+ub1XxM6zpwXgnZuG7gItHfBWIa2uq9dFdrSMP+3RF8QOvKyS0F7L2SMQ/sm/q1BO3wUvRK0k0ca14B28lH0GtDeCRnz0D6Pf4PQvitmbEE7eRB1DWiHRxpXgnbeyy4A7dOQMQntd+LfBrSdHuT1oG0b5oLQznrZJaB9FjJGof1G/FuBNmGxItEXhLYMc0lo57zsItA+CRmz0L6PfzvQdv7J8PWgrRvmotBO9rKvAe39kDEM7dv4twRt539nXA9abmZahZabmUah5WamVWi5mWkVWm5mGoWWm5lWoeVmplVouZlpFFpuZlqFlpuZRqHlZqZVaLmZaRVabmYahZabmVah5WamUWi5mWkVWm5mWoWWm5lGoeVmplVouZlpFFpuZlqFlpuZVqHlZqZRaLmZaRVabmZahZabmUah5WamVWi5mWkUWm5mWoWWm5lWoeVmplFouZlpFVpuZhqFlpuZVqHlZqZVaLmZaRRabmZahZabmUah5WamVWi5mWkVWm5mGoWWm5mPpas/zCs/nqA/xpnS8Ju69C9khqnUdh3WhAAAAAFvck5UAc+id5oAAACZSURBVDjL1dOxEQMxCATAU0AJ9EMJCkT/rfzYL/HcRXbgwGTsD9L8cAKocnHvmdRbMrz6DiMFUsAFLBlGMlSfdOADLvAMbLCfwnIBCEAgBCYYFgQgEAIBhgmB+HcYwWBtDVGZaGAKrpCfg803jAO2t1hw1npGTMEVKgn3p9XA7kw8gHZJ/f4k6A8D34BX4HbZSSTN9H7fXnUBXz+QkWPfUykAAAAldEVYdGRhdGU6Y3JlYXRlADIwMjMtMTAtMjdUMDM6NDc6MzUrMDA6MDBKPrQ3AAAAJXRFWHRkYXRlOm1vZGlmeQAyMDIzLTEwLTI3VDAzOjQ3OjM1KzAwOjAwO2MMiwAAACh0RVh0ZGF0ZTp0aW1lc3RhbXAAMjAyMy0xMC0yN1QwMzo0NzozNSswMDowMGx2LVQAAAATdEVYdGRjOmZvcm1hdABpbWFnZS9wbmf/uRs+AAAAFXRFWHRwaG90b3Nob3A6Q29sb3JNb2RlADNWArNAAAAAJnRFWHRwaG90b3Nob3A6SUNDUHJvZmlsZQBzUkdCIElFQzYxOTY2LTIuMRwvbAsAAAAQdEVYdHhtcDpDb2xvclNwYWNlADEFDsjRAAAAKHRFWHR4bXA6Q3JlYXRlRGF0ZQAyMDE4LTA0LTE1VDE4OjE0OjIxKzAyOjAwX6YhzgAAADN0RVh0eG1wOkNyZWF0b3JUb29sAEFkb2JlIFBob3Rvc2hvcCBDQyAyMDE3IChNYWNpbnRvc2gpmllTCQAAACp0RVh0eG1wOk1ldGFkYXRhRGF0ZQAyMDE4LTA0LTE1VDE4OjMzOjE2KzAyOjAwJmTVnAAAACh0RVh0eG1wOk1vZGlmeURhdGUAMjAxOC0wNC0xNVQxODozMzoxNiswMjowMBrAhiIAAAAWdEVYdHhtcDpQaXhlbFhEaW1lbnNpb24ANjTJIcZzAAAAFnRFWHR4bXA6UGl4ZWxZRGltZW5zaW9uADY0FLcf9gAAAEt0RVh0eG1wTU06RG9jdW1lbnRJRABhZG9iZTpkb2NpZDpwaG90b3Nob3A6MGI0NjQyYjktODE1OS0xMTdiLWI3MzQtOWVjODc3YWYyZDliEBg3pQAAAD10RVh0eG1wTU06SW5zdGFuY2VJRAB4bXAuaWlkOjlmMThhNDc5LWIwYTUtNDczMS1hNjcxLTZhYTllMjAyNjdhMl6RzKYAAABFdEVYdHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRAB4bXAuZGlkOmMwOGUxNmM1LTZkNGYtNGVlMy04ZGVkLWYzMTJiZWIyMWVlOSZ+IrEAAAAASUVORK5CYII=",
      asSource: false,
      asTarget: true,
      seedDomSelector: "div.torrent > div.buttons.mbox.mbox--small-bottom",
      uploadPath: "/upload",
      needDoubanInfo: false,
      search: {
        path: "/torrents",
        replaceKey: [
          "tt",
          ""
        ],
        params: {
          name: "{name}",
          imdb: "{imdb}",
          order_by: "size"
        }
      },
      name: {
        selector: "#title"
      },
      description: {
        selector: "div.sceditor-container textarea"
      },
      imdb: {
        selector: 'input[name="imdb"]'
      },
      tmdb: {
        selector: 'input[name="tmdb"]'
      },
      mediaInfo: {
        selector: "#mediainfo"
      },
      anonymous: {
        selector: 'input[name="anonymous"]'
      },
      category: {
        selector: 'select[name="type_id"]',
        map: {
          BD100: "1",
          BD66: "2",
          UHD50: "3",
          BD50: "4",
          BD25: "5",
          remux: [
            "12",
            "7"
          ],
          encode: [
            "8",
            "10",
            "11",
            "13"
          ],
          web: "9",
          hdtv: "17",
          dvd: [
            "14",
            "16"
          ],
          dvdrip: "13",
          other: ""
        }
      }
    },
    DicMusic: {
      url: "https://dicmusic.com",
      host: "dicmusic.com",
      siteType: "gazelle",
      icon: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAMAAAAM7l6QAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAB0VBMVEUAAABRyvRWzPVd0PRQyvRdz/V83fiA3/h+3vil7vt32/d/3vhRyfVRyfRQyfVRyPVSy/NNzvBQy/RRyvNdx/BcxvFSzvgA//9RyvRRyvRRyvRRyvRRyvRRyvRRyvRRyvRRyvRRyvRRyvRRyvRRyvRRyvRRyvRRyvRRyvRRyvRRyvRRyvRRyvRRyvRRyvRRyvRRyvRRyvRRyvRRyvRRyvRRyvRRyvRRyvRRyvRRyvRRyvRRyvRRyvRRyvRRyvRRyvRRyvRRyvRRyvRRyvRRyvRRyvRRyvRRyvRRyvRQyvRRyvRRyvRRyvRRyvRRyvRRyvRSy/VUzPRRyvRRyvRRyvR73fiB3/lRyvRRyvRRyvRRyvRUy/Rl0/Z53PiC4PmF4fmF4fmA3/iC4PmF4vqF4fmD4PlRyvRRyvRRyvRQyvRe0PV73fiA3/h+3vh+3vht1vdazvVSyvRs1vZ/3vh+3vhRyvRPyfRQyvRRyvRRyvRRyvRRyvRRyvRRyvRRyvRRyvRRyvRRyvRRyfRRyvRRyvRQy/RRyvRRyvRRyvNRyfNQyvRSyvRSy/ZRttpRqcdVzPRg0PVq1fZw2Pdz2fd02vd12vh02vh00+90z+ly2ff///+GemWQAAAAh3RSTlMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABLmt8WBYGi/v8w0AJg+iRUDw1GggrWZ72+vTw1WkEGV2y5/JNdNKfAlaZiUlUxv7IDh+OFxWT9eczjK6505EQit33+fv7+/v5/f37/ukOjUNFS1FRUVCB8dtmUDTreOXCPjbxMAskEfiWBXOqAzMzDrfyAAAAAWJLR0SamN9nEgAAAAd0SU1FB+cKGgg3G6bwFqAAAAE1SURBVCjPY2AYHoARBnBIS0hKScvI4lLAKCev0K6opIzVDJCIiqpCe7uauoamljaqPEhSR1dP36AdCAyNjE1MzYDyUFNApLmFpZViOxxY28CkQUDW1k6hHQXYOzAyODo5u6gwMsq5urmjSnZ0engyMXh5KxrY+/j6+QNFurrau2Ggp7cvIJAZ6Jeg9vbgEJD6/gkTJ02eMmXq1ClAMG36jGmhYUC7wyMi2xWjDKJjYuPi4+MTEmdOTooHgeT4lFSQ09KC29MzMrOyc3Jzc/PyC9oLi4pzIaAE5CXJ0nYZRhZWNnZ2dg7OsvKKSi5udgjgBoVHVXVpDTSAeBhr6+p5+fgRoSXAmNHQ2ASXBgJBIaTAFGZsbtHGFYUMDEKtbfWMjLy4pEVEgeaJ4Uwh4kBAv/RIPQAAlh1hyJQd92oAAAAldEVYdGRhdGU6Y3JlYXRlADIwMjMtMTAtMjZUMDg6NTU6MjYrMDA6MDA7po/7AAAAJXRFWHRkYXRlOm1vZGlmeQAyMDIzLTEwLTI2VDA4OjU1OjI3KzAwOjAw7Iw88wAAACh0RVh0ZGF0ZTp0aW1lc3RhbXAAMjAyMy0xMC0yNlQwODo1NToyNyswMDowMLuZHSwAAAAASUVORK5CYII=",
      asSource: true,
      asTarget: true,
      uploadPath: "/upload.php",
      search: {
        path: "/torrents.php",
        params: {
          searchstr: "{name}"
        }
      },
      torrent: {
        selector: "#file"
      }
    },
    DiscFan: {
      url: "https://discfan.net",
      host: "discfan.net",
      siteType: "NexusPHP",
      icon: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAIAAAAC64paAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAABmJLR0QA/wD/AP+gvaeTAAAAB3RJTUUH5QQKBzkJYndFrgAAAwxJREFUOMt9lFlvJEUQhLOOrj6qp+duH2Ps1bJIIOD//xOeOBZ7oe2Zcc/0XXfyYEu7sBbxlqH8lEopFAQR4S29+oS8jOStHf4m9iI9TagUBRdEEsVpJAQh5P9grbVVOhKJSAVaF+/3pnt4qNpjXFx8+HD7zV2c8DdgRDyfz1VVCRFflJdcCESCwQXVHY/HX5qn3451fap/+vEHKfMXhL6SgF1zru7v6/rcNk3XNICBc8oCjqN56vXAARnW9enjH/dKqX/BMCk4PEmjYuoHNT63J6UnoBQI1q07ekhkNi+KvJCB4vF49N6/wgig2zZV6oLhNecJpX3b1afngL4x6rEbJpGuN5vNuiyKpRBCKTVN4+vPzphmaCgEGUUbgjGxfxn76f7TaVYb5ZrZspyx3VU5X8wjRiLnInTdYS9lzgHAWFM7HdAzChknGeO5MRMAR5JsN5YxpaZ5JBbOiVGlWnMaOq2m8ZIDgJ4mZY1BxwPrECgBT0mayovr3Xq9rqrq14+/R+OptI6gJeAogcFmahg4ACjvD88nPekQggveaTeT8lKkIo6BkCRNMAQ1tBO2hAfCkdNoghA5ywGAEXJ8PNXns7EOrY8ciquNny+qx2oYuqf9HoBM0eyhI2IcGdo4QpWwPMs4AMhMUkJNP4rA1nF0M8vuVmuTZVqNfz7XRo95Khe7azVM/fkc+j511rM8zyQHgCxNv73eRXUzj/ilzHflKru5g91l0zf4d3VrdZQIxUW2TgYp9dAPbb8py0gIDgCUsfffvRfHukC/nC/ysvTbjUjTDEOR95lWmdJ+aE1eZEmSCeEDrMvt52wvtxv/8/difyhmhduuaJ4QQO99ANBA02DkMBrKIC/6pt8sV7Ni9hmmhC5vbgYhFOFQFCllIQR0DgmxlARLYgzS2upwSOWsvLogQL7INkAkxOzqSiexHUeLGBCRECRA4sSzqLX6NE6L5er23S3jryfJf5okhGCMGbpOGWOMmaYxTJOgpNhs56t1kmVf9gH5uoZeHKP1qJRzTjCWScmF+LqJ/gFiT9/X+5vOiQAAACV0RVh0ZGF0ZTpjcmVhdGUAMjAyMS0wNC0xMFQwNzo1NzowOSswMDowMA4aMCMAAAAldEVYdGRhdGU6bW9kaWZ5ADIwMjEtMDQtMTBUMDc6NTc6MDkrMDA6MDB/R4ifAAAAAElFTkSuQmCC",
      asSource: true,
      asTarget: true,
      seedDomSelector: "#top~table:first>tbody>tr:nth-child(3)",
      torrentDownloadLinkSelector: 'a[href*="download.php?id="]',
      uploadPath: "/upload.php",
      search: {
        path: "/torrents.php",
        imdbOptionKey: "4",
        nameOptionKey: "0",
        params: {
          incldead: "0",
          search_area: "{optionKey}",
          search: "{imdb}",
          sort: "5",
          type: "desc"
        }
      },
      name: {
        selector: 'input[name="name"]'
      },
      subtitle: {
        selector: 'input[name="small_descr"]'
      },
      description: {
        selector: 'textarea[name="descr"]'
      },
      imdb: {
        selector: 'input[name="url"][type="text"]'
      },
      douban: {
        selector: 'input[name="douban_url"]'
      },
      torrent: {
        selector: 'input[type="file"]'
      },
      category: {
        selector: "#browsecat1",
        map: {
          tv: "411",
          tvPack: "411",
          documentary: "413",
          cartoon: "419",
          sport: "417",
          concert: "414",
          variety: "416"
        }
      },
      videoType: {
        selector: 'select[name="source_sel"]',
        map: {
          uhdbluray: "2",
          bluray: "3",
          remux: "0",
          encode: "10",
          web: "9",
          hdtv: "1",
          dvd: "4",
          hddvd: "4",
          dvdrip: "10",
          other: "0"
        }
      },
      area: {
        selector: "#browsecat",
        map: {
          CN: "401",
          US: "410",
          EU: "410",
          HK: "404",
          TW: "405",
          JP: "403",
          KR: "406"
        }
      }
    },
    FL: {
      url: "https://filelist.io",
      host: "filelist.io",
      siteType: "FL",
      icon: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAMAAAC6V+0/AAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAABAlBMVEUsg6Qsg6MsgqMsWWssRU8sR1IsJiYsKSosLS8sLC4rLS8rLjErLjArLTAsKSkrMjYpSVcjeZsig6oihKsje54oS1okb40nWGwsKissKCkrNDknV2ofm8sifqIlaYQkbIglZ4IoUWIhj7okbIknVWgglsQoTFstIiAoT18laoUrNTogl8UmWm8qNz4qNz0qNjwmXnQglMElaYUsKCgqOkIlaIIfmsogmMcglMIjfJ8mYXgsJycpQUwfnMwpSFUqPkclZ4EsJSQsKy0rKisqNj0oTl4sJCIrMDMnUWIgkb0hi7Ula4glaoYpP0grNDojdZUpRlMsKiosLC0igqgpRlL///+rTVq6AAAAAWJLR0RVkwS4MwAAAAd0SU1FB+UEDAMIEgwtfPAAAADJSURBVBjTbZHHFoIwFAUDAoGoqGAv2BV7r1iw9+7/f4uKiKDMIos5bzM3AGD4DxgAmIUgDRAWDOAEBQ1QBA5wEtIGIKlIRkMnEbK+QDY7o0nW4XRxHO/2eH1+TQaCoXBEiMbiiSSrk6l0JkshMZGDX5n3FYqlcqVaq39lo9lqd7q9TF8vpYF7KIijsbctTyCczt6X82p4sWRX6822vtsfJEXO/MfT+YKYq8xz3O1OqUXIhhj6+SoJahH9DlRTP/J/ELPpTEc2+44Hf1AYDR9uHSMAAAAldEVYdGRhdGU6Y3JlYXRlADIwMjEtMDQtMTJUMDM6MDg6MTgrMDA6MDCjgoMzAAAAJXRFWHRkYXRlOm1vZGlmeQAyMDIxLTA0LTEyVDAzOjA4OjE4KzAwOjAw0t87jwAAAABJRU5ErkJggg==",
      asSource: false,
      asTarget: false,
      uploadPath: "/upload.php",
      search: {
        path: "/browse.php",
        imdbOptionKey: "3",
        nameOptionKey: "0",
        params: {
          search: "{imdb}",
          searchin: "{optionKey}",
          sort: "3"
        }
      }
    },
    GPW: {
      url: "https://greatposterwall.com",
      host: "greatposterwall.com",
      siteType: "gazelle",
      icon: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABYAAAAYCAMAAADJYP15AAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAABVlBMVEUAAAAvnMEvnMEvnMEvnMEvnMEvnMEvnMEvnMEvnMEvnMEvnMEvnMEvnMEvnMEvnMEvnMEvnMEvnMEvnMEvnMEvnMEvnMEvnMEvnMEvnMEvnMEvnMEvnMEvnMEvnMEvnMEvnMEvnMEvnMEvnMEvnMEvnMEvnMEvnMEvnMEvnMEvnMEvnMEvnMEvnMEvnMEvnMEvnMEvnMEvnMEvnMEvnMEvnMEvnMEvnMEvnMEvnMEvnMEvnMEvnMEvnMEvnMEvnMEvnMEvnMEvnMEvnMEvnMEvnMEvnMEvnMEvnMEvnMEvnMEvnMEvnMEvnMEvnMEvnMEvnMEvnMEvnMEvnMEvnMEvnMEvnMEvnMEvnMEvnMEvnMEvnMEvnMEvnMEvnMEvnMEvnMEvnMEvnMEvnMEvnMEvnMEvnMEvnMEvnMEvnMEvnMEvnMEvnMEvnMEvnMEvnMEvnMH////T/m9bAAAAcHRSTlMAABScbxoq5/nNlouiawwn4/36fQENv7PZH3D85e83GcnmK5OtCcbdOWzyWjjfowdURS3wQ3PcxQ8bYuGdBChjj5rWqqu2ICRMCL0y29cCprcje/v30U/+znJJX/boSPQGEsM6CpX1hBGN4FCw6p41N9CYMAAAAAFiS0dEca8HXOIAAAAHdElNRQflBg8QJipZPSzlAAABIUlEQVQoz13R11bCQBAG4AyCYkGToKImWBAsCAQLKmLsLRbsohKw9zbvf+WWILv+V3u+zJmdnSgKCfga/AGgUcRAY1OwuaW1LdQuOXSoiKhperhTdOjqJhyJYE+vxNBnIJomRvvlLgODSDMUkxmGGccTMvtGqI6O/Sse14kmJ0C+MZWmxRmrrlYsOzlF58PpGaE2N2sk0wbluXmB8wsF5FmkncFesoE1Xg5yXmGcWE2xiyG/xnndZtUbm1vbO+Tg7HJW9yhDzthXD8iheOg1PzomG3dOTs/OL+j3sMely6vrctytZAOsefXGc9R0Mmrmlg0Kd/coxHzgKwAou3V1/bU/BI9PRk2fX5y/t8LrW5Rf+h5yhA2A9fH5VdIK3z9Frr/KLlYZgS4NmAAAACV0RVh0ZGF0ZTpjcmVhdGUAMjAyMS0wNi0xNVQxNjozODo0MiswMDowMN+dGPkAAAAldEVYdGRhdGU6bW9kaWZ5ADIwMjEtMDYtMTVUMTY6Mzg6NDIrMDA6MDCuwKBFAAAAAElFTkSuQmCC",
      asSource: true,
      asTarget: true,
      uploadPath: "/upload.php",
      search: {
        path: "/torrents.php",
        params: {
          searchstr: "{imdb}",
          order_by: "size",
          order_way: "desc",
          group_results: 1,
          action: "basic",
          searchsubmit: 1
        }
      },
      needDoubanInfo: true,
      torrent: {
        selector: "#file"
      },
      sourceInfo: {
        editionTags: {
          "10_bit": "10_bit",
          hdr10: "hdr10",
          hdr10plus: "hdr10_plus",
          dolby_vision: "dolby_vision",
          dts_x: "dts_x",
          dolby_atmos: "dolby_atmos",
          chinese_dubbed: "chinese_audio",
          special_effects_subtitles: "special_effects_subtitles"
        }
      },
      targetInfo: {
        editionTags: {
          "2_disc_set": "2_disc_set",
          "2d_3d_edition": "2d_3d_edition",
          "2_in_1": "2_in_1",
          "3d": "3d",
          "3d_anaglyph": "3d_anaglyph",
          "3d_full_sbs": "3d_full_sbs",
          "3d_half_ou": "3d_half_ou",
          "3d_half_sbs": "3d_half_sbs",
          "4k_remaster": "4k_remaster",
          "4k_restoration": "4k_restoration",
          director_s_cut: "director_s_cut",
          dual_audio: "dual_audio",
          english_dub: "english_dub",
          extended_edition: "extended_edition",
          extras: "extras",
          masters_of_cinema: "masters_of_cinema",
          scene: "sc",
          the_criterion_collection: "the_criterion_collection",
          theatrical_cut: "theatrical_cut",
          two_disc_set: "2_disc_set",
          remux: null,
          rifftrax: "rifftrax",
          uncut: "uncut",
          unrated: "unrated",
          warner_archive_collection: "warner_archive_collection",
          with_commentary: "with_commentary"
        }
      },
      description: {
        selector: "#release_desc"
      },
      imdb: {
        selector: "#imdb"
      },
      mediaInfo: {
        selector: 'textarea[name="mediainfo[]"]'
      },
      category: {
        selector: "#releasetype",
        map: {
          movie: "1",
          tv: "3",
          tvPack: "3",
          concert: "5"
        }
      },
      source: {
        selector: "#source",
        map: {
          uhdbluray: "Blu-ray",
          bluray: "Blu-ray",
          web: "WEB",
          hdtv: "HDTV",
          hddvd: "HD-DVD",
          dvd: "DVD",
          other: "Other"
        }
      },
      videoCodec: {
        selector: "#codec",
        map: {
          h264: "H.264",
          hevc: "H.265",
          x264: "x264",
          x265: "x265",
          h265: "H.265",
          mpeg2: "Other",
          mpeg4: "H.264",
          vc1: "Other",
          xvid: "xvid"
        }
      },
      resolution: {
        selector: "#resolution",
        map: {
          NTSC: "NTSC",
          PAL: "PAL",
          "2160p": "2160p",
          "1080p": "1080p",
          "1080i": "1080i",
          "720p": "720p",
          "576p": "576p",
          "480p": "480p"
        }
      },
      format: {
        selector: "#container",
        map: {
          mkv: "MKV",
          mp4: "MP4",
          avi: "AVI",
          ts: "TS",
          wmv: "WMV",
          vob: "VOB IFO",
          iso: "ISO",
          mpg: "MPG",
          m2ts: "m2ts"
        }
      },
      videoType: {
        selector: "#processing",
        map: {
          encode: "Encode",
          remux: "Remux",
          DIY: "DIY",
          bluray: "Untouched",
          uhdbluray: "Untouched",
          dvd: "Untouched",
          dvdrip: "Encode"
        }
      }
    },
    HD4FANS: {
      url: "https://pt.hd4fans.org",
      host: "hd4fans.org",
      siteType: "NexusPHP",
      icon: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAYAAACNiR0NAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAABmJLR0QA/wD/AP+gvaeTAAAAB3RJTUUH5QQKBykVPLQLsAAABCVJREFUOMuVlctvVVUYxX97n3PPvb0t0BZKSKW0FdpSDCAkViMmjU9kAImaMDVGnOo/4IApGo0xccLQmYkgJhhfCSA4sgUJjz5JsbVwS/q6lN7bc/brc3AanGiiO9mjb+1k7d/KXlvxP9ax04tsfyKmMucatGYrsAysnHln82ON+rfDB967RXU+Zc/hroZSSTeXErVNKfq0Ym8cq6cizQ7rZKyeyYdxxFQ9Fc69u5kYYLxi8Q4aSiq5Mp2VhmZse93SGxS7g7BHK/qiiO44Ui1xRBxppZUC6+TpWMvVjw4WP/n6QeAcoE58s8xCVXZtKKmXTwyUD+/cHHWlTppTK80La7Lxh8ksWloLaKUoFWCwK+HJlhgBRIRI8WtXS3S8oFWlIdHElYWwt6msT0UFdeTStGEpjTnSWySJQIBqKpwfz/AiiFWMzjs2FTWD3QUmFz0/T2StFzxxMcrpxcAhYJ8XmJh3LNQCg90J09VAZ3PEoc4CN+Ys4wsOreBmxZFZ2L8t5uo9y6W7ZkOtJluBPwG0dVzNrCxlRjAOjBVEYHjWMjRr2VLWvNidUECRGcE6wTjBeGGpFgieFgV9CnjliwW0MWHEmjBjTMCagLUCwKO1wPmRlPlVz0BHgYPtMcYEjBXcusYHwXtpEpE9v99ew3tBX3x/S81YGXEu4HzA+wDrwEcrhh/HUwoaXu8t0lZWWJtrRCB4wftACNK/qzPZGIKgj56ex1q5YYxYawRrBRHBeyHNhJ9GUkYfOHraYl7aVUS84JyAgPe52+ClVylpQQT9qBbwPoxZEx46G3A2dxg8eBe4v+w4c61O3QRe6yuye0uMMYIA3gnWBLwLHRJkByLoNBMyIxVj5K5ZZygCzkvOzAhXJte4OJbS2hjxxv4GmhIIQXKNDTgnjc5Jf6wCsXMQhCpaJpSSZx4Dd4I1gkJYyeCroRr7ticMdBWp1sPfmkxQSmIvau9vS41o74VStlZzVkZsFoIxOXDvBJMFjMkxjM4azg7XiDS82l9iY0njbH5lawLehv7u0mqLvn6ynVUSrJMxa+WRMzlw5/OArMl3lga+HV5leCqjIdEkETgnmPW5s7IteGnXkKflvUxYK8utZU0hgnKs8OshORvwLlBZcnx5eYVq3aOUwjtZnwvOyR8SWIwBerYWKBfV7As9xeXne0pdm8qa48810dEa8fn3Ve4vO7TK3+rlkTX57lotvPVsky4X9YzzXItidV0JZ0Pq52KAYwfKbGiMaosP7egvt+sHLt6s5Q6CSGokeE8mmorSTNaMjF0YSWfeHGgqHT3YePnkmepQT2diAZn8uD0v2Ia3p+hrU9xbkcGCklME2kQxh2IyKeibkeIWSk2pSC8prR4iuDufdvxjMT9u7O4PpkGhEXYi0opS0yjmAX/3s87//E38BWXDuj9j0ViVAAAAJXRFWHRkYXRlOmNyZWF0ZQAyMDIxLTA0LTEwVDA3OjQxOjIxKzAwOjAws0DWvgAAACV0RVh0ZGF0ZTptb2RpZnkAMjAyMS0wNC0xMFQwNzo0MToyMSswMDowMMIdbgIAAAAASUVORK5CYII=",
      asSource: true,
      asTarget: true,
      uploadPath: "/upload.php",
      seedDomSelector: "#top~table:first>tbody>tr:nth-child(3)",
      torrentDownloadLinkSelector: 'a[href*="download.php?id="]',
      search: {
        path: "/torrents.php",
        imdbOptionKey: "4",
        nameOptionKey: "0",
        params: {
          incldead: "0",
          search_area: "{optionKey}",
          search: "{imdb}",
          sort: "5",
          type: "desc"
        },
        result: {
          list: ".torrents>tbody>tr",
          url: '.torrentname td a[href*="details.php?id="]',
          name: '.torrentname td a[href*="details.php?id="]',
          size: "td:nth-child(5)"
        }
      },
      name: {
        selector: "#name"
      },
      subtitle: {
        selector: 'input[name="small_descr"]'
      },
      description: {
        selector: "#descr"
      },
      imdb: {
        selector: 'input[name="url"][type="text"]'
      },
      torrent: {
        selector: 'input[name="file"]'
      },
      category: {
        selector: "#browsecat",
        map: {
          movie: "401",
          tv: "403",
          tvPack: "402",
          documentary: "404",
          concert: "406",
          sport: "407",
          cartoon: "405",
          variety: "405"
        }
      },
      videoType: {
        selector: 'select[name="medium_sel"]',
        map: {
          uhdbluray: "1",
          bluray: "1",
          hddvd: "2",
          remux: "3",
          encode: "7",
          web: "7",
          hdtv: "5",
          dvd: "6",
          dvdrip: "6",
          other: ""
        }
      },
      videoCodec: {
        selector: 'select[name="codec_sel"]',
        map: {
          h264: "1",
          hevc: "10",
          x264: "1",
          x265: "10",
          h265: "10",
          mpeg2: "4",
          mpeg4: "5",
          vc1: "2",
          xvid: "3",
          dvd: "4"
        }
      },
      resolution: {
        selector: 'select[name="standard_sel"]',
        map: {
          "2160p": "5",
          "1080p": "1",
          "1080i": "2",
          "720p": "3",
          "576p": "4",
          "480p": "4"
        }
      },
      team: {
        selector: 'select[name="team_sel"]',
        map: {
          chd: "2",
          mysilu: "3",
          wiki: "4",
          other: "5",
          cmct: "6",
          r2ts: "7",
          kbits: "8"
        }
      }
    },
    HDArea: {
      url: "https://hdarea.club",
      host: "hdarea.club",
      siteType: "NexusPHP",
      icon: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAYAAACNiR0NAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAABmJLR0QA/wD/AP+gvaeTAAAAB3RJTUUH5QQKBhQINJhF4AAABH1JREFUOMuNlEtsVGUYht//P/85c86c6bQz7UynMx2mLdALt2IFLZabNaAmGgRMJDFhoe41LtgYNiYsSIxRdxIJMZHISgwmLgjQCLFSC5XWQikNLQidTi+203Yu5/p/LlTUoMi7+r7vTd58m/dheAxRaeavxbMBkoDQAMYAACyYeGCzxwok+nNUYS/qIJ8jELHBmA2AGGOPF/ggKPuDjvmxFgx93SHDTT7VJct87mwdgvEsi7TNILZlGrU7cwAWxSNfO7kbAGIA64bEDkxPbHVE5bLnhZbN/K1WuHM5WNlJZL+7I5Vjg6X1hwYEANBkH1CZUtD/uU73B3Rv1XMuhRJF+ck+n3W0t1M5fxTFhaT0dLUcCFueUP1gcSbIrLtpMLmZHHBZsf6mD3Gak2cBS/eAhfE6OIX9IHmEmHhDKmqSH6OQF+1Y7Si1taVUl5jf9i7chu0/Gw6/ZFU+7UsW4vDBpVoNJ9QqnGBGCCgB4PirQLJut5TikBtsDC2knqzRqjIT+sCnLtPERhKGpeYm1EB6x0Uv1nICeTYumXsDo0NvwkWlHVuDUuypnODiG4Gx08DhsXqc6O7E8nQLk8Izez/cFFi6H0Q5yzhDo2q5KtkeuGr+KpPrbmvJddcxmm9lcBySgG82lpxE980oygMCdy5yZPu7oATXMs+BWpgUyvCZDAVERsICt8sAN1BO7ZBOpH7RBgrapbeisOc2EuyAb8QAIzWG2o7+vOOWBaLNKn76rJPKS62kmPD1GscJt9kU5JqWH1G1wgSnQJCKrbtKMMPn64EhzPc/Czv/PHwZtOJd8EKNNyoC6COmEEdkVRNmb7f5vhJdXnOwmDt4dnhp70dfMT0+otiWTQKQWsim1JY+O9N9C0AIRmwtypMr4EnFij1TLsS2DlUAg4wx4hg+dQAl2WBHm1FueGKYatLvmQqd0+9d9pT8lOEHamCnNpeFHu4RApMYfL8N5HcSMdU1MuBGoo/F24anFvMIaxzCUyOrYSRDXqSl4GW2XqkuLF8IFr20FWk+oNge+WacCmv3ZgXDucTC1TByPS9h7vp26RqslNguSTN7TA3XiFcBAIRX0dRLqU1VqGlz1Xjb98bgkTDGT65zV72+4Bupa1LRVL9uZbZq6HCa2XMvUHFir7RKaSe0QdqpXXMUTF099Rq7/84p+XuXrdyoWg7Xb+NcqHpAu6v+eCiNkY+PU+WGCTe956qr1whl9lp7YOpCA1n5uOSmaletd0rpl2eVzJ5zzIx/QK47UmUKCIVDlGqbXQC9LiBD82MRokAXyAywheFObeHGBs3njEjT3OAKUVi5X9iJnVOoaO41BM5A6D1SwRSTKoTC/kkbf/RLcCMunMXbza419zabvrxHWRyv9dVqFFMvOqhcPQIzcd6tSPc64fRojUBWYchLQIb+C18zPgEcGjx3o37l6BbP4/tcsyHpxNq/peqmPlM3rkQZfiHA4uzfyffQ9W8w5XeX8QqAxnoTXygcswAkY49m8kM89OQfBofkvnuaCMz1IMEZfML/6jelxwpRbOI1GgAAACV0RVh0ZGF0ZTpjcmVhdGUAMjAyMS0wNC0xMFQwNjoyMDowOCswMDowML4c7OgAAAAldEVYdGRhdGU6bW9kaWZ5ADIwMjEtMDQtMTBUMDY6MjA6MDgrMDA6MDDPQVRUAAAAAElFTkSuQmCC",
      asSource: true,
      asTarget: true,
      seedDomSelector: "#top~table:first>tbody>tr:nth-child(3)",
      torrentDownloadLinkSelector: 'a[href*="download.php?id="]',
      uploadPath: "/upload.php",
      search: {
        path: "/torrents.php",
        imdbOptionKey: "4",
        nameOptionKey: "0",
        params: {
          incldead: "0",
          search_area: "{optionKey}",
          search: "{imdb}",
          sort: "5",
          type: "desc"
        },
        result: {
          list: ".torrents>tbody>tr",
          url: '.torrentname td a[href*="details.php?id="]',
          name: '.torrentname td a[href*="details.php?id="]',
          size: "td:nth-child(5)"
        }
      },
      name: {
        selector: 'input[name="name"]'
      },
      subtitle: {
        selector: 'input[name="small_descr"]'
      },
      description: {
        selector: "#descr"
      },
      imdb: {
        selector: 'input[name="url"][type="text"]'
      },
      douban: {
        selector: 'input[name="dburl"]'
      },
      anonymous: {
        selector: 'input[name="uplver"]'
      },
      torrent: {
        selector: 'input[name="file"]'
      },
      category: {
        selector: "#browsecat",
        map: {
          movie: [
            "300",
            "401",
            "415",
            "416",
            "410",
            "411",
            "414",
            "412",
            "413",
            "417"
          ],
          tv: [
            "402",
            "403"
          ],
          tvPack: "402",
          documentary: "404",
          concert: "406",
          sport: "407",
          cartoon: "405",
          variety: "403"
        }
      },
      videoCodec: {
        selector: 'select[name="codec_sel"]',
        map: {
          h264: "7",
          x264: "7",
          hevc: "6",
          x265: "6",
          h265: "6",
          mpeg2: "4",
          mpeg4: "1",
          vc1: "2",
          xvid: "0",
          dvd: "0"
        }
      },
      audioCodec: {
        selector: 'select[name="audiocodec_sel"]',
        map: {
          aac: "6",
          ac3: "11",
          dd: "5",
          "dd+": "4",
          flac: "1",
          dts: "3",
          truehd: "7",
          lpcm: "8",
          dtshdma: "4",
          atmos: "10",
          dtsx: "0"
        }
      },
      videoType: {
        selector: 'select[name="medium_sel"]',
        map: {
          uhdbluray: [
            "1",
            "300"
          ],
          bluray: [
            "1",
            "401"
          ],
          remux: [
            "3",
            "415"
          ],
          encode: "7",
          web: [
            "9",
            "412"
          ],
          hdtv: [
            "5",
            "413"
          ],
          dvd: [
            "2",
            "414"
          ],
          dvdrip: "6",
          other: "0"
        }
      },
      resolution: {
        selector: 'select[name="standard_sel"]',
        map: {
          "2160p": "5",
          "1080p": [
            "1",
            "410"
          ],
          "1080i": "2",
          "720p": [
            "3",
            "411"
          ],
          "576p": "4",
          "480p": "4"
        }
      },
      team: {
        selector: 'select[name="team_sel"]',
        map: {
          epic: "1",
          hdarea: "2",
          hdwing: "3",
          wiki: "4",
          ttg: "5",
          other: "6",
          mteam: "7",
          hdapad: "8",
          chd: "9",
          hdaccess: "10",
          hdatv: "11",
          cxcy: "12",
          cmct: "13"
        }
      }
    },
    HDAtmos: {
      url: "https://hdatmos.club",
      host: "hdatmos.club",
      siteType: "NexusPHP",
      icon: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAMAAAC6V+0/AAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAACqVBMVEUAerwqYXVnYVNybF9uaFtjXUxTXlcyYnQOb54Ae7wMcKJYaWi0rqbUz8fTz8fSzcXNycG/urKemY1bcXERb50sYnSOioHf29Lt6d/s6N/m4tnBvLFNcntrb2bFwLjt6eHu6eHt6eDr597q5t3n49qRkINrf3+1t7C5u7W6u7S+urG9urG5urTEw7vj39br59/s6eCuqZ0Qc6Uib5Ijb5EkbIxQZGN8d2qAem6JhXlDaXMibpEwaoGVmpLl4disp5sAe70OcKBscWnEv7fV0MjV0cnMx706a3sAe74IcqdjdnXTzcTq59+Mj4UBe7wBerskZoGSj4bi3dTv6+O5urIibpAAerscZod4enLW0cnu6+PPy8JFcoABebg9Y26zrKLp5dyOl5EMcqUCeLcbZodaY12uqJ/t6uHk4Nh3jY4Pb54JcqZdb27Iwrji3tVggYgKbZ4yX21obGavqaDi3dXd2dF9kJIVcZ0Wa5N/f3Xb1s7Lx70zboYvY3WDfXLFwLft6ODKycFhfYESb50AebouZ36emY6nraYWZolMbXXCvLOdoJcTZ44Cd7VIZGi6tKvr5t14jY4HcqgxbIO6tKm6tqprdG/SzcTs6N7e2dBJc38AebsUa5WOk4vn4tns6ODQy8I+dYoAeLgeZoaMi4Lf2tK+vLMncZISa5R3fnnb1czMx743c40AebkCebg2ZXWrpJno5NuSl44YY4IcZYRHXmCcmI6vsKcabpUHc6pYa2vDvbTk4NecnJNnbWd9eW+po5ra1c1nhIoGc6sRbpt3eG3Z1Mza1cze2dHh3dSAk5UUcJ0qa4ajn5Xn5Nzu6uLt6uLv6+Tp5d7Y1MyxtK1hgIgUcZ8lbYyTkYSxrqOxraOwraOtqp+XlIV9iIFReYUfaowGdKz///88yl8CAAAAAWJLR0TixgGeHAAAAAd0SU1FB+UECgcrNELreWwAAAGKSURBVBjTY2BgZGJGABZWNnYOTgYubh5eOODjFxAUEhZhEBUTl5BEBlLSMgyycvIKCvJgoKCgqKSspKyiyqCmrqGhoamlraWtoaGjq6evrGxgyGBkbGJsamZuYWFpZW1sY2unpCxvz8DJwODg6OTs4urmzuDh6eWtpOTjy+Dn5+8QEBikGBwS6hAWHhGpFBUdAxTkjI2LT1CST0xKTklNk0rPyMwCCjpk5+RKSublFxQWFZcEl5aVMzD4cTpUVFYppVfX1NbVSzU0NjUDrfHjbGltk1JSaO/o7FJWUuru8eD0Bwr29vUnKE2YOGnyFEklxanWDJx+DH4OjtOmz5CcOWv2nLnzlOYvWLgIKMjpsHjJUqX0Zcs9VqxcpSS/es1akOC69Rs2Kslv2rxl67Y8peDtOxyAgg47d+1WUtqzd9/+AweV5EsOHXbwAwoeOXoMGDLHp59Qlg8+eeo0JydQMOzM2XPnL1w4H3zx0uUrV68B7QYKMly/cfPW7ds379y9d//BQwZOf6AgACIJgNAMLRaxAAAAJXRFWHRkYXRlOmNyZWF0ZQAyMDIxLTA0LTEwVDA3OjQzOjUyKzAwOjAwjJgVBwAAACV0RVh0ZGF0ZTptb2RpZnkAMjAyMS0wNC0xMFQwNzo0Mzo1MiswMDowMP3FrbsAAAAASUVORK5CYII=",
      asSource: false,
      asTarget: true,
      seedDomSelector: "#top~table:first>tbody>tr:nth-child(3)",
      torrentDownloadLinkSelector: 'a[href*="download.php?id="]',
      uploadPath: "/upload.php",
      search: {
        path: "/torrents.php",
        imdbOptionKey: "4",
        nameOptionKey: "0",
        params: {
          incldead: "0",
          search_area: "{optionKey}",
          search: "{imdb}",
          sort: "5",
          type: "desc"
        },
        result: {
          list: ".torrents>tbody>tr",
          url: '.torrentname td a[href*="details.php?id="]',
          name: '.torrentname td a[href*="details.php?id="]',
          size: "td:nth-child(5)"
        }
      },
      name: {
        selector: "#name"
      },
      subtitle: {
        selector: 'input[name="small_descr"]'
      },
      description: {
        selector: 'textarea[name="descr"]'
      },
      imdb: {
        selector: 'input[name="url"][type="text"]'
      },
      torrent: {
        selector: 'input[name="file"]'
      },
      category: {
        selector: "#browsecat",
        map: {
          movie: "401",
          tv: "402",
          tvPack: "402",
          documentary: "404",
          cartoon: "405",
          sport: "407",
          concert: "406"
        }
      },
      videoCodec: {
        selector: 'select[name="codec_sel"]',
        map: {
          h264: "1",
          hevc: "10",
          h265: "10",
          x264: "1",
          x265: "10",
          mpeg2: "4",
          mpeg4: "1",
          vc1: "2",
          xvid: "3"
        }
      },
      audioCodec: {
        selector: 'select[name="audiocodec_sel"]',
        map: {
          aac: "20",
          ac3: "22",
          dd: "23",
          "dd+": "23",
          flac: "17",
          dts: "14",
          truehd: "13",
          lpcm: "15",
          dtshdma: "10",
          atmos: "11",
          dtsx: "12"
        }
      },
      videoType: {
        selector: 'select[name="medium_sel"]',
        map: {
          uhdbluray: "1",
          bluray: "1",
          remux: "3",
          encode: "7",
          web: "10",
          hdtv: "5",
          dvd: "6",
          hddvd: "2",
          dvdrip: "13",
          other: "13"
        }
      },
      resolution: {
        selector: 'select[name="standard_sel"]',
        map: {
          "4320p": "15",
          "2160p": "10",
          "1080p": "11",
          "1080i": "12",
          "720p": "13",
          "576p": "14",
          "480p": "14"
        }
      },
      area: {
        selector: 'select[name="processing_sel"]',
        map: {
          CN: "3",
          US: "4",
          EU: "8",
          HK: "5",
          TW: "3",
          JP: "5",
          KR: "6",
          OT: "9"
        }
      },
      source: {
        selector: 'select[name="source_sel"]',
        map: {
          uhdbluray: "6",
          bluray: "6",
          hdtv: "3",
          dvd: "8",
          web: "2",
          vhs: "12",
          hddvd: "7"
        }
      },
      team: {
        selector: 'select[name="team_sel"]',
        map: {
          other: "22"
        }
      }
    },
    HDBits: {
      url: "https://hdbits.org",
      host: "hdbits.org",
      siteType: "HDB",
      icon: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAMAAAC6V+0/AAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAACUlBMVEWwxdaswdKswtKtwtKtwdKtwtOovc6juMmit8miuMmes8SftMWtv86qvMues8Omucmwwc+htcaywtC3xtO3x9Oxw9CYrb6fs8Pd5OnQ2uKXrL29y9Xn7PCpusiousjq7vHs8PPi6Ozo7PDp7vHDz9qdscGSp7iarr7g5uvS2+KTp7mRpre8ydTs8PKltsXF0NmesMCktsTG0dry9fbCzteTqLmMobKVqLje5OnP2N+LoLGJnrC3xM/r7vGgscC4xc+Jn7GLoLKOo7PN1t2ZrLuFmqyPorLd4ufY3+SfsL6er73Fz9ebrLrq7fC1wsyEmauGm6yFmquot8P3+PmltMF/lKWJnKzb4OX19/jk6ezw8vTs7/GVp7WWp7Xp7O+xvsh+k6SAlaZ+k6Wpt8N4jZ+DlqbZ3+TO1dyHmqmFmKi1wcro6+6QorDn6+6tusR3jZ55jp94jZ6Yqbb2+PmdrLlyh5h9kaDX3eLFztVwhpeptcDm6u2LnauptsBxhpdziJlyh5m2wcqGmKdxh5hsgZJ3i5rW2+DDy9NtgZNrgJGlsr3l6eyGl6WntL5ug5Nyh5eYp7O6xMxxhZZme4xyhZXU2t+/yM9ne4xkeougrrjk6OuCk6GBkqDk5+vP1tvV29/d4uW5w8p0h5ZnfIxgdYZleYqLm6eCkqBhdoZhdod2iJeRn6trf49rfo6Uoq2dqrWeqrWWo69/kJ5hdYdbcIFZbn9Zb4Bab4BYbn9ab4FYbX9YbX5XbX9Wa3xRZndNYnJMYnJNYXJNYXNNYnNJXm////9b9tfLAAAAAWJLR0TFYwsrdwAAAAd0SU1FB+UECgcqMrKT7RgAAAFGSURBVBjTY2DABhjBgImRkRlEszAyszIyMbBhAQzsSICDkxNMM3Bx8/DycXHxCwgKCgmLiPJzAQGDmLiEpJiYlLSMrJy8gqKSsoqqmBiDmrqGppaato6unp6CvoGhkbGJqRqDmbmFpZWVtY2tnZ2tvYOjk7OSixWDq5u7h6enl7e8j4+vn39AYFBwSCBDaFh4RGRkZFR0TGxcfEJiUmxwcihDSmpaekZGZlZ2Tk5uXn5BYVFxSSFDaVl5RWlpZVV1TU11bV19Q6NvUzNDS2tbe0dHZ1d3T093b1//hOqJk1oYJk+ZOm369BkzZ82ekz133vwFCxdNXsywZOmy5StWLlm1es3ades3bNy0dMmKzQxbtmzdtmXLlu07dm7ZtXvPDhB7C8NeLIBhHxbAsP/AgYP79x86fPjggcOHDwHpw/sPMxzBAgDlBZmERX8RVgAAACV0RVh0ZGF0ZTpjcmVhdGUAMjAyMS0wNC0xMFQwNzo0Mjo1MCswMDowMPTFbxAAAAAldEVYdGRhdGU6bW9kaWZ5ADIwMjEtMDQtMTBUMDc6NDI6NTArMDA6MDCFmNesAAAAAElFTkSuQmCC",
      asSource: true,
      asTarget: true,
      needDoubanInfo: true,
      uploadPath: "/upload.php",
      seedDomSelector: "#details >tbody >tr:contains(Last seeded)",
      torrentDownloadLinkSelector: 'a[href*="download.php/"]',
      search: {
        path: "/browse.php",
        params: {
          sort: "size",
          d: "DESC",
          search: "{imdb}"
        }
      },
      name: {
        selector: "#name"
      },
      description: {
        selector: "#descr"
      },
      imdb: {
        selector: "#imdb"
      },
      mediaInfo: {
        selector: 'textarea[name="techinfo"]'
      },
      torrent: {
        selector: "#file"
      },
      category: {
        selector: "#type_category",
        map: {
          movie: "1",
          tv: "2",
          tvPack: "2",
          documentary: "3",
          concert: "4",
          sport: "5",
          cartoon: "1"
        }
      },
      videoCodec: {
        selector: "#type_codec",
        map: {
          h264: "1",
          h265: "5",
          hevc: "5",
          x264: "1",
          x265: "5",
          mpeg2: "2",
          vc1: "3",
          xvid: "4",
          bluray: "1",
          uhdbluray: "5",
          vp9: "6"
        }
      },
      videoType: {
        selector: "#type_medium",
        map: {
          uhdbluray: "1",
          bluray: "1",
          remux: "5",
          encode: "3",
          web: "6",
          hdtv: "4"
        }
      }
    },
    HDDolby: {
      url: "https://www.hddolby.com",
      host: "hddolby.com",
      siteType: "NexusPHP",
      icon: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAAAAACo4kLRAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAAAmJLR0QA/4ePzL8AAAAHdElNRQflBAoGHTIjVicbAAABTUlEQVQY01WOvy9DURzFz/feW0/1pY2gogaLX4lBJBZCqiKxITGYTGIx+wOsRpbGarEwV0SExCTR+LU0GoIYMLw8vFfv1b1fgz6p73DyzUnOOR/SBEL9MVhR+Kz/mdTRpOhhwSUYFgAMJLhhK6sQ3qUWrcfDewDpqR65U64AfG2POlw9HgS69gI287LAAgCYZXY1TitzMcMAIKLJsf6OKcG/IKo2iea0bo7gRERS8fyv6P+Ll0pPV/UmCRIv+bcgXyaiWid9XNgP2wXgdGm5jxwCwDdtDclUQiqllIwnU1Zin4mdg5BBYOBX5USGjPa0HXv/Tn3H6FM3sRUoqehpo7Nx4ER0u7nkpp3xx89m2wVcf+ZyNzN9dO16TuOrWA9bWACsWTATf/jc6g5/5hTLtaB42zN5Xhqxi6bi9Q59jcaJDLORVNUWNJGRxCD8AK0whyYuCRA4AAAAJXRFWHRkYXRlOmNyZWF0ZQAyMDIxLTA0LTEwVDA2OjI5OjUwKzAwOjAwOQaHIQAAACV0RVh0ZGF0ZTptb2RpZnkAMjAyMS0wNC0xMFQwNjoyOTo1MCswMDowMEhbP50AAAAASUVORK5CYII=",
      asSource: true,
      asTarget: true,
      seedDomSelector: "#top~table:first>tbody>tr:nth-child(3)",
      torrentDownloadLinkSelector: 'a[href*="download.php?id="]',
      uploadPath: "/upload.php",
      search: {
        path: "/torrents.php",
        imdbOptionKey: "4",
        nameOptionKey: "0",
        params: {
          incldead: "0",
          search_area: "{optionKey}",
          search: "{imdb}",
          sort: "5",
          type: "desc"
        }
      },
      name: {
        selector: 'input[name="name"]'
      },
      subtitle: {
        selector: 'input[name="small_descr"]'
      },
      description: {
        selector: "#descr"
      },
      imdb: {
        selector: 'input[name="url"][type="text"]'
      },
      douban: {
        selector: 'input[name="douban_id"]'
      },
      torrent: {
        selector: 'input[name="file"]'
      },
      tags: {
        chinese_audio: "#tag_gy",
        diy: "#tag_diy",
        chinese_subtitle: "#tag_zz",
        cantonese_audio: "#tag_yy",
        hdr: "#tag_hdr10",
        hdr10_plus: "#tag_hdrm",
        dolby_vision: "#tag_db"
      },
      anonymous: {
        selector: 'input[name="uplver"]'
      },
      category: {
        selector: "#browsecat",
        map: {
          movie: "401",
          tv: "402",
          tvPack: "402",
          documentary: "404",
          concert: "406",
          sport: "407",
          cartoon: "405",
          variety: "403"
        }
      },
      videoCodec: {
        selector: 'select[name="codec_sel"]',
        map: {
          h264: "1",
          x264: "3",
          hevc: "2",
          x265: "4",
          h265: "2",
          mpeg2: "6",
          mpeg4: "0",
          vc1: "5",
          xvid: "0",
          dvd: "0"
        }
      },
      videoType: {
        selector: 'select[name="medium_sel"]',
        map: {
          uhdbluray: "1",
          bluray: "2",
          remux: "3",
          encode: "10",
          web: "6",
          hdtv: "5",
          dvd: "8",
          dvdrip: "8",
          other: "0"
        }
      },
      audioCodec: {
        selector: 'select[name="audiocodec_sel"]',
        map: {
          aac: "6",
          ac3: "5",
          dd: "5",
          "dd+": "14",
          flac: "7",
          dts: "4",
          truehd: "2",
          lpcm: "3",
          dtshdma: "1",
          atmos: "2",
          dtsx: "1"
        }
      },
      resolution: {
        selector: 'select[name="standard_sel"]',
        map: {
          "2160p": "1",
          "1080p": "2",
          "1080i": "3",
          "720p": "4",
          "576p": "5",
          "480p": "5"
        }
      },
      team: {
        selector: 'select[name="team_sel"]',
        map: {
          dream: "1",
          hdo: "9",
          dbtv: "10",
          nazorip: "12",
          mteam: "2",
          frds: "7",
          wiki: "4",
          beast: "11",
          chd: "5",
          cmct: "6",
          pthome: "3",
          other: "8"
        }
      }
    },
    HDF: {
      url: "https://hdf.world",
      host: "hdf.world",
      siteType: "gazelle",
      icon: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAYAAACNiR0NAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAABmJLR0QA/wD/AP+gvaeTAAAAB3RJTUUH5QQMAxUG6ZvEkQAABCJJREFUOMt9lc1rXFUUwH/3vq958zIz+ZhJZkzS1Jo0ta0iSCm40YK2SxH3grhUBBf+G/0LBKkFty5cuKq40SIKRdtS0pCpmXxNMpP5yrzv9+510WmLbfG3Oodz4d574PyO4CkCpAUqAyEkQtiobAlYBxqTQwfABrADpIDiOQQv4gEfYdhX0PkKKveAwqQWAT7wD/AL8MMkf4r5JKi89yXpwf3XVJ5+koyOrmohLwrUlA766HEHYRfRaQRagxBjVHYBw1oTUn6HkFs6CZ+9cPrdz9CwKgWfStRXIg0KlhRCCEHQaTHcuoO9sEY2OkLnOcLx0EJr6ZYjhLyuc/2tEGxlu39hVN++hjq4W3SXzn/uzs1/PbNyxp5vzIvlshS1aQ+tNf1Oh9L6Owi7iFGqYTfWsOpnsBvnDLS+LFQ6Nk1+t+ZOZaZVmpVWpfZxxU6uuU7kCHwdOnN46Ygci8BLMUqzlOqLeCurqCTAHLWRhxukvUzE7mwhma1dy5JkE62+N0yn4EydOvuFlw4/KKQjM3crwsoj0Tk+YfdRk9FwgLtynvqMw1x0wNR4D8c/QgZ9oaOx0EKg3XKN0tw4PWz+ZI5am0vilYvLBddxpqSJCELsYoFMl9Gqx4w3xdyrb1AOW0iRo1WApVOM6SWcapHU8vCdGSfQ1vK401oyVRKe7e82vfn1tyjNn0aGPkWvBoakXvQoFzTeTIXIWMC3PbR0sd0Yr7LMfK1KZhRp9SJ29vc8lURrJipfoPvIKb9+jnpjic4opVoymC07GLmFK8ZoUzOqryKHA3KjgmHaTNcWeXNRME5MjodNou6+Q5YsmGgFg0NkPMY0BJoMSyi0dFHCIVMZ5ODhU5l2oFLDVy6hPUs3GLB7sM/2xh8Mtm6jtcIE3UYncRDD/liyedAlHwOFnDyLIR6CkLimIjag3byPPwyoXXifuFple6fNwVGLLDyO0LptTAblap7rM71+n85RC0Pm6KBDt/WA7c27DDotKgVFH5vtjb85uvcbYTCiK1zCxCdOA1Jhb+iToxsmsAvsHO/ci9nfdMzqMsPKJXJius0HdFqPcLwp5qtFholFHEVkUZ/uxq8UCmUapxYpV+tRZJRaIhnvmUAC/AycR2WXVRLqSJuMw1T4QQIqIklMHh6OiQa3SdrNxzOrU9yTPW2c2MKW1h0r9m/J+mpqABrYBBoIeVkUyobROCfC3Q2RHG491plKSXr75IM2pAGg0UrpeHSsR71+eNLv3bQqtW+U30+f9DADdrCKoTaLl3KlrKzTFISDZ17KU1D55P7H6DyNVJJcz3NuJO2tTrp/D+NpdXa9P/Gcr/yejd+bRucOL+cE+BO4iUpvkIyapP7/CvZD4ApwepK/TLC3gB+fF6z4b/j0OxKwgEVg7bkV8BDYm7TphRXwL0hsE/fwC5NaAAAAJXRFWHRkYXRlOmNyZWF0ZQAyMDIxLTA0LTEyVDAzOjIxOjA2KzAwOjAwm25q+wAAACV0RVh0ZGF0ZTptb2RpZnkAMjAyMS0wNC0xMlQwMzoyMTowNiswMDowMOoz0kcAAAAASUVORK5CYII=",
      asSource: false,
      asTarget: false,
      uploadPath: "/upload.php",
      search: {
        path: "/torrents.php",
        params: {
          order_way: "desc",
          order_by: "time",
          searchstr: "{name}",
          group_results: "1",
          action: "basic"
        }
      }
    },
    HDFans: {
      url: "https://hdfans.org",
      host: "hdfans.org",
      siteType: "NexusPHP",
      icon: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAYAAACNiR0NAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAABmJLR0QA/wD/AP+gvaeTAAAAB3RJTUUH5QQKBykVPLQLsAAABCVJREFUOMuVlctvVVUYxX97n3PPvb0t0BZKSKW0FdpSDCAkViMmjU9kAImaMDVGnOo/4IApGo0xccLQmYkgJhhfCSA4sgUJjz5JsbVwS/q6lN7bc/brc3AanGiiO9mjb+1k7d/KXlvxP9ax04tsfyKmMucatGYrsAysnHln82ON+rfDB967RXU+Zc/hroZSSTeXErVNKfq0Ym8cq6cizQ7rZKyeyYdxxFQ9Fc69u5kYYLxi8Q4aSiq5Mp2VhmZse93SGxS7g7BHK/qiiO44Ui1xRBxppZUC6+TpWMvVjw4WP/n6QeAcoE58s8xCVXZtKKmXTwyUD+/cHHWlTppTK80La7Lxh8ksWloLaKUoFWCwK+HJlhgBRIRI8WtXS3S8oFWlIdHElYWwt6msT0UFdeTStGEpjTnSWySJQIBqKpwfz/AiiFWMzjs2FTWD3QUmFz0/T2StFzxxMcrpxcAhYJ8XmJh3LNQCg90J09VAZ3PEoc4CN+Ys4wsOreBmxZFZ2L8t5uo9y6W7ZkOtJluBPwG0dVzNrCxlRjAOjBVEYHjWMjRr2VLWvNidUECRGcE6wTjBeGGpFgieFgV9CnjliwW0MWHEmjBjTMCagLUCwKO1wPmRlPlVz0BHgYPtMcYEjBXcusYHwXtpEpE9v99ew3tBX3x/S81YGXEu4HzA+wDrwEcrhh/HUwoaXu8t0lZWWJtrRCB4wftACNK/qzPZGIKgj56ex1q5YYxYawRrBRHBeyHNhJ9GUkYfOHraYl7aVUS84JyAgPe52+ClVylpQQT9qBbwPoxZEx46G3A2dxg8eBe4v+w4c61O3QRe6yuye0uMMYIA3gnWBLwLHRJkByLoNBMyIxVj5K5ZZygCzkvOzAhXJte4OJbS2hjxxv4GmhIIQXKNDTgnjc5Jf6wCsXMQhCpaJpSSZx4Dd4I1gkJYyeCroRr7ticMdBWp1sPfmkxQSmIvau9vS41o74VStlZzVkZsFoIxOXDvBJMFjMkxjM4azg7XiDS82l9iY0njbH5lawLehv7u0mqLvn6ynVUSrJMxa+WRMzlw5/OArMl3lga+HV5leCqjIdEkETgnmPW5s7IteGnXkKflvUxYK8utZU0hgnKs8OshORvwLlBZcnx5eYVq3aOUwjtZnwvOyR8SWIwBerYWKBfV7As9xeXne0pdm8qa48810dEa8fn3Ve4vO7TK3+rlkTX57lotvPVsky4X9YzzXItidV0JZ0Pq52KAYwfKbGiMaosP7egvt+sHLt6s5Q6CSGokeE8mmorSTNaMjF0YSWfeHGgqHT3YePnkmepQT2diAZn8uD0v2Ia3p+hrU9xbkcGCklME2kQxh2IyKeibkeIWSk2pSC8prR4iuDufdvxjMT9u7O4PpkGhEXYi0opS0yjmAX/3s87//E38BWXDuj9j0ViVAAAAJXRFWHRkYXRlOmNyZWF0ZQAyMDIxLTA0LTEwVDA3OjQxOjIxKzAwOjAws0DWvgAAACV0RVh0ZGF0ZTptb2RpZnkAMjAyMS0wNC0xMFQwNzo0MToyMSswMDowMMIdbgIAAAAASUVORK5CYII=",
      asSource: true,
      asTarget: true,
      uploadPath: "/upload.php",
      seedDomSelector: "#top~font table:first>tbody>tr:nth-child(5)",
      torrentDownloadLinkSelector: 'a[href*="download.php?id="]',
      search: {
        path: "/torrents.php",
        imdbOptionKey: "4",
        nameOptionKey: "0",
        params: {
          incldead: "0",
          search_area: "{optionKey}",
          search: "{imdb}",
          sort: "5",
          type: "desc"
        },
        result: {
          list: ".torrents>tbody>tr",
          url: '.torrentname td a[href*="details.php?id="]',
          name: '.torrentname td a[href*="details.php?id="]',
          size: "td:nth-child(5)"
        }
      },
      name: {
        selector: "#name"
      },
      subtitle: {
        selector: 'input[name="small_descr"]'
      },
      description: {
        selector: "#descr"
      },
      imdb: {
        selector: 'input[name="url"][type="text"]'
      },
      anonymous: {
        selector: 'input[name="uplver"]'
      },
      torrent: {
        selector: 'input[name="file"]'
      },
      category: {
        selector: "#browsecat",
        map: {
          movie: "401",
          tv: "402",
          tvPack: "402",
          documentary: "403",
          concert: "441",
          sport: "418",
          cartoon: "417",
          variety: "416",
          app: "419",
          ebook: "423",
          audioBook: "405"
        }
      },
      videoCodec: {
        selector: 'select[name="codec_sel"]',
        map: {
          h264: "1",
          hevc: "3",
          x264: "2",
          x265: "4",
          h265: "3",
          mpeg2: "10",
          mpeg4: "11",
          vc1: "5",
          xvid: "12"
        }
      },
      source: {
        selector: 'select[name="medium_sel"]',
        map: {
          uhdbluray: "1",
          bluray: "2",
          hdtv: "6",
          dvd: "7",
          web: "5",
          vhs: "10",
          hddvd: "17",
          cd: "9",
          sacd: "16"
        }
      },
      audioCodec: {
        selector: 'select[name="audiocodec_sel"]',
        map: {
          aac: "11",
          ac3: "10",
          dd: "21",
          "dd+": "21",
          flac: "12",
          dts: "2",
          truehd: "6",
          lpcm: "7",
          dtshdma: "4",
          atmos: "1",
          dtsx: "3",
          ape: "13",
          wav: "14",
          mp3: "17",
          m4a: "5",
          other: "7"
        }
      },
      videoType: {
        selector: 'select[name="source_sel"]',
        map: {
          uhdbluray: "1",
          bluray: "3",
          remux: "10",
          encode: "9",
          web: "7",
          hdtv: "6",
          dvd: "17",
          dvdrip: "17",
          other: "10"
        }
      },
      resolution: {
        selector: 'select[name="standard_sel"]',
        map: {
          "4320p": "1",
          "2160p": [
            "2",
            "10",
            "9"
          ],
          "1080p": [
            "3",
            "5",
            "8"
          ],
          "1080i": [
            "4",
            "5",
            "8"
          ],
          "720p": [
            "5",
            "11"
          ],
          "576p": "6",
          "480p": "6"
        }
      },
      area: {
        selector: 'select[name="processing_sel"]',
        map: {
          CN: "1",
          US: "2",
          EU: "8",
          HK: "4",
          TW: "5",
          JP: "6",
          KR: "7",
          OT: "9"
        }
      },
      team: {
        selector: 'select[name="team_sel"]',
        map: {
          hdfans: "9",
          hdf: "10",
          chd: "1",
          hdc: "2",
          ttg: "19",
          wiki: "3",
          beast: "4",
          cmct: "5",
          frds: "6",
          hdsky: "7",
          ourbits: "17",
          hdhome: "18",
          pthome: "16",
          tlf: "8",
          pter: "20",
          pbk: "21"
        }
      }
    },
    HDHome: {
      url: "https://hdhome.org",
      host: "hdhome.org",
      siteType: "NexusPHP",
      icon: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAYAAACNiR0NAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAABmJLR0QA/wD/AP+gvaeTAAAAB3RJTUUH5QQKBykVPLQLsAAABCVJREFUOMuVlctvVVUYxX97n3PPvb0t0BZKSKW0FdpSDCAkViMmjU9kAImaMDVGnOo/4IApGo0xccLQmYkgJhhfCSA4sgUJjz5JsbVwS/q6lN7bc/brc3AanGiiO9mjb+1k7d/KXlvxP9ax04tsfyKmMucatGYrsAysnHln82ON+rfDB967RXU+Zc/hroZSSTeXErVNKfq0Ym8cq6cizQ7rZKyeyYdxxFQ9Fc69u5kYYLxi8Q4aSiq5Mp2VhmZse93SGxS7g7BHK/qiiO44Ui1xRBxppZUC6+TpWMvVjw4WP/n6QeAcoE58s8xCVXZtKKmXTwyUD+/cHHWlTppTK80La7Lxh8ksWloLaKUoFWCwK+HJlhgBRIRI8WtXS3S8oFWlIdHElYWwt6msT0UFdeTStGEpjTnSWySJQIBqKpwfz/AiiFWMzjs2FTWD3QUmFz0/T2StFzxxMcrpxcAhYJ8XmJh3LNQCg90J09VAZ3PEoc4CN+Ys4wsOreBmxZFZ2L8t5uo9y6W7ZkOtJluBPwG0dVzNrCxlRjAOjBVEYHjWMjRr2VLWvNidUECRGcE6wTjBeGGpFgieFgV9CnjliwW0MWHEmjBjTMCagLUCwKO1wPmRlPlVz0BHgYPtMcYEjBXcusYHwXtpEpE9v99ew3tBX3x/S81YGXEu4HzA+wDrwEcrhh/HUwoaXu8t0lZWWJtrRCB4wftACNK/qzPZGIKgj56ex1q5YYxYawRrBRHBeyHNhJ9GUkYfOHraYl7aVUS84JyAgPe52+ClVylpQQT9qBbwPoxZEx46G3A2dxg8eBe4v+w4c61O3QRe6yuye0uMMYIA3gnWBLwLHRJkByLoNBMyIxVj5K5ZZygCzkvOzAhXJte4OJbS2hjxxv4GmhIIQXKNDTgnjc5Jf6wCsXMQhCpaJpSSZx4Dd4I1gkJYyeCroRr7ticMdBWp1sPfmkxQSmIvau9vS41o74VStlZzVkZsFoIxOXDvBJMFjMkxjM4azg7XiDS82l9iY0njbH5lawLehv7u0mqLvn6ynVUSrJMxa+WRMzlw5/OArMl3lga+HV5leCqjIdEkETgnmPW5s7IteGnXkKflvUxYK8utZU0hgnKs8OshORvwLlBZcnx5eYVq3aOUwjtZnwvOyR8SWIwBerYWKBfV7As9xeXne0pdm8qa48810dEa8fn3Ve4vO7TK3+rlkTX57lotvPVsky4X9YzzXItidV0JZ0Pq52KAYwfKbGiMaosP7egvt+sHLt6s5Q6CSGokeE8mmorSTNaMjF0YSWfeHGgqHT3YePnkmepQT2diAZn8uD0v2Ia3p+hrU9xbkcGCklME2kQxh2IyKeibkeIWSk2pSC8prR4iuDufdvxjMT9u7O4PpkGhEXYi0opS0yjmAX/3s87//E38BWXDuj9j0ViVAAAAJXRFWHRkYXRlOmNyZWF0ZQAyMDIxLTA0LTEwVDA3OjQxOjIxKzAwOjAws0DWvgAAACV0RVh0ZGF0ZTptb2RpZnkAMjAyMS0wNC0xMFQwNzo0MToyMSswMDowMMIdbgIAAAAASUVORK5CYII=",
      asSource: true,
      asTarget: true,
      uploadPath: "/upload.php",
      seedDomSelector: "#top~table:first>tbody>tr:nth-child(5)",
      torrentDownloadLinkSelector: 'a[href*="download.php?id="]',
      search: {
        path: "/torrents.php",
        imdbOptionKey: "4",
        nameOptionKey: "0",
        params: {
          incldead: "0",
          search_area: "{optionKey}",
          search: "{imdb}",
          sort: "5",
          type: "desc"
        },
        result: {
          list: ".torrents>tbody>tr",
          url: '.torrentname td a[href*="details.php?id="]',
          name: '.torrentname td a[href*="details.php?id="]',
          size: "td:nth-child(5)"
        }
      },
      name: {
        selector: 'input[name="name"]'
      },
      subtitle: {
        selector: 'input[name="small_descr"]'
      },
      description: {
        selector: "#descr"
      },
      imdb: {
        selector: 'input[name="url"][type="text"]'
      },
      douban: {
        selector: 'input[name="douban_id"]'
      },
      anonymous: {
        selector: 'input[name="uplver"]'
      },
      torrent: {
        selector: "#torrent"
      },
      tags: {
        chinese_audio: "#tag_gy",
        diy: "#tag_diy",
        cantonese_audio: "#tag_yy",
        chinese_subtitle: "#tag_zz",
        hdr: "#tag_hdr10",
        hdr10_plus: "#tag_hdrm",
        dolby_vision: "#tag_db"
      },
      category: {
        selector: "#browsecat",
        map: {
          movie: [
            "411",
            "412",
            "413",
            "414",
            "415",
            "450",
            "499",
            "416"
          ],
          tv: [
            "425",
            "426",
            "471",
            "427",
            "428",
            "429",
            "430",
            "452",
            "431"
          ],
          tvPack: [
            "432",
            "433",
            "434",
            "435",
            "436",
            "437",
            "438",
            "502"
          ],
          documentary: [
            "417",
            "418",
            "419",
            "420",
            "421",
            "451",
            "500",
            "422"
          ],
          concert: "441",
          sport: [
            "442",
            "443"
          ],
          cartoon: [
            "444",
            "445",
            "446",
            "447",
            "448",
            "454",
            "449",
            "501"
          ],
          variety: ""
        }
      },
      videoCodec: {
        selector: 'select[name="codec_sel"]',
        map: {
          h264: "1",
          hevc: "12",
          x264: "1",
          x265: "2",
          h265: "2",
          mpeg2: "4",
          mpeg4: "1",
          vc1: "3",
          xvid: "5",
          dvd: "5"
        }
      },
      source: {
        selector: 'select[name="source_sel"]',
        map: {
          uhdbluray: "9",
          bluray: "1",
          hdtv: "4",
          dvd: "3",
          web: "7",
          vhs: "8",
          hddvd: "8"
        }
      },
      audioCodec: {
        selector: 'select[name="audiocodec_sel"]',
        map: {
          aac: "6",
          ac3: "15",
          dd: "15",
          "dd+": "15",
          dts: "3",
          truehd: "13",
          lpcm: "14",
          dtshdma: "11",
          atmos: "12",
          dtsx: "17"
        }
      },
      videoType: {
        selector: 'select[name="medium_sel"]',
        map: {
          uhdbluray: [
            "10",
            "499",
            "500",
            "502",
            "501"
          ],
          bluray: [
            "1",
            "450",
            "451",
            "452",
            "453",
            "454"
          ],
          remux: [
            "3",
            "415",
            "421",
            "430",
            "437",
            "448"
          ],
          encode: [
            "7",
            "411",
            "412",
            "413",
            "414",
            "416",
            "417",
            "418",
            "419",
            "420",
            "422",
            "425",
            "426",
            "471",
            "427",
            "428",
            "429",
            "431",
            "432",
            "433",
            "434",
            "435",
            "436",
            "438",
            "444",
            "445",
            "446",
            "447",
            "449"
          ],
          web: [
            "11",
            "411",
            "412",
            "413",
            "414",
            "416",
            "417",
            "418",
            "419",
            "420",
            "422",
            "425",
            "426",
            "471",
            "427",
            "429",
            "431",
            "432",
            "433",
            "434",
            "436",
            "438",
            "444",
            "445",
            "446",
            "447",
            "449"
          ],
          hdtv: [
            "5",
            "412",
            "413",
            "416",
            "418",
            "419",
            "422",
            "424",
            "426",
            "471",
            "427",
            "428",
            "431",
            "433",
            "434",
            "435",
            "438",
            "442",
            "443",
            "445",
            "446",
            "449"
          ],
          dvd: [
            "",
            "411",
            "417",
            "425",
            "432",
            "444"
          ],
          dvdrip: [
            "7",
            "411",
            "417",
            "425",
            "432",
            "444"
          ],
          other: ""
        }
      },
      resolution: {
        selector: 'select[name="standard_sel"]',
        map: {
          "2160p": [
            "1",
            "499",
            "416",
            "500",
            "422",
            "431",
            "438",
            "502",
            "449",
            "501"
          ],
          "1080p": [
            "2",
            "414",
            "420",
            "429",
            "436",
            "447"
          ],
          "1080i": [
            "3",
            "424",
            "428",
            "435",
            "443"
          ],
          "720p": [
            "4",
            "413",
            "419",
            "423",
            "427",
            "434",
            "442",
            "446"
          ],
          "576p": [
            "5",
            "411",
            "417",
            "425",
            "432",
            "444"
          ],
          "480p": [
            "5",
            "411",
            "417",
            "425",
            "432",
            "444"
          ]
        }
      },
      team: {
        selector: 'select[name="team_sel"]',
        map: {
          "3201": "20",
          "969154968": "22",
          hdhome: "1",
          hdh: "2",
          hdhtv: "3",
          hdhpad: "4",
          hdhweb: "12",
          shma: "17",
          tvman: "21",
          arin: "19",
          ttg: "6",
          mteam: "7",
          other: "11"
        }
      }
    },
    HDPOST: {
      url: "https://pt.hdpost.top",
      host: "hdpost.top",
      siteType: "UNIT3D",
      icon: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAYAAACNiR0NAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAC4jAAAuIwF4pT92AAAAB3RJTUUH5QQKBy0Lotfz1wAABIZJREFUOMuNlG1olXUYxn/3//+cs3Oec852ztnRc1LnGG5Zrm2uQvAF0pAUgla+VRZIHyJm1IciiCj8FJWJxqhPUX2QBFHJXqBC0KnlG7nM0XRo6hw62XA76s52Xp7nuftgWkZFv0/3/eG6uLjhvoS/8fI7fQBWlbs10CWB8iCQAwKBQTEcNSLdIgyool1vzLlDL7eGl947he8rxkpj4GunNTxRHXPqamtCTtx1UFWuF3yu5sul8Un/N4VtxsgnqnoFhA9fv/dPwxffP42tCuEVy8tQ3s+lwy3zW2ponhUnVR0i5AgolCsBI/kyJ/rHOdZ3LRi74R0UI6+g2oMIH712D9K5pR/xFRWWC3w8tzE+47FFU8imw/wbqsqFoSJfHBjhzKXJk2JknaAnFMEERvBDptE3srH17sSMp5Zm/9MMQERomBbl2WU5GmZEW33h3cAx6cAKxquyxhNZn51S1dKxIEPCdW4Ly+UylUrl9u77PqVSCVUFYGoqTMfCDPFEaKkn8jQCBrhXQubxBc015P6S7PTp03R1dbFz5048zwOgu7ubTZs2cfjwYYIgAKBpWpS2xrj1raz1wjbjeEYWJ6OmrilrKJeKBHoz2cDAAIsWLSKXy6GqqCqzZ88mk8kwNDTE8PAwyWQSa4T2WXEOnS80Fz1tdzTsPFApjjib3t7MlUsXicfjrF27lunTp3Po0CHK5TLr1q3DdV2OHDnCmTNnWLx4MXv37mX37t3U1qa5Z+583NSSRKGgbaZi9K76+iydLzzPxMQEHR0dNDc347oura2tbNmyhf3793P27Fk2bNhAMpmksbGRnp4eYrEYq1etZtf2z5mYvGY0bHOOZ8W30QgNDQ0kEgnq6+uJRqNs376d3t5eLl68SH9/P8lkkgsXLrBjxw7y+TylUom+vj527dpFW3s7oVQN+QKBE4TM4FgloOQrcPNWiUSC0dFRtm7diuu6ZLNZXNdl6tSp7Nu3j2QySVNTE3V1dXR2duJm69l8fNL3HW/QwZGjQ8XgueEiVfe3t1NTU0MkEmHlypWMjY1RXV3NvHnzSKVSrF+/nt7eXtasWUOhUGDmzJnc19LCkctFRr2JPCFzQlZ8PdSg8M2KxticJ2dFsNZijKFUKlEoFFBVqqursdaSz+cBqKqqIhKJoBqg4tD1yzUOXirucYRVpug6530r2/ZdKem5AhhjbovS6TS1tbWEQiGMMaTTadLpNLFYDGstjhPi2EiJn0YrRRzzme+Y6ybkK+KYT4Yruv/TswUuT/j8X07lK2w9N8ENZYdY+VKNYHxrCBy5gpVXf73undx8apzefAX/j/f6J8qB8sNIiQ/6xxksBnuMlbd8RyYqEXuzvh7tvkoAGLTNh43JsHl4QSbszK8NM9M1RK2gwLinnC/4HBgpc3y0XCxUdKcV3gQGAoFvH8r8WbCPHMvjTPogpH14WuGZqJXmVNjEY44YVbjhqZ+vBPmSrz0Cn1n4CigEyQjftcbubOxbLP9xFLGKepIJoD2ANpScQmCEQQM/C5wU9Hoghu8Xpu7Q/w5HIu8yT4GwdgAAACV0RVh0ZGF0ZTpjcmVhdGUAMjAyMS0wNC0xMFQwNzo0NToxMSswMDowMDQkcScAAAAldEVYdGRhdGU6bW9kaWZ5ADIwMjEtMDQtMTBUMDc6NDU6MTErMDA6MDBFecmbAAAAAElFTkSuQmCC",
      asSource: true,
      asTarget: true,
      uploadPath: "/upload/1",
      needDoubanInfo: true,
      seedDomSelector: '#meta-info+.meta-general>.panel:has(".table-responsive"):first table tr:last',
      torrentDownloadLinkSelector: 'a[href*="download.php?id="]',
      search: {
        path: "/torrents",
        params: {
          name: "{name}",
          imdb: "{imdb}"
        }
      },
      name: {
        selector: "#title"
      },
      description: {
        selector: "#bbcode-description"
      },
      imdb: {
        selector: "#autoimdb"
      },
      tmdb: {
        selector: "#autotmdb"
      },
      mediaInfo: {
        selector: 'textarea[name="mediainfo"]'
      },
      anonymous: {
        selector: '.form__group input[type="checkbox"][name="anonymous"]'
      },
      torrent: {
        selector: "#torrent"
      },
      category: {
        selector: "#browsecat",
        map: {
          movie: "1",
          tv: "2",
          tvPack: "2"
        }
      },
      videoType: {
        selector: "#autotype",
        map: {
          uhdbluray: "1",
          bluray: "1",
          remux: "2",
          encode: "3",
          web: "4",
          hdtv: "6",
          dvd: "1",
          dvdrip: "12",
          other: ""
        }
      },
      resolution: {
        selector: "#autores",
        map: {
          "4320p": "1",
          "2160p": "2",
          "1080p": "3",
          "1080i": "4",
          "720p": "5",
          "576p": "6",
          "480p": "8"
        }
      }
    },
    HDRoute: {
      url: "http://hdroute.org",
      host: "hdroute.org",
      siteType: "NexusPHP",
      icon: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAYAAACNiR0NAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAABmJLR0QA/wD/AP+gvaeTAAAAB3RJTUUH5QQKBy01Y7bufAAAA3xJREFUOMttlc1vlFUUxn/nzjCoTEsnQClBIehIaNTG+hU0rkwXsNBo4n9QF40kuGFh3GqIC1aYEBKtf4NxA4su1ESNCSHYBBrxI7akQK3tQJwO7cw593Hxvh1a40nu5r3v+b3PPc9z8xpb6oPTpwEMaAIngQnDRkEHAQSLwJzQDOISxm+Azp//rM8wgFPvnwITyBpmvA28Z9gYqC7+t9qSZoEvJL6iohZuXLh4Afvkw49ZWF0gWdpvZmeASWUaGYGs0LWlUgLDyi21QNOIc5Hz0qE9h6jOL88DNMLyGdBUSlYfGa4xOFD5L4v19czyao/2mhdHMxrAlCQQZ+eX51vVzsY6O6s73sGYBOqVZLzx+gAvjg0ibSeudYKFxQ2+/eEec7+uUW7XgUmhuY1e58uUzI56xKR7NNwdj0ASZuWQzfqrvqvKs8d28e6b+zj8eI1ez3F33L0RHpMVakdTRJyI8DEPxz0I974yMyNn0XngbGwEADnD8N4aLzxXxyz3e9x9zCNOVMN9AijcFFQq6SEQaK85X1++A8BbJw6we2AHACPDNVIqgMVAqSNNVD18lBImoBoJKfdD1e1mbi894LFHq2Rps5leL+M93wrEYLTq7gc3hy6Bb1EIkCVee6nBM6NDDA3WkEASN27ep73WLd/tx+tgNTw2BYLAq9rursRAvdI/KsDV2VW++3GJbq+HmRXNpcqqeyyCmpvQqle2AQXkrL6SnMWNX+5xZ6lDsodRLXmLycPnPAKP0q3whzMskXf/6tDtFc8qFeNoc5DaDhUOR7HKyM2lHDETEe3wElrmsH/Zzbg6u8L8rXY/m8eagzz9ZJ2eO+FB2duOiJkUEZfDfTbC+19j2w0Ryysdvvn+Nu4ZCYZ27+SV8b2kJDyKU+XIsxFxOZl0M3JMe0RrU2GWSjdLozz46cpdbi0WKiV4eXyY/ft2FgojWpFjOiVu2qvHjwNqCPtIYipVqB95YoDG0COA6HaD3//8h84Dp3lkkN1ldHIWf8zf5979XtuMi5idBVrWPPAUew7vRZH3C86AJiPU0Bb7UjIMiKxyGsIwUrKWGdMY58zS0vrKCpXVdosDIyNkaQ10RWLB0D6Mhhk1K7MoCQPMwIy2GVdAnwo+t6y/s8TP169vxqeo8efHMcyEmkInzZiQGAU2b9MiMAfMAJeg+AVcu3atz/gXdAVC3vg+5BoAAAAldEVYdGRhdGU6Y3JlYXRlADIwMjEtMDQtMTBUMDc6NDU6NTIrMDA6MDCBhmVAAAAAJXRFWHRkYXRlOm1vZGlmeQAyMDIxLTA0LTEwVDA3OjQ1OjUyKzAwOjAw8Nvd/AAAAABJRU5ErkJggg==",
      asSource: false,
      asTarget: true,
      uploadPath: "/upload.php",
      search: {
        path: "/browse.php",
        imdbOptionKey: "4",
        nameOptionKey: "0",
        replaceKey: [
          "tt",
          ""
        ],
        params: {
          s: "{name}",
          dp: "0",
          add: "0",
          action: "s",
          or: "4",
          imdb: "{imdb}"
        }
      },
      name: {
        selector: "#title_eng"
      },
      subtitle: {
        selector: 'input[name="title_sub"]'
      },
      description: {
        selector: 'textarea[name="description"]'
      },
      poster: 'input[name="poster_big"]',
      imdb: {
        selector: "#upload-imdb_url"
      },
      anonymous: {
        selector: 'input[name="is_anonymous"]'
      },
      torrent: {
        selector: "#file_torrent"
      },
      tags: {
        chinese_audio: 'input[name="is_mandrain"]',
        cantonese_audio: 'input[name="is_cantonese"]',
        diy: 'input[name="is_diyed"]',
        chinese_subtitle: 'input[name="is_chs_sub_incl"]'
      },
      category: {
        selector: "#type_category",
        map: {
          movie: "1",
          tv: "3",
          tvPack: "3",
          documentary: "2",
          concert: "5",
          sport: "6",
          cartoon: "4",
          variety: "9"
        }
      },
      videoCodec: {
        selector: "#type_codec",
        map: {
          h264: "1",
          hevc: "7",
          x264: "1",
          x265: "7",
          h265: "7",
          mpeg2: "3",
          mpeg4: "1",
          vc1: "2",
          xvid: "4",
          dvd: "3"
        }
      },
      audioCodec: {
        selector: "#type_audio",
        map: {
          aac: "9",
          ac3: "5",
          dd: "5",
          "dd+": "5",
          flac: "7",
          dts: "4",
          truehd: "3",
          lpcm: "1",
          dtshdma: "2",
          atmos: "2",
          dtsx: "4"
        }
      },
      videoType: {
        selector: "#type_medium",
        map: {
          uhdbluray: "1",
          bluray: "1",
          remux: "2",
          encode: "4",
          web: "6",
          hddvd: "6",
          hdtv: "3",
          dvd: "6",
          dvdrip: "6",
          other: "6"
        }
      },
      resolution: {
        selector: "#type_resolution",
        map: {
          "2160p": "7",
          "1080p": "1",
          "1080i": "2",
          "720p": "4",
          "576p": "6",
          "480p": "6"
        }
      }
    },
    HDSpace: {
      url: "https://hd-space.org",
      host: "hd-space.org",
      siteType: "HDSpace",
      icon: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAMAAABg3Am1AAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAACK1BMVEUAAABMUFBITExMTFBOUFJQUlRSUlZQUFRMTlBUVFhaWlxKTE5ERkhISEw6PD48PkA8PEA+PkJAQkRCQkZEREhUVlhcXGBGRkg4OjxSVFZYWlxWVlpcYGBYWFxAQERiZGZwcHRoaGxEREZsbnBqam5gYGRwdHRsbHAgICIYGBgsLCweHh48PDxkZmh4eHyEhIgkJCREREQ0NDYqKiooKCgyMjRcXmBkZGimpqpUVFYuLi5gYmRqamoyMjJQUFBwcHA0NDReXmBISEg4ODhucHBsbGxwcnBwdHBeYGJmaGpGREZAQEB4fHyanJyIjIxgZGRISkxoamxYWFp+foKMjI5kZGS+wL6mqqiMkI52eHhMTEyEiIiYnJxUVFR4eHjO0tCoqqqQkpJ0dHScnKBISkpITE5ucHJ0dHhgYGJOTEx4enyQkpSYmJiQkJDc4ODY2NjAxMSgpKR8fICAhIRKSkxGSEp0eHgAAACIiIzk5OS4uLhydHQ4ODwmJiY8PD4ICAiChIaAgIQMDAwwMDC0tLi4uLx2dnb0+PTs8PDg4ODAxMAUFBSsrLDExMiQlJTk6Ojo7OzY3NiwtLQgICCcoKCoqKxgYGDw9PDc4NzMzMxQUFIcHBw4NjaMjJDAwMCwsLCanJ5AQkI0ODh4eHqQkJSgoKDM0NCkpKiUlJiwsLTY2NzIyMjAwMSUmJjU2NhscHBobGyIjIrQ0NB8gIDIyMz4+Py8vLy8vMD///8yzIHDAAAAAXRSTlMAQObYZgAAAAFiS0dEuE2/JvYAAAAHdElNRQflBhsHHAEWOn7hAAADz0lEQVRIx+3U63vTVBwH8JGeJD1J7+s5HU3SJKyX3bJWuXQuULRTaew2DGMD2ym6ame7S12HnIHILoBON0Bx3p3zAjjFu0z/PYN75M35B3jB91WeJ+dzvvklT05Ly6M8VNnDMC7AAsABlndDAbhFHjAer+jz+wPBUGuYArzIu92i6EIsDznEA57HrDcS8Xpa/W2Q8YcosJcHbpcIoyxEEsfKCkQuxu31eFqDgYAnFqQBhDwAIqtwURVCSdOjrOhlmHA45HMS8O+jG1iWBTyHOFZShKjcHpcQEL2RcDjmDbbFfHQDCzjIKhLLQYjlhKwlEynkFplIuJWJ+QK+GN3AKYiTEAc7OrswjupJjBHkGMbtDOBr87XSDZKAkMK6UHd3jwKB0Qu9eyASXZCJhfyxIA0k6Dw7EtIok3lMER7PdKns/sxuDhwMxYIUOIQQxjDb90R/PzAPH+nPHc31P8iTQQ8FnsIYJ2QzmR8YSDz9zMDAs8ecqwcJ8RRIFBKyahnqc8V8avBwsTg0fOy4gDjAs88Xi8V9LgoYhUJWtVN6Pn9i5ORoPjd26vQLVi6fNw2plM9HvDQwE4ZhJ0dLpdHy+Iull86MvfzKRK6Uq1QEplR69TUKHDeztl2dfL1Wq09N12ozs4035pq1GkrPI6ZWO/smBSzTiqfONfcTsjA3SMj0+fONC28RcpHFchchb9PAsFKXFgmVc0vL9QwhJZYCcXtld8mBE/8vXrlMFucntSwhGQnSr7XTKVZzhFhXrhLyzrurq++93006dVntIAQoiAIXCRmwtYNkbf3adUKGbtz44MObhBwx5MvOjYJwiAIfOdtO6ovE3Pj4E0Ian372+dgSIT1ffOkUy0KUBmtkpZL+iqxsLi10k46vG2e25s7ujtIWbxcUGnSSxW+ccbXm/SG/vb5+dXzpO2f1Wo9qVG2MVQoE/tvNuzzx/fJ0uXdkemg+GdctKxWfrKRNu3mLArcvEdIdUdX65tSMVtWWysl2S7WrWnLuTt/QlfU5CvyQHpmaMOvb2+nlCdNSq71xPR4fKQ//+NPd9TuzfU36w2VTOsSVn08aVtU21JRm2/Xh7V/WZ3/dKN8e1ywKqGpC5BPbCwWc7dUtvaqltOXNcnpmY3vwt9+Pzv9BgUnTAghzvIKxJpvOn2HdL6nG25u3hk+f+nOLAgLggYB5SZE4XpBxQVWzhlHXtM0LjWtjd7f+osBeFkDn8HOOYZdz9kkKLuhNo14Zv7ez07i5qcoUYEUQdYmAYUS3m+Pl9gIu2NmZe3/P7qz+kzYKiZZHeajyL1zy+j56IdRgAAAAJXRFWHRkYXRlOmNyZWF0ZQAyMDIxLTA2LTI3VDA3OjI4OjAxKzAwOjAwPxKVSgAAACV0RVh0ZGF0ZTptb2RpZnkAMjAyMS0wNi0yN1QwNzoyODowMSswMDowME5PLfYAAAAASUVORK5CYII=",
      asSource: true,
      asTarget: true,
      seedDomSelector: "#mcol>table>tbody>tr:last table:first>tbody>tr:nth-child(2)",
      torrentDownloadLinkSelector: 'a[href*="download.php?id="]',
      needDoubanInfo: true,
      uploadPath: "/index.php?page=upload",
      search: {
        path: "/index.php",
        imdbOptionKey: "2",
        nameOptionKey: "0",
        replaceKey: [
          "tt",
          ""
        ],
        params: {
          search: "{imdb}",
          page: "torrents",
          options: "{optionKey}",
          order: 4,
          by: 2
        }
      },
      name: {
        selector: "#filename"
      },
      imdb: {
        selector: 'input[name="imdb"]'
      },
      description: {
        selector: 'textarea[name="info"]'
      },
      anonymous: {
        selector: 'input[name="anonymous"][value="true"]'
      },
      torrent: {
        selector: 'input[type="file"][name="torrent"]'
      },
      category: {
        selector: 'select[name="category"]',
        map: {
          movie: [
            "15",
            "40",
            "16",
            "18",
            "19",
            "41"
          ],
          tv: [
            "15",
            "40",
            "16",
            "21",
            "22"
          ],
          tvPack: [
            "15",
            "40",
            "16",
            "21",
            "22"
          ],
          documentary: [
            "15",
            "40",
            "16",
            "24",
            "25"
          ],
          cartoon: [
            "15",
            "40",
            "16",
            "27",
            "28"
          ],
          concert: [
            "15",
            "40",
            "16",
            "31"
          ]
        }
      },
      videoType: {
        map: {
          uhdbluray: [
            "15"
          ],
          bluray: [
            "15"
          ],
          remux: [
            "40"
          ],
          encode: [
            "18",
            "19",
            "41",
            "21",
            "22",
            "24",
            "25",
            "27",
            "28",
            "31"
          ],
          web: [
            "18",
            "19",
            "41",
            "21",
            "22",
            "24",
            "25",
            "27",
            "28",
            "31"
          ],
          hdtv: [
            "18",
            "19",
            "41",
            "21",
            "22",
            "24",
            "25",
            "27",
            "28",
            "31"
          ]
        }
      },
      resolution: {
        map: {
          "2160p": [
            "15",
            "40",
            "16",
            "41"
          ],
          "1080p": [
            "19",
            "22",
            "25",
            "28",
            "31"
          ],
          "1080i": [
            "19",
            "22",
            "25",
            "28",
            "31"
          ],
          "720p": [
            "18",
            "21",
            "24",
            "24",
            "31"
          ]
        }
      }
    },
    HDT: {
      url: "https://hd-torrents.org",
      host: "hd-torrents.org",
      siteType: "HDT",
      icon: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAQAAAAngNWGAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAAAmJLR0QA/4ePzL8AAAAHdElNRQflBAoHLibMJfxhAAABTklEQVQoz4XSz2oTURzF8c+dyUwSqSUKitJuqq5cFxfWt/BpfCxfwa2CC3VjsUWptYUqJmlmzEzujIuk+SNIzg/u6svh3PP7BSQSrS0KEq+8UG0DSb3Wbp/Ounn6j0erWWZagpkducDSBGqlWrsC+/btm4mIolpEpuvKD5N1cOBYgSBq5DJRqWvP3RUYpGpXDlz76UBuz67SNx/RE7Q3YKvS9cxXlUMDDxUmHrsUzVYgqVyw44GhXbkzb5ReemRsuvp1kMpE9z13pO+DPxpDx3pG6s16glThrU+eKhWmOnouVIuiOjfVRsHQqXe6BvqeqGW+CxKYv/N6K5+dmzpz4rc7bvviAtmq8EYjl3svap0Izt0ycSnom61vpjBxqFSj0WrQc0/fL+P1jIVTI6l2EaTRChLRyPU62BgrZMLGBbeL7W/UMz+G/yvZftlz/QVf65MTdoZVvQAAACV0RVh0ZGF0ZTpjcmVhdGUAMjAyMS0wNC0xMFQwNzo0NjozOCswMDowMAiuiIoAAAAldEVYdGRhdGU6bW9kaWZ5ADIwMjEtMDQtMTBUMDc6NDY6MzgrMDA6MDB58zA2AAAAAElFTkSuQmCC",
      asSource: true,
      asTarget: true,
      seedDomSelector: ".listadetails>tbody>tr:nth-child(2)",
      torrentDownloadLinkSelector: 'a[href*="download.php?id="]',
      needDoubanInfo: true,
      uploadPath: "/upload.php",
      search: {
        path: "/torrents.php",
        imdbOptionKey: "2",
        nameOptionKey: "3",
        params: {
          search: "{imdb}",
          options: "{optionKey}",
          order: "size",
          by: "DESC"
        }
      },
      name: {
        selector: 'input[name="filename"]'
      },
      imdb: {
        selector: 'input[name="infosite"]'
      },
      description: {
        selector: 'textarea[name="info"]'
      },
      tags: {
        hdr: 'input[name="HDR10"]',
        hdr10_plus: 'input[name="HDR10Plus"]',
        dolby_vision: 'input[name="DolbyVision"]'
      },
      anonymous: {
        selector: 'input[name="anonymous"][value="true"]'
      },
      torrent: {
        selector: 'input[name="torrent"]',
        announce: "https://hdts-announce.ru/announce.php"
      },
      category: {
        selector: 'select[name="category"]',
        map: {
          movie: [
            "70",
            "1",
            "71",
            "2",
            "64",
            "5",
            "3",
            "63"
          ],
          tv: [
            "72",
            "59",
            "73",
            "60",
            "65",
            "30",
            "38"
          ],
          tvPack: [
            "72",
            "59",
            "73",
            "60",
            "65",
            "30",
            "38"
          ],
          documentary: [
            "70",
            "1",
            "71",
            "2",
            "64",
            "5",
            "3",
            "63"
          ],
          cartoon: [
            "70",
            "1",
            "71",
            "2",
            "64",
            "5",
            "3",
            "63"
          ],
          concert: [
            "61",
            "62",
            "66",
            "57",
            "45",
            "44"
          ],
          variety: [
            "72",
            "59",
            "73",
            "60",
            "65",
            "30",
            "38"
          ]
        }
      },
      videoType: {
        map: {
          uhdbluray: [
            "70",
            "72"
          ],
          bluray: [
            "1",
            "59",
            "61"
          ],
          remux: [
            "71",
            "2",
            "62",
            "73",
            "60"
          ],
          encode: [
            "64",
            "5",
            "3",
            "65",
            "30",
            "38",
            "66",
            "57",
            "45"
          ],
          web: [
            "64",
            "5",
            "3",
            "65",
            "30",
            "38",
            "66",
            "57",
            "45"
          ],
          hdtv: [
            "64",
            "5",
            "3",
            "65",
            "30",
            "38",
            "66",
            "57",
            "45"
          ]
        }
      },
      resolution: {
        map: {
          "2160p": [
            "70",
            "72",
            "71",
            "73",
            "64",
            "65",
            "66"
          ],
          "1080p": [
            "1",
            "59",
            "61",
            "2",
            "60",
            "62",
            "5",
            "30",
            "57"
          ],
          "1080i": [
            "1",
            "59",
            "61",
            "2",
            "60",
            "62",
            "5",
            "30",
            "57"
          ],
          "720p": [
            "3",
            "38",
            "45"
          ]
        }
      }
    },
    HDTime: {
      url: "https://hdtime.org",
      host: "hdtime.org",
      siteType: "NexusPHP",
      icon: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAMAAABEpIrGAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAABnlBMVEVyICB6Hh57HR2GGhqKGBiLGBiRJiajTEx+IiKeQkKDLS2BKiqYOjp9ISGYODiNHh6PFxeQFxeuWlqzYWGeNjaxXl6iQECSHx+nSUm1ZGS0Y2OtV1eaMDCTIyOuV1e0ZGTt4eH59fW7dHTz7OzIlJSXLy/Vr6/////+/f3y6enJmJicNDSbOzvq19fStbX28PDjzs7izMzw5ub17+/CioqeQ0PRq6vhysrz6+vizc3gysrBlZXl09OpU1OjRka0amrn1NTfxsakSUmfPDyjRESqVVXu4uLcvr6pVlaiRETfysqXKSmSHR27dXX8+vqsVVWZKyvq3Nz37+/y5eX9/PytVlbx6Oj38vKwXFz+/v77+Pj59PSsVlbw5+f38/OwXV37+fnWs7O8gYH48/OQGBixYGCvW1uZMTHLm5vr3d2pUFDFiIjBgIDPoqL17u7Tra2bNDT8+/vkz8+tXFyRGxvRr6/ZvLyvXl7XubnXurq4d3eVKCi+hYXbv7/Zvb2mSUmTISGWJyfQra2aMzOcNTWVJCSQGhqXKiqRGhqbMzMP6rAIAAAAEHRSTlPB4en7/f39/en96en96f39DMn6iQAAAAFiS0dEJy0PqCMAAAAHdElNRQflBgoEEjQ06RnvAAABJUlEQVQ4y2NgYGTCAxgZGBiZWVhxAhZmRgYmFgE8gIWJgYlVQBAnEGAdNgrYhIRFgGxRYTFxCUkgkJKWEZSVkwQDeXYOBiZOBUUloAJlRRVVNXUg0NDU0tbRVYcAPS40BfoGhkbqxiamZuYGiuoWllbW3GgKbGzt7B3UHZ2cXVzd1N09PHl40RR4eQv6+PoZ+QsKBgSqq6mCHcmpoBEUHBwcAlMgGBoWHoGqIDIqOjpaA64gJjYuHlVBQmJSUlIyTEFKqr5+GqoCFDekpGeoZ2bhVKCQnZObF5JfgFMBCBQWFZcgK+ArLSsHKqiorKquqQWCOq36BiC/sam2phqsgL+5pRUo0KLt3dbeAgTa3uB46uhsaW8bNAmGcgWEsh7BzEso+wMAFb1rT/22c/EAAAAldEVYdGRhdGU6Y3JlYXRlADIwMjEtMDYtMTBUMDQ6MTg6NTErMDA6MDD9uTIQAAAAJXRFWHRkYXRlOm1vZGlmeQAyMDIxLTA2LTEwVDA0OjE4OjUxKzAwOjAwjOSKrAAAAABJRU5ErkJggg==",
      asSource: true,
      asTarget: true,
      seedDomSelector: "#top~table:first>tbody>tr:nth-child(5)",
      torrentDownloadLinkSelector: 'a[href*="download.php?id="]',
      uploadPath: "/upload.php",
      search: {
        path: "/torrents.php",
        imdbOptionKey: "4",
        nameOptionKey: "0",
        params: {
          incldead: "0",
          search_area: "{optionKey}",
          search: "{imdb}",
          sort: "5",
          type: "desc"
        },
        result: {
          list: ".torrents>tbody>tr",
          url: '.torrentname td a[href*="details.php?id="]',
          name: '.torrentname td a[href*="details.php?id="]',
          size: "td:nth-child(5)"
        }
      },
      name: {
        selector: "#name"
      },
      subtitle: {
        selector: 'input[name="small_descr"]'
      },
      description: {
        selector: "#descr"
      },
      imdb: {
        selector: 'input[name="url"][type="text"]'
      },
      mediaInfo: {
        selector: 'textarea[name="technical_info"]'
      },
      torrent: {
        selector: 'input[name="file"]'
      },
      tags: {
        diy: 'input[type="checkbox"][name="tags[]"][value="8"]',
        chinese_audio: 'input[type="checkbox"][name="tags[]"][value="16"]',
        chinese_subtitle: 'input[type="checkbox"][name="tags[]"][value="32"]',
        hdr: 'input[type="checkbox"][name="tags[]"][value="64"]',
        hdr10_plus: 'input[type="checkbox"][name="tags[]"][value="64"]'
      },
      category: {
        selector: "#browsecat",
        map: {
          movie: "401",
          tv: "402",
          tvPack: "402",
          documentary: "404",
          concert: "406",
          sport: "407",
          cartoon: "405",
          variety: "403"
        }
      },
      videoCodec: {
        selector: 'select[name="codec_sel"]',
        map: {
          h264: "1",
          hevc: "12",
          x264: "10",
          x265: "12",
          h265: "12",
          mpeg2: "4",
          mpeg4: "1",
          vc1: "2",
          xvid: "3",
          dvd: "4"
        }
      },
      videoType: {
        selector: 'select[name="medium_sel"]',
        map: {
          uhdbluray: "1 ",
          bluray: "1",
          remux: "3",
          encode: "7",
          web: "7",
          hddvd: "2",
          hdtv: "5",
          dvd: "6",
          dvdrip: "6",
          other: "0"
        }
      },
      team: {
        selector: 'select[name="team_sel"]',
        map: {
          hdtime: "6",
          hdt: "12",
          vtime: "15",
          padtime: "7",
          cmct: "8",
          wiki: "4",
          beast: "3",
          chd: "2",
          other: "5"
        }
      }
    },
    HDU: {
      url: "https://pt.hdupt.com",
      host: "hdupt.com",
      siteType: "NexusPHP",
      icon: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAYAAACNiR0NAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAABmJLR0QA/wD/AP+gvaeTAAAAB3RJTUUH5QQKBy8jpVQ5rwAABFlJREFUOMs9lElvXMcBhL9e3j4LZ6gR6SFpLhITWU4gKTSyIRdHgZBTfpN/UZBrTrEBI4ccAmRBLjYgWZFEUZztLTNv6dfdOVAI6lKnQhUKVeIPFydeSokQAqUU86NPePyTSx59/oD9/QFCAEhQA2Q6QURjOgP//vs/+POf/shmtcYLiUfgvUdN48FXjZP0QvOjx5c8f/FrLh/OiAOLNS3O1HR1gbM9QkY4r7HWs394xGCyR1WWrLeGzkmcDFDDwfQrGUb87OkjXjz/gulQ0m+XeG9x3mO6FtM2dKan2Va024reGHpCDo+OOdiL0GHKphHIcIgeTA958ctHfPmLh0i34+b1W7Q3hFFI0xlUlCKlQoUe6x29rXH+hmBUk+7N6KxkOJ5yehpzu2nRz3/zhC9//pBYtbx/ec3bl69wXc1klLLZ9axqwafn53jZkiZDrn94xfHZGYYcnU3wwNff/oXj8yuy0R76d7+6JFaecl1S5iVKK9J4iJWCk4tT5iJmnTfsjOX9as3X3/yNLxYfuHr2BKtb9sZzjk9OeP3uB84uforeFRtcqGi7HofEiwCnY1abNYv8FYfzQzSCemepW8vDkwmZavjvd/+iWP+VbHbO1WdPWVXf4zzodtdQrXdUZYlH8iFvuF0uMX3Htqg4Wu44nB9Q5i1CaT6dZbi25s37FZvSsHj7PU+GF1w9u+LNokW/eXnDeDagqg14i1URr2/f0vUObywqbHAqp1hucb5nfqBpasdt0bIVI75b52z/+R9+/9tjpFLI63crwnTM/aMzVoVhU3UEcYIOI5I0w1rB8npNvioo25Ztp1hXnrIVOBWRjWc0dU1RNQgp0Pkq5/rNguHekKKs2eQlaRKjXI0wHtEZTNNRNTXjyQFNo+gaSW8EWg/Znw7IhiNaGyKQaNc23F7fUOxKrO2YjDKqakfvHML1aC/AexIdEBByuyhZFTmdjrE7x/mDU87OT+/miUCbvmNbViSjmPnhPcp8w2axwjQN2nmQIUpp9pOMUGl6oTAyIBhO+ezzZ5xdXKD13RcIAdpYg7UtUQB917Je5pjWIKxFeEU6mqC8QFpDNrrP+JMfcxanDGbHjOcH6NgjhUAiEEIgvfc02x1lXrL4sKTKS2xrwAm0CkkmBzROki9zgnjK+PwpgQyJtCAbSAZZRJaGpGlAmgToNA5o6o5iVdK3Dar3RCrAek+UjghHM+Ryzfj+KcHsnGg8xfdL9g5HJEmA+OjMA8IL9CgOabYFN+9uieMI7yVeWIIoYrg/xxrBeP+M8fEDiDPiCO4/vkSFdyXcAe6OUyBT4UiVp9gULFYFTddje0iye0gZY27ek907ITu+JBuNiBOPDhXcyQDgAbwHPDrWinESkemGqjXsrCUMIorVmmaZk4QZu+2aqQcZBCgl8fiPEfnI/q+KFl6QRSF7SURtGpwVWCydLSFMcL0nXrzGrG+I9oc4LzEteOfw3uOtA+9xzoJ1/A9EnjRTvBUMaAAAACV0RVh0ZGF0ZTpjcmVhdGUAMjAyMS0wNC0xMFQwNzo0NzozNSswMDowMIa7gnQAAAAldEVYdGRhdGU6bW9kaWZ5ADIwMjEtMDQtMTBUMDc6NDc6MzUrMDA6MDD35jrIAAAAAElFTkSuQmCC",
      asSource: true,
      asTarget: true,
      seedDomSelector: "#top~table:first>tbody>tr:nth-child(3)",
      torrentDownloadLinkSelector: 'a[href*="download.php?id="]',
      uploadPath: "/upload.php",
      search: {
        path: "/torrents.php",
        imdbOptionKey: "4",
        nameOptionKey: "0",
        params: {
          incldead: "0",
          search_area: "{optionKey}",
          search: "{imdb}",
          sort: "5",
          type: "desc"
        }
      },
      name: {
        selector: 'input[name="name"]'
      },
      subtitle: {
        selector: 'input[name="small_descr"]'
      },
      description: {
        selector: "#descr"
      },
      imdb: {
        selector: 'input[name="url"][type="text"]'
      },
      anonymous: {
        selector: 'input[name="uplver"]'
      },
      torrent: {
        selector: 'input[name="file"]'
      },
      category: {
        selector: "#browsecat",
        map: {
          movie: "401",
          tv: "402",
          tvPack: "402",
          documentary: "404",
          concert: "406",
          sport: "407",
          cartoon: "405",
          variety: "403"
        }
      },
      videoCodec: {
        selector: 'select[name="codec_sel"]',
        map: {
          h264: "1",
          hevc: "14",
          x264: "16",
          x265: "14",
          h265: "14",
          mpeg2: "18",
          mpeg4: "18",
          vc1: "2",
          xvid: "3",
          dvd: "18"
        }
      },
      audioCodec: {
        selector: 'select[name="audiocodec_sel"]',
        map: {
          aac: "6",
          ac3: "2",
          dd: "2",
          "dd+": "2",
          flac: "7",
          dts: "4",
          truehd: "3",
          lpcm: "11",
          dtshdma: "1",
          atmos: "17",
          dtsx: "16"
        }
      },
      videoType: {
        selector: 'select[name="medium_sel"]',
        map: {
          uhdbluray: "11",
          bluray: "1",
          remux: "3",
          encode: "7",
          web: "10",
          hddvd: "2",
          hdtv: "5",
          dvd: "6",
          dvdrip: "6",
          other: "0"
        }
      },
      resolution: {
        selector: 'select[name="standard_sel"]',
        map: {
          "2160p": "5",
          "1080p": "1",
          "1080i": "2",
          "720p": "3",
          "576p": "4",
          "480p": "4"
        }
      },
      area: {
        selector: 'select[name="processing_sel"]',
        map: {
          CN: "1",
          US: "2",
          EU: "2",
          HK: "3",
          TW: "3",
          JP: "4",
          KR: "5",
          IND: "6",
          SEA: "8",
          OT: "7"
        }
      }
    },
    HH: {
      url: "https://hhanclub.top",
      host: "hhanclub.top",
      siteType: "HanHan",
      icon: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAMAAAC6V+0/AAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAB+FBMVEX/////+/r/8O3/5N/+08z+xLr/8O7//f3/6eb+z8f+uq7+rp//rJ3+rZ//saT+tqn/t6r+ppb+jHj/eWL/bVT/ZUv/XkP+oZH//Pv//fz+2NH+mYj/b1f/X0P/aE7+fmf/XED/Wj3/Wj7+gGr/XEH/Wz//XD//Wz7/blX+497+1Mz+a1L/WT3+hXD+2dL+sqX+3tj/Zkv/Ykf+zsb+vrP/XkL+i3b+5N//tan/6+j/X0T+w7n+z8b/Y0j+jnv+6uf/clr/taj/8vD/dV3+vbL+5eD+kn//eGD/9/X/e2X+vLH/8/H+f2n+lYL/9PP/fWf/WTz+taj/+vn/gWv+vbH+l4X/+Pf+iHT/a1L+x73/hnH+vLD+mIb+4tz/3tj/5uH/7uv/+/v+inb+wLX+wrj+moj//Pz+u7D/n4/+m4n/kn/+h3L+w7j//v3+jXn+pJT+nIr/Vjr/Vzv/r6H+kHz/YEX+yL7+4t3/b1b+no3//v7+lIH/sKL+k4H+zMP+oJD+m4r+zsX+xrz+o5P+opL+sKL+p5j+qpz/ZEn+0sr+19H+mIf+rJ3/Z03+2tT+7er+inX/cVj/ZUr+i3f+dFz/6uf/6ub+uq3+rqD+nIv9fmj+cVn/YUb/ZEr/alH+6ub+4Nr+zcT+wrf+zcX+1M3/08z/0cn/9vQySTsrAAAAAWJLR0QAiAUdSAAAAAd0SU1FB+cKGggqKOZMG6oAAAFmSURBVBjTTdHlW4IxEADwEwMVu8BA907nizrrtVHs7sLuwG4xUFGxu7v733TDL+7Lbb/dPffcBvB/2chs7ewd+E7u6OSscHF1c/fw9PL28fVTqsA/IDBIHRyCBIxxUGgYCRc1ERAZRUUaHRNMEMKxcfEsSAmQmIQQTU7x4ZiaxoM2HTJ0DDOzskWGObl5GKGkfCjQEEQLZUWYZxaXcCyFsnKMaEVlFSVidU1tncCwHkAhIqpvaNQ1ZXs3q1oY+iUCtLLyNnl7R2daV0N3D0VI3QvQxxr1GwYGh4ZHRsfGqbW7fIJlThq8piidnoFZhsY5mF9guGhaYie8DCssSGaYM7LyVVj7Qz3HdbBw3IBNjlvWO10GOPGJtmFH4LODkuHuHuz7EiQcGA45Kv1ZATk6hpNoLFDp9Iy9BDm/0BBSfXkFcH1ze3f/8Kg1GqVdSXp6HjHLrb9genl9e7dYPj6/vr9efwB+AedbWaa0tk+DAAAAJXRFWHRkYXRlOmNyZWF0ZQAyMDIzLTEwLTI2VDA4OjQyOjM5KzAwOjAwIhY7NQAAACV0RVh0ZGF0ZTptb2RpZnkAMjAyMy0xMC0yNlQwODo0Mjo0MCswMDowMMwWz0MAAAAodEVYdGRhdGU6dGltZXN0YW1wADIwMjMtMTAtMjZUMDg6NDI6NDArMDA6MDCbA+6cAAAAAElFTkSuQmCC",
      asSource: true,
      asTarget: false,
      uploadPath: "/upload.php",
      needDoubanInfo: true,
      seedDomSelector: ".bg-content_bg div.leading-6:nth-child(5)",
      torrentDownloadLinkSelector: 'a[href*="download.php?id="]',
      search: {
        path: "/torrents.php",
        imdbOptionKey: "4",
        nameOptionKey: "0",
        params: {
          incldead: "0",
          search_area: "{optionKey}",
          search: "{imdb}",
          sort: "5",
          type: "desc"
        },
        result: {
          list: ".torrenttable>tbody>tr",
          url: '.torrentname td a[href*="details.php?id="]',
          name: '.torrentname td a[href*="details.php?id="]',
          size: "td:nth-child(5)"
        }
      }
    },
    HUNO: {
      url: "https://hawke.uno",
      host: "hawke.uno",
      siteType: "UNIT3D-Legacy",
      icon: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAYAAACNiR0NAAAACXBIWXMAAAsTAAALEwEAmpwYAAADOklEQVR4nL1U32/TVhT+kpUXeIAW/gd4Ytr+gT1XCBC/JJAm8RYJTaNqrmP73sRxC+w/mJCmTUKa4AUhBLET0rERDbQ9dR1FRRRBW8UJELa2lC52nNj1QddpsoYB2st2pE86Oj76fI6+7x7gf4gEiLp4TxBRQiLufW/IhkplCNhKJGsU1whIVExzaCtJr0b0NrFJyf5EREkU1vfgOu2O6z3izR+Zppms6/ruZ+n0HjLNZH/izbxLJsNeG4bdzMNy52B7q7C8FVjebNJqckzRDmKf71higteZmK0pYqXGxKrD+JzDeL6q68MxcZ+0sL4PRf8J7hLh9sYGii2K8UMYJX4lwrXl2XtfarOReYFe6vmormSprgj6U89vuMYFmT9ZSvN9XbIr1WFMBY9QIULB9VH0QvxEFMP2gmSp1QH7nvafVOkpE53nighW+AStigmqKSJ0GPdfZyepoRmPHpw5Mwzcak/EkxWabdzqEMptH5Zr4cZ6CRXq4Otp+mj0ixCH1TCfEuRzo7OQ1ktVxq2GlvNfqDmqMt6Wk77IGBNAuTOPckCw3Qh2K0DBH+2L9TMdw9lvKXlwLMIRLfrklE6vFHGs97nGxGhdEYGjiKihGtRQs/OA7UWw3BB3iGB5dtz5zfQ2mNJCAI5kKjiRJZwQlJC51PEzc2g6ldomc0fh9pqYJIfxsKaIaJCw4BZjEum9HuHRdxNS15NwGC++GiDsrWy5EYqtEHbzQH/lu3QcY9/1V/5Urqzmjv+9snagLoWRK2tyZWMeKHpGLIolRWkTyp02brol3PyrjDsU4OJvXVEOqeFkilNLzwULjJerab3UUHPtWJS03naN8/RczRnApaVdmAoe9m0jhZGW+XGLbZTL9PFJlRaZ6DzbYptYEMb99ew5eqkZD38/PbarO/uN13theY8Hje13jf1LbOyZe2f1mcj8iv7QzaieyZLE8qaxa4p4vDiW2Tv49G6v7oTdzMH27sP2lmNY3kzSbmoo0HZKpbYvMqHVGJ9xmFiOofD7TiabW9C0nb13/q7jkECZRnB1bWSgtpnLCzM3Pj7ijI+PyBz/OA4fOl9xbfB89Ug+fL7ejn9/YP/7eAMLS3CiKim0CAAAAABJRU5ErkJggg==",
      asSource: true,
      asTarget: true,
      uploadPath: "/torrents/create?category_id=1",
      torrentDownloadLinkSelector: 'a[href*="/torrents/download/"]',
      needDoubanInfo: true,
      seedDomSelector: ".torrent__buttons+.panelV2",
      search: {
        path: "/torrents",
        replaceKey: [
          "tt",
          ""
        ],
        params: {
          name: "{name}",
          imdbId: "{imdb}",
          sortField: "size"
        }
      },
      name: {
        selector: 'input[name="name"][class="form__text"]'
      },
      description: {
        selector: "#bbcode-description"
      },
      imdb: {
        selector: "#autoimdb"
      },
      tmdb: {
        selector: "#autotmdb"
      },
      mediaInfo: {
        selector: 'textarea[name="mediainfo"]'
      },
      anonymous: {
        selector: '.form__group input[type="checkbox"][name="anon"]'
      },
      torrent: {
        selector: 'input[type="file"][accept=".torrent"]'
      },
      category: {
        selector: "#browsecat",
        map: {
          movie: "1",
          tv: "2",
          tvPack: "2"
        }
      },
      videoType: {
        selector: "#autotype",
        map: {
          uhdbluray: "1",
          bluray: "1",
          remux: "3",
          encode: "12",
          web: "4",
          hdtv: "6",
          dvd: "1",
          dvdrip: "12",
          other: ""
        }
      },
      resolution: {
        selector: "#autores",
        map: {
          "4320p": "11",
          "2160p": "1",
          "1080p": "2",
          "1080i": "3",
          "720p": "5",
          "576p": "6",
          "480p": "8"
        }
      }
    },
    KEEPFRDS: {
      url: "https://pt.keepfrds.com",
      host: "keepfrds.com",
      siteType: "NexusPHP",
      icon: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAMAAAC6V+0/AAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAACDVBMVEX////8/Pz19fXs7Oz09PT+/v7p6enQ0NC7u7uwsLCvr6+6urrOzs7n5+f7+/v6+vri4uKrq6uBgYFzc3N5eXl6enp0dHR/f3+np6be3t75+fjj4+OSkpJ8fHyhoaHh4eHT09OlpaV+fn2Li4ve3t3s8PXu8vfh5uu6vsKLjY+3uLjl5eX5+fm8vLyLjY6zt7vf4+isvtSOp8WCnsB+mbl6kKyutb3c3d7v7u7m5ubY2NjY2NfP0NGqsrt1jKd8lreCnr+OqMWcss1chLAvZZ4uZp9ahbPS3ejOzs+3trbLy8ugoKCioqHBwsPK1eJXg7EtZZ8uZJ5bhLCds83t8faoxt9Yl8g/icJ2qtLh6vGwr697e3uNjY3FxcWRkZGenp3MzMvf6fFyqNE8h8FXlseoxd78/f7f7PWPweJWpdZ7uuDh7fWzs7OampqoqKipqamXl5enp6fk8fh4uN9Uo9X6/P3Q6PaQzex3xenX7ffP0dLR0NDW1ta5ubna2trx8fH1+PnY8Pp0xOqOzOz1/P/L5vKUwtaxwMfa3N329fX39/f4+Pjq7e6xwsmOvtLJ5fD2/P/x8/PDyMuMjpC0tLX29va2t7eKjo67wcPu8PH9/P3m5eWXlpabm5vKysrd3d3MzMyQkI/h4OCxsbGGhoZ4eHiEhISurq79/f3U1NTAwMC1tbW/v7/q6urw8PAgqDn/AAAAAWJLR0QAiAUdSAAAAAd0SU1FB+UECgYrK84hHq4AAAEbSURBVBjTY2AgFTAyMTOzMCKLsDKysXNwcnHz8PKxwgX5BQSFhEVExcQlJKXAoqysDIzSMrJy7PICCopKyir8IBFVVTV1DU0tbR1WVj42XT19AzVVVQZDI2MTUzNzC2ZLeStrG1s7ewdHQwYnZxdXN3cPTw4vbm8fXz//gMCgYIaQ0LDwiMio6JhYwbj4hMSk5JTUEIa09IzMrOyc3Lz8gsJY7aLikoz0NAbW0rLyisqq6hqO2rr6hsam5rJSkKtaWtvaOzq7tHm7GXp6+/onQNw+cdLkKfJTWVm7pKdNnzET6qFZs+dEz503f/4Cb9mFi/jg3tRevERs6VKxZcsFdOCeZ13BvHLV6tVrFNYysqIEVHf9uu4VJIc4AFHVRtljPRexAAAAJXRFWHRkYXRlOmNyZWF0ZQAyMDIxLTA0LTEwVDA2OjQzOjQzKzAwOjAwO9PHqAAAACV0RVh0ZGF0ZTptb2RpZnkAMjAyMS0wNC0xMFQwNjo0Mzo0MyswMDowMEqOfxQAAAAASUVORK5CYII=",
      asSource: true,
      asTarget: true,
      seedDomSelector: "#top~table:first>tbody>tr:nth-child(3)",
      torrentDownloadLinkSelector: 'a[href*="download.php?id="]',
      uploadPath: "/upload.php",
      needDoubanInfo: true,
      search: {
        path: "/torrents.php",
        imdbOptionKey: "4",
        nameOptionKey: "0",
        params: {
          incldead: "0",
          search_area: "{optionKey}",
          search: "{imdb}",
          sort: "5",
          type: "desc"
        }
      },
      name: {
        selector: 'input[name="small_descr"]'
      },
      subtitle: {
        selector: "#name"
      },
      description: {
        selector: "#descr"
      },
      imdb: {
        selector: 'input[name="url"][type="text"]'
      },
      douban: {
        selector: 'input[name="douban_url"]'
      },
      anonymous: {
        selector: 'input[name="uplver"]'
      },
      torrent: {
        selector: 'input[name="file"]'
      },
      category: {
        selector: "#browsecat",
        map: {
          movie: "401",
          tv: "402",
          tvPack: "402",
          documentary: "404",
          concert: "408",
          sport: "407",
          cartoon: "405",
          variety: "403"
        }
      },
      source: {
        selector: 'select[name="source_sel"]',
        map: {
          uhdbluray: "10",
          bluray: "1",
          hdtv: "4",
          dvd: "3",
          web: "7",
          vhs: "8",
          hddvd: "8"
        }
      },
      videoCodec: {
        selector: 'select[name="codec_sel"]',
        map: {
          h264: "3",
          hevc: "0",
          x264: "3",
          x265: "0",
          h265: "0",
          mpeg2: "17",
          mpeg4: "1",
          vc1: "16",
          xvid: "5"
        }
      },
      resolution: {
        selector: 'select[name="standard_sel"]',
        map: {
          "4320p": "0",
          "2160p": "7",
          "1080p": "1",
          "1080i": "2",
          "720p": "3",
          "576p": "5",
          "480p": "5"
        }
      }
    },
    KG: {
      url: "https://karagarga.in",
      host: "karagarga.in",
      siteType: "KG",
      icon: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAMAAAC6V+0/AAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAC0FBMVEUAAADMzMyDgIDBxMSAgIB6gID/4uIAgICAhYXNzc2IiIiXl5eDg4O/v7/BwcHAwMCFhYXGxsbS0tK5ubl7e3tzc3P////Ly8vMzMzMzMzMzMzMzMxvamqlpKSmpqZaWlqChYXP0tJ/gICChYVISUkTExMFBQWJh4fJycmDhYV+hYU9iIhXWloAhIQAgIDNzc3Q0NCsrKxVV1cdDg56OTk4OTkODQ1bAAA9REQAhYWSkpJfX18QEBB4eHiLi4uVlJSZmpqNjY15eXkODg5hYWEgICCIQEC9u7vBxMQ/Pz+CgoJGRkYVeXmuuLjq1NQAAAAZGRljXl5iqKi+v7/BwMBWVlaNjY2IiIiIiIhoaGihoaGMjIycoKCwsLDJw8PAwMC/v7/AwMDAwMCWlpaLi4uDg4PGxsbHx8fDw8PIyMiwsLDAwMDAwMDAwMDAwMC/v7+8vLzAwMDAwMC8vLy4uLi3t7eQkJCenp7BwcHAwMDAwMDAwMDBwcHBwcHPz8+NjY2Hh4eEhISnp6fBwcHAwMDAwMB7e3t7e3t7e3uqqqqHh4dhYWH8/Pyjo6N5eXmAgIB/f3+AgICbm5uKiorCwsLDw8OMjIy9vb3///////+JiYl/f39/f3+AgICwsLCioqK6urq/v7+amprw8PDMzMy/v7/AwMDExMR5eXmAgIDKysp/f3+AgICvr6+hoaG/v7++vr7BwcHAwMDExMR5eXmAgICpqakUFBQRQkIAAAABAABrJiYoQUEAHR0SERGKiopaW1sMBgZOHh4aCwsMAABKLS1OTk45OTlTUVEBDg4BYGAIISE9AAAJCQkDAwMODg4FBQUHBwcLCwsBAwMCDg5TAwNCOTk+Pj5bW1tZWVleXl4rKysWFxdYV1dcWVl3WFg7Ozs8PDxzc3PFxcW2trbAwMC4uLiHh4eIiIiMjIyPj4+zs7OdnZ2/v78GBgb///+lKbQMAAAAtnRSTlMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAkTUEIDo3hNxoOBqD3++TnchSh7eSBAgFag32O8PCOfIhfJExJTMrhHQ6N+/v++sYaBp33vCADtuicX5oUv3t/dbruiNi6nO+WikT90FgtpehaxPfEwV7dRgKc9f786eDlxx0BHQkRkfleFR4aAwJ63elXD39/g4iIidzagX9/g1oB3Le5ubO3F6TuswxDUSMVTIEDAwMEBrawIHRE97mnD1YAAAABYktHRBZ80agZAAAAB3RJTUUH5QQMAwUgcVRTPQAAAThJREFUGNNjYKAaYJSQlJJmRBFiYpKR3SYnr6DIjBBjYVVSVtmuqqauwcYOF+TQ1NLesXPnrt06unpgAU59A0MjY5M9e/eZmplbWAIFuaysbWzt9h84eOjwkaP2DtwgVTyOTsecXVyPnzh56vQZN3cPXpCgp5f32XPnL1y8dPnK1Ws+vn58IEH/gOs3bty8dfvO3Xv3A4OCQ/hBgg8ehoaFh0dEPoqKjomNi09ITAIKJ6ekCggKpqU/zsjMevI0Oyc3DyiYXyDEwl9YVPyspLSsvKKyir8aKFhTy8cgLFxX//xFQ2NTc0srP8w3Im3tHS87u7pFYQI9vX39EyZOejV5ytRp02fMFAMLvn4za/acufPmty9YuOjt4iVLly1fsZLh3fNVYqvXrF3XJr5+w9uNm/Kfbt6yFQBipHYOvCm+yAAAACV0RVh0ZGF0ZTpjcmVhdGUAMjAyMS0wNC0xMlQwMzowNToyOCswMDowMNjzD2AAAAAldEVYdGRhdGU6bW9kaWZ5ADIwMjEtMDQtMTJUMDM6MDU6MjgrMDA6MDCprrfcAAAAAElFTkSuQmCC",
      asSource: true,
      asTarget: true,
      uploadPath: "/upload.php",
      seedDomSelector: ".outer h1~table:first>tbody>tr:nth-child(6)",
      torrentDownloadLinkSelector: 'a[href*="/down.php/"]',
      needDoubanInfo: true,
      search: {
        path: "/browse.php",
        imdbOptionKey: "imdb",
        nameOptionKey: "title",
        params: {
          search: "{imdb}",
          search_type: "{optionKey}",
          sort: "size",
          d: "DESC"
        }
      },
      source: {
        selector: "select[name='source']",
        map: {
          uhdbluray: "Blu-ray",
          bluray: "Blu-ray",
          hdtv: "TV",
          dvd: "DVD",
          web: "WEB",
          vhs: "VHS",
          hddvd: "HD-DVD",
          other: "Other"
        }
      },
      resolution: {
        selector: "select[name='hdrip']",
        map: {
          "720p": "1",
          "1080p": "2",
          bluray: "3"
        }
      },
      torrent: {
        selector: 'input[name="file"]'
      },
      genres: {
        map: {
          Action: "4",
          Adventure: "55",
          Animation: "5",
          Arthouse: "6",
          Camp: "43",
          Classics: "8",
          Comedy: "9",
          Crime: "10",
          Cult: "11",
          Documentary: "20",
          Drama: "12",
          Epic: "44",
          Erotica: "13",
          Experimental: "51",
          Exploitation: "47",
          Fantasy: "14",
          "Film Noir": "15",
          Giallo: "53",
          Horror: "17",
          "Martial Arts": "18",
          Musical: "19",
          Mystery: "54",
          Performance: "60",
          Philosophy: "48",
          Politics: "49",
          Romance: "50",
          "Sci-Fi": "21",
          Short: "22",
          Silent: "23",
          Thriller: "24",
          TV: "25",
          "Video Art": "56",
          War: "26",
          Western: "27"
        }
      },
      country: {
        map: {
          USA: "2",
          UK: "12",
          Germany: "7",
          Italy: "9",
          "---": "255",
          Abkhazia: "119",
          Afghanistan: "54",
          "Akrotiri and Dhekelia": "120",
          "Aland Islands": "121",
          Albania: "65",
          Algeria: "35",
          "American Samoa": "122",
          Andorra: "68",
          Angola: "36",
          Anguilla: "123",
          "Antigua Barbuda": "89",
          Argentina: "19",
          Armenia: "124",
          Aruba: "125",
          "Ascension Island": "126",
          Australia: "20",
          Austria: "37",
          Azerbaijan: "118",
          Bahamas: "82",
          Bahrain: "127",
          Bangladesh: "86",
          Barbados: "85",
          Belarus: "129",
          Belgium: "16",
          Belize: "34",
          Benin: "116",
          Bermuda: "130",
          Bhutan: "131",
          Bolivia: "132",
          "Bosnia Herzegovina": "67",
          Botswana: "133",
          Brazil: "18",
          "British Virgin Islands": "134",
          Brunei: "135",
          Bulgaria: "104",
          "Burkina Faso": "60",
          Burundi: "136",
          Cambodia: "84",
          Cameroon: "137",
          Canada: "5",
          "Cape Verde": "138",
          "Cayman Islands": "139",
          "Central African Republic": "140",
          Chad: "114",
          Chile: "51",
          China: "8",
          "Christmas Island": "141",
          "Cocos (Keeling) Islands": "142",
          Colombia: "99",
          Comoros: "143",
          "Congo (Brazzaville)": "53",
          "Congo-Kinshasa (Zaire)": "252",
          "Cook Islands": "144",
          "Costa Rica": "102",
          "Cote d'Ivoire": "145",
          Croatia: "97",
          Cuba: "52",
          Cyprus: "146",
          "Czech Republic": "46",
          Denmark: "10",
          Djibouti: "147",
          Dominica: "148",
          "Dominican Republic": "41",
          Ecuador: "81",
          Egypt: "103",
          "El Salvador": "149",
          "Equatorial Guinea": "150",
          Eritrea: "151",
          Estonia: "98",
          Ethiopia: "112",
          "European Union": "253",
          "Falkland Islands": "153",
          "Faroe Islands": "111",
          Fiji: "152",
          Finland: "4",
          France: "6",
          "French Polynesia": "154",
          Gabon: "155",
          Gambia: "156",
          Georgia: "108",
          Ghana: "157",
          Gibraltar: "158",
          Greece: "42",
          Greenland: "159",
          Grenada: "160",
          Guam: "161",
          Guatemala: "43",
          Guernsey: "162",
          Guinea: "113",
          "Guinea-Bissau": "163",
          Guyana: "164",
          Haiti: "165",
          Honduras: "79",
          "Hong Kong": "33",
          Hungary: "74",
          Iceland: "62",
          India: "70",
          Indonesia: "166",
          Iran: "107",
          Iraq: "167",
          Ireland: "13",
          "Isla de Muerte": "105",
          "Isle of Man": "168",
          Israel: "44",
          Jamaica: "31",
          Japan: "17",
          Jersey: "170",
          Jordan: "169",
          Kazakhstan: "110",
          Kenya: "172",
          Kiribati: "58",
          Kosovo: "173",
          Kuwait: "171",
          Kyrgyzstan: "80",
          Laos: "87",
          Latvia: "101",
          Lebanon: "100",
          Lesotho: "174",
          Liberia: "175",
          Libya: "176",
          Liechtenstein: "177",
          Lithuania: "69",
          Luxembourg: "32",
          Macau: "178",
          Macedonia: "179",
          Madagascar: "180",
          Malawi: "181",
          Malaysia: "40",
          Maldives: "182",
          Mali: "115",
          Malta: "183",
          "Marshall Islands": "184",
          Mauritania: "185",
          Mauritius: "186",
          Mayotte: "187",
          Mexico: "25",
          Micronesia: "188",
          Moldova: "189",
          Monaco: "190",
          Mongolia: "109",
          Montenegro: "257",
          Montserrat: "191",
          Morocco: "192",
          Mozambique: "193",
          Myanmar: "194",
          "Nagorno-Karabakh": "195",
          Namibia: "196",
          Nauru: "63",
          Nepal: "197",
          Netherlands: "15",
          "Netherlands Antilles": "71",
          "New Caledonia": "198",
          "New Zealand": "21",
          Nicaragua: "199",
          Niger: "200",
          Nigeria: "61",
          Niue: "201",
          "Norfolk Island": "202",
          "North Korea": "96",
          "Northern Cyprus": "203",
          "Northern Mariana Islands": "204",
          Norway: "11",
          Oman: "205",
          Pakistan: "45",
          Palau: "207",
          Palestine: "208",
          Panama: "206",
          "Papua New Guinea": "209",
          Paraguay: "90",
          Peru: "83",
          Philippines: "59",
          "Pitcairn Islands": "210",
          Poland: "14",
          Portugal: "24",
          "Puerto Rico": "50",
          Qatar: "211",
          Romania: "75",
          Russia: "3",
          Rwanda: "212",
          "Saint Helena": "213",
          "Saint Kitts and Nevis": "214",
          "Saint Lucia": "215",
          "Saint Vincent and the Grenadines": "217",
          "Saint-Pierre and Miquelon": "216",
          Samoa: "39",
          "San Marino": "219",
          "São Tomé and Príncipe": "220",
          "Saudi Arabia": "221",
          Sealand: "258",
          Senegal: "94",
          Serbia: "256",
          "Serbia and Montenegro": "47",
          Seychelles: "48",
          "Sierra Leone": "222",
          Singapore: "26",
          Slovakia: "223",
          Slovenia: "64",
          "Solomon Islands": "224",
          Somalia: "225",
          Somaliland: "226",
          "South Africa": "29",
          "South Korea": "30",
          "South Ossetia": "227",
          Spain: "23",
          "Sri Lanka": "228",
          Sudan: "229",
          Suriname: "230",
          Svalbard: "231",
          Swaziland: "232",
          Sweden: "1",
          Switzerland: "57",
          Syria: "233",
          Taiwan: "49",
          Tajikistan: "234",
          Tanzania: "235",
          Thailand: "93",
          "Timor-Leste": "236",
          Togo: "95",
          Tokelau: "237",
          Tonga: "238",
          Transnistria: "239",
          "Trinidad & Tobago": "78",
          "Tristan da Cunha": "240",
          Tunisia: "106",
          Turkey: "55",
          Turkmenistan: "66",
          "Turks and Caicos Islands": "241",
          Tuvalu: "242",
          Uganda: "243",
          Ukraine: "72",
          "United Arab Emirates": "244",
          "United Kingdom": "12",
          Uruguay: "88",
          USSR: "92",
          Uzbekistan: "56",
          Vanuatu: "76",
          "Various/International": "117",
          "Vatican City": "245",
          Venezuela: "73",
          Vietnam: "77",
          "Virgin Islands": "246",
          "Wallis and Futuna": "247",
          "Western Sahara": "248",
          World: "254",
          Yemen: "249",
          Yugoslavia: "38",
          Zambia: "250",
          Zimbabwe: "251"
        }
      }
    },
    KamePT: {
      url: "https://kamept.com",
      host: "kamept.com",
      siteType: "NexusPHP",
      icon: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAYAAACNiR0NAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAABmJLR0QA/wD/AP+gvaeTAAAAB3RJTUUH5woaCDQq3ANFWQAAA51JREFUOMuFlFtT21YUhb+jI8m2ZMtXCgYMLiEpoXGmTXpvc5k8NP83nabT5z4ktNOZUEiDSyBASInxVb7JliWdPNDSIZB0v+9v1t577SWivlK8XUpRPzyg9uI5Uig+WFomlZ9GN02klFzQcVr6eZZi5+kfvNx6RKcxwNQNOo1jMsVl9HicfHGGzFQBKbULwWeAQkDP7fLjTw/x/SZSxEnG4kR+Ej3hYcZD3GaVZKHG4uVLWLZ1DnpO4cT3Oaw1qfVa5BybsqPRFQFmzyNvJkBoHB3UGY0Drt2ooOtnEdrbwFCBFXPA9RnXBZlElkuX85ixGENvwsALaHZ6bG5s0TiuI8T7FAqo1RpY2XlyKRepBDNzWeyE5OVhC8OwAPizusloErBS+YjiXPE9QAXttotumkwtzJMQJo2+wAs8XNfDtgTSEMzNZ9l+XsN1+yilTpS8a4cIDeH1ycmQccKmulcnbQrSlk2gedjJGKufXKPV9pBSQwhx5jDnRrbtOLbmE26/gDmDhZkUmcIUBccilYpz3Gyy93QbiwAnlfz/KxuGTmQlCRbLeJFkdSrNF5VZYjN5QqGRPMjw994OKqojwiFHe7tMlxbRpHwHUNdpDSJc36TvNikcBdy8WsDrJxhhUixPUyjlufLlDbKFHLXdA8beECuVQqkLbGMYOmEUYoo4s9oS3X3JDw/XqVYPSU3PEs9m0E2TmdIcSkU4hTwT33+3D3VdR0UKW4ZUygtUVu5QKi/TbtVoN+pomkQJSafRIAxCpCkZDvqoSF0AVBCGIaFSGGmL8m2HlfsWXb3O2q/rvKjuYpgG6XwGIQTyny8JggkKdXaHvu/zfOsvnlV38YOQtjtg7fctLKPHk18eIzqKaDSh+bpJMpPEyeUYj8YM3QEpJ40QJ9pE1FdKCFhff8aDBz/THY4ZKYO+e4QxbjFvm7ivenx37ytu3LnJwFdsbO7Q6nQYtlxu3bvDZ7e+PQWeKozCkFFkoAwd1WuTtyM+vVLi69UVJk6OYqlITAo6geLRbxvs7B4wl7X45u5tlOL0p0+BuqFj2xbK87GcJJmEQyqboa9Myh+WaB++RkQhZNLksmnE1Y/RpES3nTPZKP5N7PF4zP7+Kx6vrbO1vcfn15e5VlklHHuISZdISyAIkVpEqxeyt/+KTm/I9/fvsrS0cB4oxElabzzZpNXuUrm+QiabJYoiAt9H03WUikApNKnjeUMEYCdTaNp/ZnkDkeWj+pSQ1t4AAAAldEVYdGRhdGU6Y3JlYXRlADIwMjMtMTAtMjZUMDg6NTI6NDIrMDA6MDDrWrkWAAAAJXRFWHRkYXRlOm1vZGlmeQAyMDIzLTEwLTI2VDA4OjUyOjQyKzAwOjAwmgcBqgAAACh0RVh0ZGF0ZTp0aW1lc3RhbXAAMjAyMy0xMC0yNlQwODo1Mjo0MiswMDowMM0SIHUAAAAASUVORK5CYII=",
      asSource: true,
      asTarget: true,
      seedDomSelector: "#top~table>tbody>tr:nth-child(4)",
      torrentDownloadLinkSelector: 'a[href*="download.php?id="]',
      uploadPath: "/upload.php",
      search: {
        path: "/torrents.php",
        imdbOptionKey: "4",
        nameOptionKey: "0",
        params: {
          incldead: "0",
          search_area: "{optionKey}",
          search: "{imdb}",
          sort: "5",
          type: "desc"
        },
        result: {
          list: ".torrents>tbody>tr",
          url: '.torrentname td a[href*="details.php?id="]',
          name: '.torrentname td a[href*="details.php?id="]',
          size: "td:nth-child(5)"
        }
      },
      name: {
        selector: "#name"
      },
      subtitle: {
        selector: 'input[name="small_descr"]'
      },
      description: {
        selector: "#descr"
      },
      anonymous: {
        selector: 'input[name="uplver"]'
      },
      torrent: {
        selector: 'input[name="file"]'
      }
    },
    LST: {
      url: "https://lst.gg",
      host: "lst.gg",
      siteType: "UNIT3D",
      icon: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAABXFBMVEUAAAAAAAEAAQABAAABAQAAAAAAAAEBAAEAAAAAAQAAAQABAAAAAAEAAAAAAQAAAAABAAAAAAAAAAABAQALCgoKCgoBAADQ0dC2treTkpMoKSmBgICAgIABAACTk5MAAACTkpIBAQEAAAEBAQEAAAEAAQABAAAAAQABAAABAAEAAQABAAAAAAEBAAEBAAEBAAAAAAABAQEAAQAAAAEBAQAEBAQhICAREREAAQH8/PwoKCk+Pz/q6ur//v/9/P13d3d2dnbz8vLz8/Pz8/I3NzexsbH+//5gYWBVVVVISEgyMjJoaGny8/Pg4OBoaWn///5/fn7////p6eiQkZEUFBTp6enJyMg3NjdQUVCys7L8/fzGx8bJyciEhYRgYGE0NDVra2ppaGlHR0bo6Ojs7e37+vr9/Pz9/f2NjY14eXn8/P309PRnZmfV1dXIycgNDQ0gICEHBwcDAgMCAgOj429fAAAALnRSTlMAAAAAADCX2fn52ZcJmv7+CQnCmjD+MJiX2dn5+fnZ2ZeXMP6aCcKa/pqX2fmXK9ig8QAAAAFiS0dEUZRpfCoAAAAHdElNRQfnChsDMwGLF6JaAAAA90lEQVQY0xWOZ1PDMBiD3yQEWiBNE/YsZc9Y2AbMCIXSsqEUCLPsvdf/v8PRJ+k53UlEZJBdXZNI1tbZJsUy6p1UwIBJuE46Bp7POVjAIQDf06AhCCAk4syZY1Bjk7ZianoGUgmZaqaW2Tnw+YVwMbe0nF/Jt1JbWBCiuLq2vrG5tb2z204dpYJke+X9g0MgOmJJ6iwdM6ZOTs/OJaIK66Lu8sXl1fXN7d09gqjCM9Tz8Pj0/PIavr1DfXwiS72unhdf3z+A/P3rs/UxgIGr+Bh4v0XWgK+gNIrxYLqKTMsbciG4ZGp4xCPdIDLt0bHEeGbCtkwy/wE9US4qeYwieAAAACV0RVh0ZGF0ZTpjcmVhdGUAMjAyMy0xMC0yN1QwMzo1MTowMSswMDowMPxuOEAAAAAldEVYdGRhdGU6bW9kaWZ5ADIwMjMtMTAtMjdUMDM6NTE6MDErMDA6MDCNM4D8AAAAKHRFWHRkYXRlOnRpbWVzdGFtcAAyMDIzLTEwLTI3VDAzOjUxOjAxKzAwOjAw2iahIwAAAABJRU5ErkJggg==",
      asSource: true,
      asTarget: true,
      uploadPath: "/torrents/create?category_id=1",
      needDoubanInfo: true,
      seedDomSelector: "#meta-info+.meta-general>.panel:first",
      torrentDownloadLinkSelector: 'a[href*="/download/torrent/"]',
      search: {
        path: "/torrents",
        replaceKey: [
          "tt",
          ""
        ],
        params: {
          name: "{name}",
          imdbId: "{imdb}",
          sortField: "size"
        }
      },
      name: {
        selector: "#title"
      },
      description: {
        selector: "#bbcode-description"
      },
      imdb: {
        selector: "#autoimdb"
      },
      tmdb: {
        selector: "#autotmdb"
      },
      mal: {
        selector: "#automal"
      },
      mediaInfo: {
        selector: 'textarea[name="mediainfo"]'
      },
      anonymous: {
        selector: '.form__group input[type="checkbox"][name="anonymous"]'
      },
      torrent: {
        selector: 'input[name="file"]'
      },
      category: {
        selector: "#browsecat",
        map: {
          movie: "1",
          tv: "2",
          tvPack: "2"
        }
      },
      videoType: {
        selector: "#autotype",
        map: {
          uhdbluray: "1",
          bluray: "1",
          remux: "2",
          encode: "3",
          web: "4",
          hdtv: "6",
          dvd: "1",
          dvdrip: "3",
          other: "7"
        }
      },
      resolution: {
        selector: "#autores",
        map: {
          "4320p": "1",
          "2160p": "2",
          "1080p": "3",
          "1080i": "4",
          "720p": "5",
          "576p": "6",
          "480p": "8"
        }
      }
    },
    Lemon: {
      url: "https://lemonhd.club",
      host: "lemonhd.club",
      siteType: "NexusPHP",
      icon: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAYAAACNiR0NAAAACXBIWXMAAAPoAAAD6AG1e1JrAAADkUlEQVR4nI2Uf0zUdRjHnzt+CExYwQwbDLChy3TLcrVJqMtNaNRaWWBzZbMhPyLQNoKMk6PmbGVYzIYYakq1OcosS+qPmq11gKKAguF5Id1xAgGCVhr6/X4/r3Z3IMc8imf77vnj+Xxfn/fzfd7PV+R/gvrMIMAUsIanJgFr08K8WcRM16MpnFuayZnkZ3E8ns4vMZE+qNU8I6jnoDefT8+i9/UO+jYprlfD2EHFYBG4S/uUY00ZVgn2dPCf0Fuw7vVvcX0nuLIULYkGjnwN13aN5rsNHGkG/5SDs/AYlRLuey8AdKJNZU/dyNguGP1Goz1Vwxav+K0EXDugeQE0JRn0770BDdCd9rG/ED9lvhv4XqIZtPTiWA2tqQajP8PpZWDPA+e70BgPg4fBWanU6WSd0QqwL1weoNXxITjTsxgpRZ1M1GlKhrMZMPAZ9FRAz5vQ+z5ctEDTPajGOJ2hbHC/tCfQtwv2ZK0np4qrZdC+QqNjDbStAns+/P0rXLvgU9m2EjqeRrWv0hnIhksFP94GrGp4bJYX7MrfCT/B0Fcaw8dg6GsY+hL0v0AZcPk7X8vDDajBIzqGDVxFU4GZmeJtV0TCWhozDjG8CaN5ns7JxXDiPujbD/0HYPALH+zUQ3BiIao5Wcf1JDg3+gGt4p1OyFrJkXVyednWCOivUMap+dDyIAwfha4NcD4beqzQuRaGv4XW5dAUq3G1FNxZFh9rHJZUFmFZuXsOD1fGGHOLzZxtfQ7chejuKnAUg20udL8GrkqwxcKFQuj/xMDxFAxs/pPGqORJhRtkffirQSx9504ta3+8nvJBLI98ZGJ0YAf0vc1NWyR6Y6LCXqT4fbuiaZ6BLUqjd6vBjUPQlpAz6eEX5Q7JFWdMcSiLtkVpK96bo4JKBKkR0urDudaTDQNWxbkUhXsL/LELupYoRgqhN8/gzP0FU02dK0mmXLliKhASyiNUdEmoHlcTrtKPxvJAfQwL6kJU+Q+LDLt9nYb7jREuWa4o18suLj6/j875S/y3azJyJEHy5JmgFyRDtogldJ+ZuIPhavWRu7RZtWZNDgiRNbIZq5g7ayWa4xLmt13m2/w3PmmvqaVW8kM/NRNXF3bz3sORzK4LxlQt2wJt1fQwxCSF4jW17JZXgj83EVJrGpNqOS57JHXCDZ5dn3gCg6aG79CHMluq5YmQall8q1LvNf3M/8zThkeJDzbj+Bc9TIk5RyzZEgAAAABJRU5ErkJggg==",
      asSource: true,
      asTarget: true,
      uploadPath: "/upload.php",
      seedDomSelector: "#top~table:first>tbody>tr:nth-child(5)",
      torrentDownloadLinkSelector: 'a[href*="download.php?id="]',
      search: {
        path: "/torrents.php",
        imdbOptionKey: "4",
        nameOptionKey: "0",
        params: {
          incldead: "0",
          search_area: "{optionKey}",
          search: "{imdb}",
          sort: "5",
          type: "desc"
        },
        result: {
          list: "#torrenttable>tbody>tr",
          url: '.torrentname td a[href*="details.php?id="]',
          name: '.torrentname td a[href*="details.php?id="]',
          size: "td:nth-child(5)"
        }
      },
      name: {
        selector: 'input[name="name"]'
      },
      subtitle: {
        selector: 'input[name="small_descr"]'
      },
      description: {
        selector: 'textarea[name="descr"]'
      },
      imdb: {
        selector: 'input[name="imdb"]'
      },
      douban: {
        selector: 'input[name="douban"]'
      },
      anonymous: {
        selector: 'input[name="uplver"]'
      },
      torrent: {
        selector: 'input[name="file"]'
      },
      mediainfo: {
        selector: 'textarea[name="mediainfo"]'
      },
      category: {
        selector: 'select[name="type"]',
        map: {
          movie: "401",
          tv: "402",
          tvPack: "402",
          documentary: "404",
          concert: "406",
          sport: "407",
          cartoon: "405",
          variety: "403",
          music: "411"
        }
      },
      videoCodec: {
        selector: 'select[name="codec_sel"]',
        map: {
          h264: "1",
          x264: "1",
          hevc: "3",
          x265: "3",
          h265: "3",
          mpeg2: "4",
          mpeg4: "1",
          vc1: "2",
          xvid: "100",
          dvd: "4"
        }
      },
      audioCodec: {
        selector: 'select[name="audiocodec_sel"]',
        map: {
          aac: "8",
          ac3: "6",
          dd: "6",
          "dd+": "7",
          flac: "10",
          dts: "5",
          truehd: "2",
          lpcm: "9",
          dtshdma: "3",
          atmos: "1",
          dtsx: "4",
          ape: "12",
          wav: "11",
          mp3: "100",
          m4a: "100",
          other: "100"
        }
      },
      videoType: {
        selector: 'select[name="medium_sel"]',
        map: {
          uhdbluray: "3",
          bluray: "1",
          remux: "12",
          encode: "13",
          web: "10",
          hdtv: "11",
          dvd: "2",
          dvdrip: "13",
          other: '5"'
        }
      },
      resolution: {
        selector: 'select[name="standard_sel"]',
        map: {
          "4320p": "6",
          "2160p": "5",
          "1080p": "1",
          "1080i": "2",
          "720p": "3",
          "576p": "100",
          "480p": "4"
        }
      },
      area: {
        selector: 'select[name="team_sel"]',
        map: {
          CN: "3",
          US: "1",
          EU: "1",
          HK: "2",
          TW: "2",
          JP: "4",
          KR: "4",
          IN: "5",
          OT: "10"
        }
      },
      tags: {
        chinese_audio: 'input[name="tag_gy"]',
        diy: 'input[name="tag_diy"]',
        cantonese_audio: 'input[name="tag_yy"]',
        chinese_subtitle: 'input[name="tag_zz"]',
        hdr: 'input[name="tag_hdr"]',
        dolby_vision: 'input[name="tag_dv"]'
      }
    },
    MDU: {
      url: "https://monikadesign.uk",
      host: "monikadesign.uk",
      siteType: "UNIT3D-Legacy",
      icon: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAYAAACNiR0NAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAABmJLR0QA/wD/AP+gvaeTAAAAB3RJTUUH5woaCDIPwV02mAAABU1JREFUOMtt1GtoW2Ucx/Hf8zznnDQnJycnl6ZJ27Tp1q1pu/uYl21O1M0Lc47hi050IoqCgoL6SnzhCxVviIKIU/ECU7Ra3ECHoqKi3VS2eSmua7t2abusNmuTNE3OOTnXxxcDL+D//f/z7vcl+J/bvWY9jlbm8Ug8g13ZLG685iqgL4vCsR/x7WwBXxXmkAhIaLRm8dqbB//zSwDgtrZeMB/ILFgwKEchLuCVUAJPKm77xkRyRzqh9YtBSbAFMlNsmMP3Hvrgj4MP3ee/Mfgl1uaySF25Dc89+zQAQAAAn1EQisBykO52uG+a4L+8zeu7r7dDj67q6cwlVqUpaxLhAzBcd/7Yxic+/mFs+uBocfqMnIrwhYlxDAwMYHBw8BIoMAZfZEJy0bufWe6OFseb6K7XV2QEW44kwwg2h+G7PgihaGIspRI8yJiw58GBfS9+NzZ1GJHoHIxlDgAUAN7Lj2D7RE1vBNkXGiNSp+2uUWuWbEVksGQUluXBc314TABTFdBwCL19K7I37Np6i+pytv3UT5wIIv4G7+i7HE/dvonKlrMmRhwk13UCqgz55q0Q00k0dAs2J3AEBiEWgUcZXN1ELhm/7s5d2wce+30E+eJ5HBn8DGT//v2wz0zBpjS5pWi8lYuHb+7ZuQXW5Aw6912NBhPAKAcHAaEEWjiEqm7COjcHNZPAdNWYOTaav0mVg2eGRsfBvMoSPEIwa+nZ3rbmWN/Kzh3N3WkSbE9ATUZRMm3Mc4apqg4lFYfS0QYe07BYWoYEHz6BVl42inuVyPfPnxwBZYqCkueIFnjQqZsRSgkRZAmhSAgsGMSi52GyLmB4to5oTy/EeAwnJ+ZwqlRDvakJEmMWE+nG14ySuvuKfgg5TYPr+1rNdSXJ8sYoIXA9DjnIwClF7+Z1WB9pxmVLVSTiEQgCQUCLQmvncEQPYYEaohJwYg5tUZXgsrCmKw3CIbuenxMK5bzneKa+VAsGJBW8WIYbCiOuhtGXUgFG4IPg6v4O6C0qSqUyiFGzHfASoZSIjEIgAQlhSVosVqoe15SGaTb0Rr4YNBjFwnIRku0ikG5GLBwGIRSu60BUQhA5wMenUK5VqvPF0ilRDhbKDQs0JIpYXK7r0yF+aNE0y1PzFwvnzxd5ZeYiGlUdhV/PwLctcEpACCAKIogUQK1SxdLoFP4sloaf+fqnQzNzcwZx6mDRdAt+GBlH2KX8fZlUVp0rBnXu86WqrsW62uUQ8cC5i3BrCqIsg3CgOnsBY9//OHb29OTx4wuLL+3NZWeHT0/gwEOPXYoDAPTHk9hRqqGQSV/mO45z4913Pdy7ae2B+IVJJEMUHge8TMYru3z05AdHi4ZhDJ2+WP5tW67z5xs29+DxE3m8887bl7a8dfPlUAJNOGFUWVciYzYJgXUbdu7c0LV6Jc6OyFhu1NHWKGMuf4F/Pll89euhTz9TWuKVb2amjbUb1+PgyDh+PnECAMAAoHtFN/ZsuApxJbqvu63jw66O9gOLF+ZbVuRWo6NnNSqWi4sOh6doNJxIaXWb55vbO9UjHw15Nrx6TIlgfGryH7CjNYMtK/vBfd/q6GrPNKcTPcTn4vmz56AlEwgRAnOuCM/jsA23I6Wot7WmU7fGNQ110zwWVyPeyZHf/wW2ZbCpswcQSaWrL/u53bB/FQRBMHQ9XK2UA1JApNOHj/JyftZ2mLQQjWrDSij0giLL7wZFUd91xTa8e3jon2IDwCcvvw4mCX+nnHMulctLKyOxSK/453zrwvg48TgW/CZ1LH3ttglX141Gw4TZsNAcj2PvA/cAAP4C8IBVZiJ4EWwAAAAldEVYdGRhdGU6Y3JlYXRlADIwMjMtMTAtMjZUMDg6NTA6MTQrMDA6MDDEn1J1AAAAJXRFWHRkYXRlOm1vZGlmeQAyMDIzLTEwLTI2VDA4OjUwOjE1KzAwOjAwE7XhfQAAACh0RVh0ZGF0ZTp0aW1lc3RhbXAAMjAyMy0xMC0yNlQwODo1MDoxNSswMDowMESgwKIAAAAASUVORK5CYII=",
      asSource: true,
      asTarget: true,
      uploadPath: "/upload/1",
      needDoubanInfo: true,
      seedDomSelector: "#meta-info+.meta-general>.panel:first",
      torrentDownloadLinkSelector: 'a[href*="/download/torrent/"]',
      search: {
        path: "/torrents",
        replaceKey: [
          "tt",
          ""
        ],
        params: {
          name: "{name}",
          imdbId: "{imdb}",
          sortField: "size"
        }
      },
      name: {
        selector: "#title"
      },
      subtitle: {
        selector: 'input[name="subhead"]'
      },
      description: {
        selector: "#bbcode-description"
      },
      imdb: {
        selector: "#autoimdb"
      },
      tmdb: {
        selector: "#autotmdb"
      },
      mal: {
        selector: "#automal"
      },
      bgm: {
        selector: "#bgm"
      },
      mediaInfo: {
        selector: 'textarea[name="mediainfo"]'
      },
      bdinfo: {
        selector: 'textarea[name="bdinfo"]'
      },
      anonymous: {
        selector: '.form__group input[type="checkbox"][name="anonymous"]'
      },
      torrent: {
        selector: 'input[name="file"]'
      },
      category: {
        selector: "#autocat",
        map: {
          movie: "1",
          tv: "2",
          tvPack: "2"
        }
      },
      videoType: {
        selector: "#autotype",
        map: {
          uhdbluray: "1",
          bluray: "1",
          remux: "2",
          encode: "3",
          web: "4",
          hdtv: "",
          dvd: "",
          dvdrip: "",
          other: ""
        }
      },
      resolution: {
        selector: "#autores",
        map: {
          "4320p": "1",
          "2160p": "2",
          "1080p": "3",
          "1080i": "4",
          "720p": "5",
          "576p": "6",
          "480p": "8"
        }
      }
    },
    MTV: {
      url: "https://www.morethantv.me",
      host: "morethantv.me",
      siteType: "gazelle",
      asSource: true,
      asTarget: true,
      needDoubanInfo: true,
      uploadPath: "/upload.php",
      search: {
        path: "/torrents/browse",
        params: {
          searchtext: "{imdb}",
          title: "{name}"
        }
      },
      icon: "data:image/png;base64,AAABAAEAEBAAAAEAIABoBAAAFgAAACgAAAAQAAAAIAAAAAEAIAAAAAAAQAQAABMLAAATCwAAAAAAAAAAAAAiHaEEIh2hYCIdoaEiHaGaIh2hmCIdoZgiHaGYIh2hmCIdoZgiHaGYIh2hlyIdoZUiHaHAIh2htiIdoUEAAAAAIh2hJyIdoW0iHaFsIh2hbCIdoWsiHaFrIh2hayIdoWsiHaFrIh2hayIdoWoiHaFbIh2hsyIdof8iHaH7Ih2hQSIdoQciHaEDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAiHaG8Ih2h/yIdoZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIh2hoSIdof8iHaGeAAAAAAAAAAAAAAAAIh2hIiIdoZkiHaGZIh2hIiIdoSIiHaGZIh2hiAAAAAAAAAAAAAAAACIdoaEiHaH/Ih2hngAAAAAAAAAAAAAAACIdoaoiHaH/Ih2h/yIdoUQiHaF3Ih2h/yIdof8iHaFEAAAAAAAAAAAiHaGiIh2h/yIdoZ4AAAAAAAAAAAAAAAAiHaG7Ih2h/yIdoREAAAAAIh2h7iIdof8iHaH/Ih2hqgAAAAAAAAAAIh2hoiIdof8iHaGeAAAAAAAAAAAAAAAAIh2huyIdof8AAAAAIh2hVSIdof8iHaGZIh2hzCIdof8iHaERAAAAACIdoaEiHaH/Ih2hngAAAAAAAAAAIh2hZiIdod0iHaH/Ih2hmSIdobsiHaH/Ih2hVSIdoXciHaH/Ih2hdwAAAAAiHaGhIh2h/yIdoZ4AAAAAAAAAACIdoZkiHaH/Ih2h/yIdof8iHaH/Ih2h7gAAAAAiHaEzIh2h/yIdobsAAAAAIh2hoSIdof8iHaGeAAAAAAAAAAAAAAAAIh2huyIdof8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACIdoaEiHaH/Ih2hngAAAAAAAAAAAAAAACIdobsiHaH/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAiHaGhIh2h/yIdoZ4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIh2hoSIdof8iHaGeIh2hCyIdoQYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACIdocUiHaH/Ih2hlSIdoSMiHaFwIh2hfSIdoXEiHaF3Ih2heiIdoXkiHaF5Ih2heSIdoXoiHaFzIh2hYiIdocIiHaH/Ih2h5yIdoS4AAAAAIh2hLyIdoXoiHaGMIh2hcyIdoXMiHaFzIh2hcyIdoXMiHaFyIh2heSIdoY0iHaFsIh2hSSIdoQoAAAAAAAEgNgAAb2Q/+CA1//hTdOA4cGngGCA54hhHZeQIaW7ACG50wIgAUOf4Q0Xn+E9S//hFVj/4PTYAAFJPgAFTUw==",
      seedDomSelector: "#descbox",
      torrentDownloadLinkSelector: 'a[href*="/torrents.php"][title="Download Torrent"]',
      name: {
        selector: 'input[name="title"][class="long"]'
      },
      description: {
        selector: "#desc"
      },
      anonymous: {
        selector: 'input[name="anonymous"][value="1"]'
      },
      torrent: {
        selector: "#file"
      },
      category: {
        selector: "#category",
        map: {
          movie: "1",
          tv: "5",
          tvPack: "5",
          documentary: "1",
          concert: "1"
        }
      }
    },
    MTeam: {
      url: "https://kp.m-team.cc",
      host: "m-team.cc",
      siteType: "MTeam",
      icon: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAMAAAC6V+0/AAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAABdFBMVEUAAAACAgCCajIDAgEHBgImHw5XSCFcSyNTRCAeGAtpVihSQx9yXSxaSSJxXStZSSKxkUR9ZzCafjvNqE+TeDihhD6niUAdFwsAAAAGBQJ3Yi46MBYAAAAHBQJqVyhmVCcAAAAAAAA1LBSGbjMAAAAgGwx1YC0AAAAAAABENxqNdDYAAAAnIA9NPx0IBwMzKROmiUBSQx8IBgMaFQqCajLOqU86MBa9m0lEOBqSeDhyXStsWSlVRSAuJhJrWClxXCtmVCcjHQ1kUiZvWyoqIxBVRiByXixmVCckHg7rwFruw1zvxFzjulf0yV72yl/uw1v0yF7tw1v1yV74zGD3y1/3yl/1yV/4y1/5zGDxxl3lvFjku1jwxVzIpE3qwFrWsFL5zWDCn0vft1bHpE3MqE/Wr1LvxVz4zF/ctVXet1ZKPBzas1Tyx11ZSSK4l0f6zWDdtlVJPBzYsVNYSCK2lUbetlVIOxvXsFNXSCG1lEXpv1r///+72WvcAAAASXRSTlMAAAAAAKvo6uaQ+OL75/vn++v2/vX5+ogrXOazQ1/e2RsBoO85geUyDrfyRI3Hb6f5y2GA7P79/vz9+/nkwfn7+e35++73+/ejS5QV5gAAAAFiS0dEe0/StfwAAAAHdElNRQflBAoGJSzOxqaDAAAA40lEQVQY02NgZWNHAxycDFyeXqjA24ebgcfXDw348zLwBaALBvKTJhjkFxwSHBoU5hceEREaBFMZKSAoFBXq5ycsIhodAhUMFxOXkJSKCY6VlpGViwuFCEbKKzAoKsUnKKswMqkmRkAEA9TUmTU0kxK0tFkUdZKhgiEpunr6Bn4hqYZGxiZpMNvTTc3M/fyCQjIsLCPh7gzJzMoOCfLzy8nNy4c7KaSgsCgE6OzI4pIIP9IErUCCpWiC1pEBAUEZZeV+AQEB3hWVIQG+VTYMtnZ89nwOjk5W9vZ8zi6ubvZ87h4AngBo3AG4MQYAAAAldEVYdGRhdGU6Y3JlYXRlADIwMjEtMDQtMTBUMDY6Mzc6NDQrMDA6MDDepEzfAAAAJXRFWHRkYXRlOm1vZGlmeQAyMDIxLTA0LTEwVDA2OjM3OjQ0KzAwOjAwr/n0YwAAAABJRU5ErkJggg==",
      asSource: true,
      asTarget: true,
      uploadPath: "/upload",
      seedDomSelector: ".detail-view .ant-descriptions-view>table>tbody .ant-descriptions-row:nth-child(3)",
      search: {
        path: "/browse",
        replaceKey: [
          "tt",
          "https://www.imdb.com/title/tt"
        ],
        params: {
          keyword: "{imdb}",
          sort: "size%3Adescend"
        }
      },
      name: {
        selector: "#name"
      },
      subtitle: {
        selector: "#smallDescr"
      },
      description: {
        selector: "#descr"
      },
      mediainfo: {
        selector: "#mediainfo"
      },
      imdb: {
        selector: "#imdb"
      },
      douban: {
        selector: "#douban"
      },
      tags: {
        diy: 'input[value="diy"]',
        chinese_subtitle: 'input[value="sub"]',
        chinese_audio: 'input[value="dub"]'
      },
      torrent: {
        selector: "#torrent-input"
      },
      category: {
        selector: "#category",
        map: {
          movie: [
            "401",
            "419",
            "420",
            "421",
            "439"
          ],
          tv: [
            "403",
            "402",
            "435",
            "438"
          ],
          tvPack: [
            "403",
            "402",
            "435",
            "438"
          ],
          documentary: "404",
          concert: "406",
          sport: "407",
          music: "434",
          cartoon: "405",
          app: "422",
          ebook: "427",
          magazine: "427",
          audioBook: "427"
        }
      },
      videoCodec: {
        selector: "#videoCodec",
        map: {
          h264: "1",
          hevc: "16",
          h265: "16",
          x264: "1",
          x265: "16",
          mpeg2: "4",
          mpeg4: "15",
          vc1: "2",
          xvid: "3",
          av1: "19"
        }
      },
      audioCodec: {
        selector: "#audioCodec",
        map: {
          aac: "6",
          ac3: "8",
          dd: "8",
          "dd+": "8",
          flac: "1",
          dts: "3",
          truehd: "9",
          lpcm: "7",
          dtshdma: "11",
          atmos: "10",
          dtsx: "3",
          ape: "2",
          wav: "7",
          other: "7",
          mp3: "4"
        }
      },
      source: {
        selector: "#source",
        map: {
          uhdbluray: "1",
          bluray: "1",
          hdtv: "4",
          dvd: "3",
          web: "8",
          vhs: "6",
          hddvd: "6"
        }
      },
      videoType: {
        selector: "#medium",
        map: {
          uhdbluray: [
            "1",
            "421",
            "438"
          ],
          bluray: [
            "1",
            "421",
            "438"
          ],
          remux: [
            "3",
            "439"
          ],
          encode: [
            "7",
            "401",
            "419",
            "403",
            "402"
          ],
          web: [
            "10",
            "419",
            "402"
          ],
          hdtv: [
            "5",
            "419",
            "402"
          ],
          dvd: [
            "6",
            "420",
            "435"
          ],
          dvdrip: [
            "7",
            "401",
            "403"
          ],
          other: ""
        }
      },
      resolution: {
        selector: "#standard",
        map: {
          "2160p": [
            "6",
            "419",
            "402"
          ],
          "1080p": [
            "1",
            "419",
            "402"
          ],
          "1080i": [
            "2",
            "419",
            "402"
          ],
          "720p": [
            "3",
            "419",
            "402"
          ],
          "576p": [
            "5",
            "401",
            "403"
          ],
          "480p": [
            "5",
            "401",
            "403"
          ]
        }
      },
      area: {
        selector: "#processing",
        map: {
          CN: "1",
          US: "2",
          EU: "2",
          HK: "3",
          TW: "3",
          JP: "4",
          KR: "5",
          OT: "6"
        }
      },
      team: {
        selector: "#team",
        map: {
          mteam: "9",
          tnp: "23",
          kishd: "7",
          bmdru: "6",
          onehd: "18",
          cnhk: "19",
          stbox: "20",
          r2hd: "21",
          pack: "8",
          geek: "24",
          qhstudio: "34"
        }
      }
    },
    NYPT: {
      url: "https://nanyangpt.com",
      host: "nanyangpt.com",
      siteType: "NexusPHP",
      icon: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAMAAAC6V+0/AAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAB71BMVEVTu8ZWu8ZRusVkwctrxM2R09rW7vFTu8ZSusW44ue04eVTu8ZhwMpTu8Z5ydKFzdWs3OLR7O9Tu8bD5enN6u5lwstTu8ZTu8ZiwMpWvMZSusVTu8ZTu8ZTu8bD5up5ydJQucVSu8VSusVVu8aM0NhrxM2W1Nuf2N5Uu8Zpw83S7O98ytO54ueP0dl7ytPT7e93yNFRusVTu8ZiwMpwxs/V7fCO0dmg2d9gwMqz4OWv3uPB5eldv8llwcu64+e34eaBzNTA5emo3OFWvMdQusWw3+Sn2+HO6+6i2d9+y9PG5+tlwst7ytLT7fBvxs93ydHX7/GS09qs3eOFztbh8vTZ7/Ffv8lSusZ/zNTR7O9sxM6T09rc8PKJz9eu3uOp3OLK6e2a1tyAzNRnwsxXvMed193a7/Lf8fNcvsjE5urK6exVvMaHztZWvMa74+eY1dxSu8ZowsxYvMdjwctavchzx9BPucRQucRZvcdtxM6N0diQ0tl6ytKR09qU1NuV1Ntqw82Iz9fQ6+5Zvcie2N7H5+u44uZyx9Btxc6o2+FYvcd4ydHX7vG74+ij2d98y9PW7vFhwMrF5+ub193E5+qd197E5+vM6u3L6u1gv8nT7O90x9C04eW14eWa1t1vxc9uxc7P6+5gv8qy4OT///+e7qWjAAAAHnRSTlMAAEvO+oAXN9f3gYr55/3CaPzNFKD+10sUaMP+6DbE9n4oAAAAAWJLR0SkWb56uQAAAAd0SU1FB+UECgcwCiq8r10AAAFtSURBVBjTJdBlV0JBEAbgtbs7uc5VuZjMKhY2KIqJiV3X7sJusbs7/6gDzqfd58zOeWcZc3SKVQhxIMYnJColAHB2cWVu7qqkZLqIKalp6WrkkOHhybwwU5OVnYOYqxTztPlCQWGRN/NBtaa4pFSnLysXVIaKSmNKFTKO1TW1dfUmbGhAbGxqrmjBVkJzWzt0dHZ19yC29PZx4Jyw3zCA8uDQsBJhZNSE3I7msQyA8aykCYTJqWk7zsBs/BzQo/kFCtm/CDOEdBIselLLfy1RK1ueWFldq1tAcX1jc4vK1I6cbRt2lLG72sq9faPVajVqD9YJD2vMIB8da9SSLJ8sy7pxCTg7PTMjoHx+AYCXW7YfoZmKqzTBIlzf3ALXr91RDlskX43iaPP+4TEBOTY+Pf+j38ur4u39Q0VJsdqwjXb0D/gEUQKkFvj6XrRhIAsKDqHhtj04/Px+EoaGMYfwiMgobi+QrnUQ7RXD/gCppmlft2mUAgAAACV0RVh0ZGF0ZTpjcmVhdGUAMjAyMS0wNC0xMFQwNzo0ODoxMCswMDowMGet8SMAAAAldEVYdGRhdGU6bW9kaWZ5ADIwMjEtMDQtMTBUMDc6NDg6MTArMDA6MDAW8EmfAAAAAElFTkSuQmCC",
      asSource: true,
      asTarget: true,
      uploadPath: "/upload.php",
      seedDomSelector: "#top~table:first>tbody>tr:nth-child(5)",
      torrentDownloadLinkSelector: 'a[href*="download.php?id="]',
      search: {
        path: "/torrents.php",
        imdbOptionKey: "4",
        nameOptionKey: "0",
        params: {
          incldead: "0",
          search_area: "{optionKey}",
          search: "{imdb}",
          sort: "5",
          type: "desc"
        }
      },
      subtitle: {
        selector: 'input[name="small_descr"]'
      },
      description: {
        selector: "#descr"
      },
      imdb: {
        selector: 'input[name="url"][type="text"]'
      },
      douban: {
        selector: 'input[name="dburl"]'
      },
      torrent: {
        selector: 'input[name="file"]'
      },
      category: {
        selector: "#browsecat",
        map: {
          movie: "401",
          tv: "402",
          tvPack: "402",
          documentary: "406",
          concert: "407",
          sport: "405",
          cartoon: "403",
          variety: "404"
        }
      }
    },
    OpenSub: {
      url: "https://www.opensubtitles.org",
      host: "opensubtitles.org",
      siteType: "subtitles",
      icon: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQBAAAAAD/aE28AAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAAAmJLR0QADzoyPqMAAAAHdElNRQflBxcLOzjtVivgAAAARElEQVQI12NggAH+D//BCMHAAjj/L2B6/w/IqGRYzuMgC2RcYpDldQBJPWSQY/l/GSw1g4PBF8jg+r+A5/1XbMbgtgsAjDUiHY8LnyYAAAAldEVYdGRhdGU6Y3JlYXRlADIwMjEtMDctMjNUMTE6NTk6NTUrMDA6MDB7fTP0AAAAJXRFWHRkYXRlOm1vZGlmeQAyMDIxLTA3LTIzVDExOjU5OjU1KzAwOjAwCiCLSAAAAABJRU5ErkJggg==",
      asSource: false,
      asTarget: false,
      search: {
        path: "/en/search/sublanguageid-all/imdbid-{name}"
      }
    },
    Orpheus: {
      url: "https://orpheus.network",
      host: "orpheus.network",
      siteType: "gazelle",
      icon: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAYAAACNiR0NAAAACXBIWXMAAAPoAAAD6AG1e1JrAAAEiklEQVR4nI2UbUhbVxjHr93Y6MdROhDcJzW5MfdeE6/Re5leJSYkYTeSqPElxiiKJjfxbSjXi0i00RhqR1EWNEaR+JJ2idmsqXOz0+lstZ1Yna2tq1q1Gxu1K4V1bF8dR1SiW6EPPJzz4Zwf53nO8/9D0OmIgCDoHPSW0dzcfO7ozv/GCYwgiPN8Pj8xMjKyUCAQlBoMhmyPx6OYnJzMmJqa+nhmZiY6EAi8B84eHBxEgDwLOwRFRUWdFwgEZh6Pt8Dn8/dpmt602+3fe73eG36/PxgIBIKjo6OjwWBwxO/3fzY8PPxJOPgUDEXRqLi4uAkYhv9GUXS/qqpqdmho6JrX6/X19vYG+vr6/AMDA9fA6na7g93d3aHe3t5vXC7X5StXrnx4CioSiS4iCDKPIMhrFEV3LBbLXGdn543W1tYJu90+63A4Jurr66dNJtNybW3ttN1un+zo6Ag5HI5Qe3v7nMPh6OM47oOTejEM88THx/8pFAp3tFrtalNT0636+voZlmUXOY7raG1tjcYwDEEQ5DqGYS9JktzU6/VLHMdNsyw7xbLsEsuylw5hOI6n4Dj+e0JCwg5Jktsmk2mBYZh5hmFWGIZpOdPwiISEhM9FItFLDMN2MzMz16xW67zZbL5tNpuXysvLJVBycvJVgiD2JRLJlkKheGQ0Gu/p9fqfDAbDhF6vPyxDp9O9AxLsJRLJBZIk7xAE8UtSUtJ2dnb2alFR0d3CwsLHBoPBDlEUtUBR1E5qauoTmqYfZmVlLWs0mqdarfbTY9jx89LS0t4FK0VRDRRFPU9JSflZLpc/zsrKWtVoNOtarXYakslkj2Qy2QZI8EKFQrGmVCp3VSoVfRZ4vJdKpWq5XP5MJpOtA6BSqVw/yocQTdNrNE0/ACmVSjcoitpIT0//laKozDcB1Wo1TdP0tlqtXlWpVOtpaWlPQKanp29Aubm5t3Q63YO8vLzljIyMDYIgNkmSfEGSJBdeZjgwJyenVqfTbeXl5S2BhyQnJ28TBLFHEMRdyGg0XiopKVkvLS1d0Ol0K2KxeBfH8d9wHF+EYfjC2U8BH1VSUnKzuLh4paysbBG0SSwWP01MTPwDx/FOiGEYSWVl5T2LxTJfXV39A2iBUCh8hqLoKwzDXOHiByNktVpbLBbLfavVOscwzB2JRLKDouhefHz8cxRFUw8PNjQ0tHAc9yPHcd82NjZ+V1BQsATGSCgUvoJh+AsYhhEw3BzHXeY4boFl2WmbzTal0WhWYRjeQ1H0NYIgfSfTCmQD5ON0OoGMxoGsgLxqampmKioq7tfV1U07nc6bbW1thzIEsjSbzXNxcXG7MAz/JRAIbsfExFw8KQOsQOBA6N3d3VNA+D09PcFjQ/B4PAG32z0K9sAwLBbLrFAofMHj8f6BYfjr6Ojoj8KN5gQKrGhwcJD2+XxXR0ZGrvt8vi99Pt9XIPv7+0M2m21OpVJt8Xi8/djYWGBxJmB5p2DhDT8Gd3V1vT8+Ph4TCoVSxsbGMlwulzI/Pz+Hz+eXAtMF5gtMOAz0Ztc+svW3jf/A/gVj2wYRcKPv6wAAAABJRU5ErkJggg==",
      asSource: true,
      asTarget: true,
      uploadPath: "/upload.php",
      search: {
        path: "/torrents.php",
        params: {
          searchstr: "{name}"
        }
      },
      torrent: {
        selector: "#file"
      }
    },
    OurBits: {
      url: "https://ourbits.club",
      host: "ourbits.club",
      siteType: "NexusPHP",
      icon: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAYAAACNiR0NAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAABmJLR0QA/wD/AP+gvaeTAAAAB3RJTUUH5QQKBicSPZHZqgAABUJJREFUOMsFwdlvXFcBB+Dfuefcc7eZ8awZ22M7jpfGxQlZGpoWhxYVgVpaqQuPSMATz/wFiH+BRx4QQkgVCAkQS1GRQIgi5BIVxwlJG+yOxxnbs8+9c5e567mH7yMAwA57+HHtO3jf/56yIHUz0262JPS7Rna0d4m3b+qG1joOr9HzXtlJnOSJTtJ/GWb+b1UMPhV91W5u/FR8fvgTPPy+DvZhcBlNcw2n3i5Zu/hLcyKuf2VCF782L67tLKpRc2W2X5XdkTVJYkzkK7qmE6OqnqwuqZ2XeBr+A0vZByHNTzZfeSHfOPwmWJAu4DwwSZDwK63gozdGY+c9p/rinbReKgmzjJltwu3nsDUus6ppcE2UNeFfbrFHX1ytHW2PM9Z84jR+nTjPP1JAc/YBPVQa/ofNS8GPXick/C4R3nUiZpqRnkFkGp5pb2LWdMHKN0i5UAFPRjAdB5XkMa/jwW7PqVaCfkWd5D/4+Yzu/Y8VaM9SzeReNNfeg0GuWQ1LW8M+iY/vY67fRty4B3rFQKGoQmYZtOEzMPcYPS8l7qTAuq5YhkzfXV74r7ubDX7GcnGxYmmdN1SDvWhSV6+Ih0R1ztAdX4VvrEMhM6jMQJoJZPMh6MUBnN4znAVbmGMXBRN0uzFcb1m/3IuHO49ZlvC7SJ4+5533iheHIYZuiGHxGvr1t5DxDViRi+g0RzhXQdFFiQ9gVAWCwjpCbGO1OSOtQkdV7aPtc4+8zWahvOcnnUY0foZ+bwEd7w5GxXcQNm9D0QTg+eBOAuoF+MLSU6zXn4CSNrbpDIl5ARn68IYjzM4WGt1B4WXW9vhNNTRqXKkgXLkD33sbQt8CoQGkEkEIDQqKaDTGuHX5AZpkH6E7Qb1yCmpJfNzJ8eTxMqajXcO215rsNCqukujLZsW6hGhnD2rwVah2gjycgUdAwSbQcgqjocGNAiTjGFSUUFooIrYD+F4ATxTlJN1SbH9LZyCMjArvkISPoFOKMgMyX4OcFGAmMcwwB+EBfK+AT7xXwWYENcNG5rkwlEOUCjFqNYlR2oAkt8DKIekn5jJz5KK+JNu4av4dTd3D0/YaXOcKJFehFQIIksG3vgSfXIdDp1gr7GPdOIY9tDHzFgjYUl5arkTMdJJHwWhsRTArS6UhWuXfoqF2kJlb6MUvIZbPIZ6XkDICSUsI4mXwvAIxP4BZlshzAtctIRKl0KxlQybt2T+D7mAjEcUNuzFFvxWiwU9xc+cEm/FnOO6/iqPpmwjVZdA4gzzvQsRH8LQD2FaIWFxCltaQhmLCzfl9uvKNb2Vur7uTurNN3+eqm9RJURtha6WPgtHDwDUwEC9DFK8AaYjos2OQ9n2U2CFyjaDd38PF8JaQqXbQoORXzGSyUy+Zfx10zjfdXvn2mbOtlcUNlPUT+HaC9lEFc90E1+YQng3pDzB3HDx+WMbx8Cps7fU8x+KgqIw/QRrss9rqmiuC5G8JoYt5Jip+f75xShdVQymT2NYwOGkhLPpQlD6QJVBLFuLSIvq2IWWyKEldcwwr/TM32O+zrRsuLVdfkMTxPV01JllG0iTJqqHgVUkjFiY1uLN1RK4ic38KmWWQqgZBOBEZF4pqnjI1/QPB9BfFev2BtnlLoRt334WRSik5m2RK0s2helHCY1Ae5aQm0qRIMjck+eQil6Ebg5CpwmiHUvkfXRV/5DJ6P7O7B823vp0CXNLTj3+H2tdfgx/o0ipnbjietRG4nyOz5nle4cipriQ+V0JbKMHUURPvyKLyo5Kp/4Zz+ifEfmf62g/T1vNcSg/i/8nGx5VMcAmaAAAAJXRFWHRkYXRlOmNyZWF0ZQAyMDIxLTA0LTEwVDA2OjM5OjE4KzAwOjAwTy0YfAAAACV0RVh0ZGF0ZTptb2RpZnkAMjAyMS0wNC0xMFQwNjozOToxOCswMDowMD5woMAAAAAASUVORK5CYII=",
      asSource: true,
      asTarget: true,
      seedDomSelector: "#top~table:first>tbody>tr:nth-child(3)",
      torrentDownloadLinkSelector: 'a[href*="download.php?id="]',
      uploadPath: "/upload.php",
      search: {
        path: "/torrents.php",
        imdbOptionKey: "4",
        nameOptionKey: "0",
        params: {
          incldead: "0",
          search_area: "{optionKey}",
          search: "{imdb}",
          sort: "5",
          type: "desc"
        },
        result: {
          list: "#torrenttable>tbody>tr",
          url: '.torrentname td a[href*="details.php?id="]',
          name: '.torrentname td a[href*="details.php?id="]',
          size: "td:nth-child(5)"
        }
      },
      name: {
        selector: 'input[name="name"]'
      },
      subtitle: {
        selector: 'input[name="small_descr"]'
      },
      description: {
        selector: "#descr"
      },
      poster: 'input[name="picture"]',
      imdb: {
        selector: 'input[name="url"][type="text"]'
      },
      anonymous: {
        selector: 'input[name="uplver"]'
      },
      torrent: {
        selector: 'input[name="file"]'
      },
      tags: {
        chinese_audio: "#tagGY",
        diy: "#tagDIY",
        cantonese_audio: "#tag_yy",
        chinese_subtitle: "#tagZZ",
        hdr: "#tagHDR10",
        hdr10_plus: "#tagHDR10P",
        dolby_vision: "#tagDB"
      },
      category: {
        selector: 'select[name="type"]',
        map: {
          movie: "401",
          "3d": "402",
          tv: "412",
          tvPack: "405",
          documentary: "410",
          concert: "419",
          sport: "415",
          cartoon: "411",
          variety: "413",
          music: "416"
        }
      },
      videoCodec: {
        selector: 'select[name="codec_sel"]',
        map: {
          h264: "12",
          hevc: "14",
          x264: "12",
          x265: "14",
          h265: "14",
          mpeg2: "15",
          mpeg4: "12",
          vc1: "16",
          xvid: "17",
          dvd: "18"
        }
      },
      audioCodec: {
        selector: 'select[name="audiocodec_sel"]',
        map: {
          aac: "7",
          ac3: "6",
          dd: "6",
          "dd+": "6",
          flac: "13",
          dts: "4",
          truehd: "2",
          lpcm: "5",
          dtshdma: "1",
          atmos: "14",
          dtsx: "21"
        }
      },
      videoType: {
        selector: 'select[name="medium_sel"]',
        map: {
          uhdbluray: "12",
          bluray: "1",
          remux: "4",
          encode: "7",
          web: "9",
          hdtv: "5",
          dvd: "2",
          dvdrip: "2",
          other: "0"
        }
      },
      resolution: {
        selector: 'select[name="standard_sel"]',
        map: {
          "2160p": "5",
          "1080p": "1",
          "1080i": "2",
          "720p": "3",
          "576p": "4",
          "480p": "4"
        }
      },
      area: {
        selector: 'select[name="processing_sel"]',
        map: {
          CN: "1",
          US: "2",
          EU: "2",
          HK: "3",
          TW: "3",
          JP: "4",
          KR: "5",
          OT: "6"
        }
      }
    },
    PTHome: {
      url: "https://www.pthome.net",
      host: "pthome.net",
      siteType: "NexusPHP",
      icon: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAMAAAC6V+0/AAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAABR1BMVEUAAAD/sxz/sxz/sxz/sxz/sxz/sxz/sxz/sxz/sxz/sxz/sxz/sxz/sxz/sxz/sxz/sxz/shv/shv/sxz/sxz/sxz/sxz/sxv/sxz/shv/shr/sx3/tB//vj7/zWv/2pH/4ab/zmz/vTz/2Y7/7s7/+e7//v3/////sx7/uS7/ujH/x1j/68T/8dX/1YL/03z/25P/zGj/6b7/7Mj/9OD//fn/shn/033/sxv/w07/8tj/1oX/1oT/vj//uCr/463//v7/893/14r/14j/8db/2Iv/vDn/57n/+vD///7//fv//fr/6b3/vDj/vTv/ymD/35//89z/xE//yV//6Lv/7MX/7Mf/uTD/0nj/+vH/7sz/1YH/3Zr/uC3/x1r/+e3/5bL/yV3/9N3/8NP/yWD/ujP/zm7/xFD/57j/4qr/wkn/vDf/tym6/awGAAAAGHRSTlMAAAEmcLXj+bYPYsPx/hWL7u6LEPTi+u42ThkjAAAAAWJLR0QnLQ+oIwAAAAd0SU1FB+UECgYoFFNqYFAAAAE4SURBVBjTZdFXW8IwFAbgpINKW1pGq0laFRSIC5xUxIkDFTfiwL33/7/2pMUrz+X7nDz58gUhhLAkK2pM02I9iixhJAbjuG6YCQKTMA09jrEwy06SaCilqbQFijO20xXGPN9z0hmMJD3ao8zvHxjM5ryULiHZCIXRoeF8ocizPjVkpJhgI6Nj4xOl8mSpOOVRU0GqsOmZ2blKmQbzhRyjREUuqbKFGue8skjIUn6ZEeKiXsJWVtcAeX19Y3PLp4RogEFju74DuNvc2z9gIbqE+odHx02xe9ISBsdVQslpu3xWATy/YCKyCpGod9m5ur7pcN6+FQiRIDy7q90/PD7x5xdPnIbwkt5HX1tv742Pz6/QkvBMUQgL4Lbvn/AWx4ZCouqgtIBVxZ5tRYX+L/nvO1xNc9Xud/wCUFAuZX3Re8sAAAAldEVYdGRhdGU6Y3JlYXRlADIwMjEtMDQtMTBUMDY6NDA6MjArMDA6MDAnY2+xAAAAJXRFWHRkYXRlOm1vZGlmeQAyMDIxLTA0LTEwVDA2OjQwOjIwKzAwOjAwVj7XDQAAAABJRU5ErkJggg==",
      asSource: true,
      asTarget: true,
      uploadPath: "/upload.php",
      seedDomSelector: "#top~table:first>tbody>tr:nth-child(3)",
      torrentDownloadLinkSelector: 'a[href*="download.php?id="]',
      search: {
        path: "/torrents.php",
        imdbOptionKey: "4",
        nameOptionKey: "0",
        params: {
          incldead: "0",
          search_area: "{optionKey}",
          search: "{imdb}",
          sort: "5",
          type: "desc"
        },
        result: {
          list: ".torrents>tbody>tr",
          url: '.torrentname td a[href*="details.php?id="]',
          name: '.torrentname td a[href*="details.php?id="]',
          size: "td:nth-child(5)"
        }
      },
      name: {
        selector: 'input[name="name"]'
      },
      subtitle: {
        selector: 'input[name="small_descr"]'
      },
      description: {
        selector: "#descr"
      },
      imdb: {
        selector: 'input[name="url"][type="text"]'
      },
      douban: {
        selector: 'input[name="douban_id"]'
      },
      anonymous: {
        selector: 'input[name="uplver"]'
      },
      torrent: {
        selector: "#torrent"
      },
      tags: {
        chinese_audio: "#tag_gy",
        diy: "#tag_diy",
        cantonese_audio: "#tag_yy",
        chinese_subtitle: "#tag_zz",
        hdr: "#tag_hdr10",
        hdr10_plus: "#tag_hdrm",
        dolby_vision: "#tag_db"
      },
      category: {
        selector: "#browsecat",
        map: {
          movie: "401",
          tv: "402",
          tvPack: "402",
          documentary: "404",
          concert: "408",
          sport: "407",
          cartoon: "405",
          variety: "403"
        }
      },
      videoCodec: {
        selector: 'select[name="codec_sel"]',
        map: {
          h264: "1",
          x264: "1",
          hevc: "6",
          x265: "6",
          h265: "6",
          mpeg2: "4",
          mpeg4: "1",
          vc1: "2",
          xvid: "5",
          dvd: "4"
        }
      },
      audioCodec: {
        selector: 'select[name="audiocodec_sel"]',
        map: {
          aac: "6",
          ac3: "18",
          dd: "18",
          "dd+": "18",
          flac: "1",
          dts: "3",
          truehd: "20",
          lpcm: "21",
          dtshdma: "19",
          atmos: "19",
          dtsx: "3"
        }
      },
      videoType: {
        selector: 'select[name="medium_sel"]',
        map: {
          uhdbluray: "12",
          bluray: "1",
          remux: "3",
          encode: "15",
          web: "10",
          hdtv: "5",
          dvd: "2",
          dvdrip: "15",
          other: "11"
        }
      },
      resolution: {
        selector: 'select[name="standard_sel"]',
        map: {
          "4320p": "10",
          "2160p": "5",
          "1080p": "1",
          "1080i": "2",
          "720p": "3",
          "576p": "4",
          "480p": "4"
        }
      },
      team: {
        selector: 'select[name="team_sel"]',
        map: {
          pthome: "19",
          pth: "21",
          pthweb: "20",
          pthtv: "22",
          pthaudio: "23",
          pthebook: "24",
          pthmusic: "25",
          other: "5"
        }
      }
    },
    PTN: {
      url: "https://piratethenet.org",
      host: "piratethenet.org",
      siteType: "PTN",
      icon: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAQAAAC1+jfqAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAAAmJLR0QA/4ePzL8AAAAHdElNRQflBR0NCTVvZ8yaAAAB3UlEQVQozwXBT0hTcQDA8e977/c298I5Xchaf9S1ZRNLttmhltUQnSc9VAgFUWAgCzrYTYnOEZ0G0T/IiKi0Dv0jughJ64/YQB0q2imTwjmI2h/3tvden4/Ui4Tpczyt/qgkpA2wACvguFet+Zz4k65F2YuOc3L0qK8t5Si9U5GxUB+N9BzZlW7SH1vIZkSbMmIGBQobClV7RZQp5coUcMci72vahOvBlQN5DKYrZWXHhLejov/8lMumiDNmr/SOJUWRv2T5gqkOXztDAzor7ffZ4Dm96FSRghHn6NYvQxu60MUKIVoBuMTLu/UuWXy/Kvn5x3Y6pjpj8+xhkRH2s4Bg6M7SMICQcOPyqJ3zJGhimoc0YqIS6F6yoYNoxGRLRQEJCQkLExkLVBQnJYSGTHYtvxwN36KZDJcJMoediRl3ycsySnMzSfngWulQ6DQmZwmj0cIN5t+2nNL6N9PSwMeL0RyzZkEOc45aTFa5TRGVHnSuvxDC78GBTx43bz6ZbN0XqBiZb/n1k+fjKFSx7WbnYM/igJmyxq32USE5PLZGFyeSb6xXVp9x7GtdVKw/K74+vmD31SP7hcVvmRqkUB0Gmx9mu7EQKHgH+1djM9uCoGEHGrr6MvGM6zDAf9rgrjhkXWjnAAAAJXRFWHRkYXRlOmNyZWF0ZQAyMDIxLTA1LTI5VDEzOjA5OjUzKzAwOjAwiaGjGgAAACV0RVh0ZGF0ZTptb2RpZnkAMjAyMS0wNS0yOVQxMzowOTo1MyswMDowMPj8G6YAAAAZdEVYdFNvZnR3YXJlAEFkb2JlIEltYWdlUmVhZHlxyWU8AAAAAElFTkSuQmCC",
      asSource: false,
      asTarget: true,
      uploadPath: "/upload.php",
      search: {
        path: "/browse.php",
        params: {
          name: "{name}",
          imdb: "{imdb}"
        }
      },
      name: {
        selector: "#name"
      },
      description: {
        selector: "#descr"
      },
      mediaInfo: {
        selector: 'textarea[name="mediainfo"]'
      }
    },
    PTP: {
      url: "https://passthepopcorn.me",
      host: "passthepopcorn.me",
      siteType: "gazelle",
      icon: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAMAAAC6V+0/AAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAABU1BMVEUAAAACAgIEBAQDAwMBAQF7e3u+vr56enoXFxecnJy6urpSUlIuLi6vr6+xsbH///+wsLAhISHg4OB2dnZCQkL8/Px6fHy8vr95ensWFhebm528vL1UVFQuLS6xr7C9vbydnJsXFxZ7e3q/v718fHsXDAoiFQ8gGQ4eHAwfHw4LCwYIDQgQGw8PGxMPHBYNHBkHDg0GCAoOFx0MEBgODxgSDxoOChIDAQGcSj7oh1zgrVng0VrU2lk6Ohc4WzB2x29auXpZv5Fc0rcpY1gXKDVYl8Vae7ZYYqhwXKxZPnYBAQKxVkj/nWv/yWf+8Wj1+WhDQxtAaTiI5oFp145n3alr89Qwc2YaLj1mr+RojtJmcsODa8hoSIkCAQOxVEf/mmn/xWX+7Wbx92ZBQho/ZzeG4X5n04tm2aVp7tAvcGQaLTxkrN9mi85kb7+AacRmR4YCAQJn073lAAAAAWJLR0QPGLoA2QAAAAd0SU1FB+UEDAMAJuVAAk0AAAC+SURBVBjTY2BgZGJkYGZiYWFmZmFhYgZzGRhZ2dg5OLm4eXh5ebi5ODnY2ViBivj4BQSF+IVFREVFhPmFBAX4+YDKxcQlJKWkZWTl5GRl5BUUlZRVgPpV1dQ1NLW0dXT19A0MjYxNTM0YGMwtLK2sbWzt7B0cnZxdXN3cPTy9GMy9fXz9/AMCg4JDQsPCIyKjomNiGczj4hMSk5JTUtPSMzKzsnNy8/IL6CiI1UnYHI/Vm1gDBHvQYQtkbNEBAFOfVLHCxSMQAAAAJXRFWHRkYXRlOmNyZWF0ZQAyMDIxLTA0LTEyVDAzOjAwOjM4KzAwOjAw8nDEugAAACV0RVh0ZGF0ZTptb2RpZnkAMjAyMS0wNC0xMlQwMzowMDozOCswMDowMIMtfAYAAAAASUVORK5CYII=",
      asSource: true,
      asTarget: true,
      needDoubanInfo: true,
      uploadPath: "/upload.php",
      search: {
        path: "/torrents.php",
        params: {
          action: "advanced",
          searchstr: "{imdb}"
        }
      },
      sourceInfo: {
        editionTags: {
          HDR10: "hdr10",
          "HDR10+": "hdr10_plus",
          "Dolby Atmos": "dolby_atmos",
          "Dolby Vision": "dolby_vision",
          "10-bit": "10_bit",
          "2-Disc Set": "2_disc_set",
          "2D/3D Edition": "2d_3d_edition",
          "2in1": "2_in_1",
          "3D": "3d",
          "3D Anaglyph": "3d_anaglyph",
          "3D Full SBS": "3d_full_sbs",
          "3D Half OU": "3d_half_ou",
          "3D Half SBS": "3d_half_sbs",
          "4K Remaster": "4k_remaster",
          "4K Restoration": "4k_restoration",
          "Director's Cut": "director_s_cut",
          "Dual Audio": "dual_audio",
          "English Dub": "english_dub",
          "Extended Cut": "extended_edition",
          "Extended Edition": "extended_edition",
          Extras: "extras",
          "Masters of Cinema": "masters_of_cinema",
          Scene: "scene",
          "The Criterion Collection": "the_criterion_collection",
          "Theatrical Cut": "theatrical_cut",
          Trumpable: null,
          "Two-Disc Set": "two_disc_set",
          Remux: "remux",
          Rifftrax: "rifftrax",
          Uncut: "uncut",
          Unrated: "unrated",
          "Warner Archive Collection": "warner_archive_collection",
          "With Commentary": "with_commentary"
        }
      },
      targetInfo: {
        editionTags: {
          "2_disc_set": "2-Disc Set",
          "2_in_1": "2in1",
          "2d_3d_edition": "2D/3D Edition",
          "3d_anaglyph": "3D Anaglyph",
          "3d_full_sbs": "3D Full SBS",
          "3d_half_ou": "3D Half OU",
          "3d_half_sbs": "3D Half SBS",
          "4k_remaster": "4K Remaster",
          "4k_restoration": "4K Restoration",
          director_s_cut: "Director's Cut",
          dual_audio: "Dual Audio",
          english_dub: "English Dub",
          extended_edition: "Extended Edition",
          extras: "Extras",
          masters_of_cinema: "Masters of Cinema",
          scene: "sc",
          the_criterion_collection: "The Criterion Collection",
          theatrical_cut: "Theatrical Cut",
          two_disc_set: "2-Disc Set",
          remux: "Remux",
          rifftrax: "Rifftrax",
          uncut: "Uncut",
          unrated: "Unrated",
          warner_archive_collection: "Warner Archive Collection",
          with_commentary: "With Commentary",
          "10_bit": "10-bit",
          dts_x: "DTS:X",
          dolby_atmos: "Dolby Atmos",
          dolby_vision: "Dolby Vision",
          hdr10: "HDR10",
          hdr10plus: "HDR10+"
        }
      },
      description: {
        selector: "#release_desc"
      },
      poster: "#image",
      imdb: {
        selector: "#imdb"
      },
      anonymous: {
        selector: 'input[name="uplver"]'
      },
      mediaInfo: {
        selector: "#Media_BDInfo"
      },
      screenshots: {
        selector: "#url_vimages"
      },
      torrent: {
        selector: "#file"
      },
      category: {
        selector: "#categories",
        map: {
          movie: "Feature Film",
          tv: "Miniseries",
          tvPack: "Miniseries",
          documentary: "Feature Film",
          concert: "Live Performance"
        }
      },
      videoCodec: {
        selector: "#codec",
        map: {
          h264: "H.264",
          hevc: "H.265",
          x264: "x264",
          x265: "x265",
          h265: "H.265",
          mpeg2: "Other",
          mpeg4: "H.264",
          vc1: "Other",
          xvid: "XviD",
          DVD5: "DVD5",
          DVD9: "DVD9",
          BD100: "BD100",
          BD66: "BD66",
          BD50: "BD50",
          BD25: "BD25"
        }
      },
      source: {
        selector: "#source",
        map: {
          uhdbluray: "Blu-ray",
          bluray: "Blu-ray",
          hdtv: "HDTV",
          dvd: "DVD",
          web: "WEB",
          vhs: "VHS",
          hddvd: "HD-DVD"
        }
      },
      resolution: {
        selector: "#resolution",
        map: {
          "2160p": "2160p",
          "1080p": "1080p",
          "1080i": "1080i",
          "720p": "720p",
          "576p": "576p",
          "480p": "480p",
          NTSC: "NTSC",
          PAL: "PAL",
          other: "Other"
        }
      }
    },
    PTSBAO: {
      url: "https://ptsbao.club",
      host: "ptsbao.club",
      siteType: "NexusPHP",
      icon: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAYAAACNiR0NAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAABmJLR0QA/wD/AP+gvaeTAAAAB3RJTUUH5QQKBiwfoNR83AAABVJJREFUOMtNlVtsVNcVhr+99zlnPL6Mz4wBu1zsEpvB9hjHxLeYEFzapDWkTqNEFFoUhHGLlD60VZuXoEhVeKFBVQtRE1tIEEIkEqnKQxrJiSBxXCfFTl1gggHjxJdxgrGxPXicsWcyMz5n9wFSsaRf618vS1r/w7cE91VzczM9PT3U19V5f/u731fl+fIeUUptKihYscqb7SWVSs0sxuODExMT/z5+7G9Xr1wZTG7fvp2enp7/7xDfmf1t+zn9+mnZ0dlZEwqF2sZGR1r6L/SuXYjFPKsKi0TLzieprtmstdapdDp18040+kE4HH79V+3t4fb2dvfkyZMAKIDW1lbGxyPW8Vde2V39YM1fp6du/fTNU52Bm5EvjcTigpj8OsKVK2GC5ZVizbpiw/JYAZ8vv2HNmjWPtrS0xN46e3a4vr7eGR4eRkkpSCaTxuHDh39ZWlp21OPxPHCu65+M3Bgky+NBKYllmiQTi5iWh811DUghMQwDr9e70h/wb6kKVd3u7Oy4Fo/HXek4Li8cOtRYXFzyojKMIq01y5kUUgo0gAaNRklJOpXCdVw0kEgsMTs7g6t1UUWo8sWXXz7aqLXG2LNnT/6vDx48aJhmGYAQgtCmGsL/7SeTSSGlBC2wPB6qqmtACPo+7eW9d99h9vYU+XaAx36ys2xDsPzg/ra2q+q5536ztbik5A/KUD4lFUIICotWk52TzfTUTRKJJbTrUlPbSOvTu7kxdI1Xjx1lejKCk0kRuzPH4OeXWVlYtKKiMjSg2g4c2Gf7/Ts0Ws3OzjA9NYWQgtCmzVRVb0YAyxmHZ36xj5xcH2+c7GDq5jhZHg9S3c3SWc6glOktr6yKGF6vd2MymTDOf9DFQP8nfJtM4rNtHt7SzPbHfsyuvQeIzt7GX7CS3o8/5PrgZSzTQKMRWqCFRgiBZZlGbp5vo9r77LP7Lg70l5977x20k8aQkEouMXzjKuHLF8nJ8VG2IYgUgnQ6xVJ8gfk7UZzlZQBc7ZLl9fLEz3aJVYXfGzeWFhe/GR2+rpVCGEoBYBgGytAsLUQRaKRUfDURoXTDRsorDnFpoI8Lvd3Mzc3g8+Xzgx+10NC0VX81MRE3ksnkDa83KwPC0mgEAq01rutS17iV2vqHCYcvcqrz75SsL2VH61M0bNlGXeMjJBNLZOfkkJuXTzqdzsRisSG1bVuzLF637vGJyEh+MpFAa43WLqvXFvP07n0IKXn7zVNEZyaZm5lm4LM+5mMLVISqsf0BTNPCdV0SS0uTAwP/Oa5S6dSdlpadpcHy0EOgRW5uHpVVD/LEUz9n9boSPu3tpv+TbkxTYRgKoV3GRoaxAysoLQuitcZxHH1r6tY/Ol597Q3j/PkP438+cuTEtubmLbv2BkNojWlZgCCVThEZ/RKhXQQKNEgpka7D6BdDZB7fgZSC+Dfxoc/6+k90d38UN0xDAVx6raPjpfKKir+YllXspjMoKVFKYdt+EKC1BiFA383Ztv33Tk1OhMOX//T883+8NHDho7u0CQaD+syZM1/U1dWN2fl2mWEYhYAUUmLbfr4eH2MhNo/WLhpN8fcfYMeTz7iO41zr77vw0tnTJ97/4aONyjQNRwFEo1EJeN/v6pqem5sbzMvNdbKysvxKqux82zY2VoTI8+Vh2wEqKjfxUEMT42Oj4lzXu4nI6FAwELB3aa0LhBDXvwOsCRQA+YAFZNfW1q5tamrasH79+hJ/IOCzLIvYfHR5+tZkcnxsJL24MO9YHsu1THPZMNS3Qoh/CSE+Fvd9AOOeFCDvI/r9swss3+vOPS0fO/KC/vzqMFpr/gfBWD3aoENSLwAAACV0RVh0ZGF0ZTpjcmVhdGUAMjAyMS0wNC0xMFQwNjo0NDozMSswMDowMERVxOEAAAAldEVYdGRhdGU6bW9kaWZ5ADIwMjEtMDQtMTBUMDY6NDQ6MzErMDA6MDA1CHxdAAAAAElFTkSuQmCC",
      asSource: true,
      asTarget: true,
      seedDomSelector: "#top~table:first>tbody>tr:nth-child(5)",
      torrentDownloadLinkSelector: 'a[href*="download.php?id="]',
      uploadPath: "/upload.php",
      search: {
        path: "/torrents.php",
        imdbOptionKey: "4",
        nameOptionKey: "0",
        params: {
          incldead: "0",
          search_area: "{optionKey}",
          search: "{imdb}",
          sort: "5",
          type: "desc"
        },
        result: {
          list: ".torrents>tbody>tr",
          url: '.torrentname td a[href*="details.php?id="]',
          name: '.torrentname td a[href*="details.php?id="]',
          size: "td:nth-child(7)"
        }
      },
      name: {
        selector: 'input[name="name"]'
      },
      subtitle: {
        selector: "#small_descr"
      },
      description: {
        selector: "textarea[tabindex]"
      },
      imdb: {
        selector: 'input[name="imdburl"][type="text"]'
      },
      anonymous: {
        selector: 'input[name="uplver"]'
      },
      torrent: {
        selector: 'input[name="file"]'
      },
      tags: {
        chinese_subtitle: 'input[type="checkbox"][name="zz"]'
      },
      category: {
        selector: "#browsecat",
        map: {
          movie: "0"
        }
      },
      source: {
        selector: "#medium_sel",
        map: {
          uhdbluray: "10",
          bluray: "1",
          hdtv: "5",
          dvd: "3",
          web: "2",
          vhs: "9",
          hddvd: "9"
        }
      },
      videoCodec: {
        selector: 'select[name="codec_sel"]',
        map: {
          h264: "1",
          hevc: "6",
          x264: "1",
          x265: "6",
          h265: "6",
          mpeg2: "4",
          mpeg4: "5",
          vc1: "2",
          xvid: "3",
          dvd: "4"
        }
      },
      audioCodec: {
        selector: "#audiocodec_sel",
        map: {
          aac: "6",
          ac3: "11",
          dd: "10",
          "dd+": "10",
          dts: "3",
          truehd: "9",
          lpcm: "12",
          dtshdma: "8",
          atmos: "8",
          dtsx: "13",
          flac: "1"
        }
      },
      videoType: {
        selector: "#processing_sel",
        map: {
          uhdbluray: "5",
          bluray: "5",
          remux: "1",
          encode: "2",
          web: "2",
          hdtv: "3",
          dvd: "3",
          dvdrip: "3",
          other: "3"
        }
      },
      resolution: {
        selector: 'select[name="standard_sel"]',
        map: {
          "2160p": [
            "5",
            "92"
          ],
          "1080p": [
            "1",
            "3"
          ],
          "1080i": "1",
          "720p": [
            "2",
            "91"
          ],
          "576p": "3",
          "480p": "4"
        }
      },
      team: {
        selector: 'select[name="team_sel"]',
        map: {
          ffansbd: "8",
          ops: "11",
          ffansweb: "12",
          ffanstv: "13",
          hqc: "10",
          ttg: "3",
          hdc: "6",
          chd: "2",
          hdsky: "9",
          cmct: "4",
          frds: "5",
          other: "7",
          ffansdvd: "14",
          fhdmv: "15",
          enichi: "16"
        }
      }
    },
    PTZone: {
      url: "https://ptzone.xyz",
      host: "ptzone.xyz",
      siteType: "NexusPHP",
      icon: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAYAAACNiR0NAAAACXBIWXMAAAPoAAAD6AG1e1JrAAAEmklEQVR4nG2VCUwUZxTHF7FJTZPaIzWlB9XWGqUBlUuFAkJopRQpkRIOTSsmgrpiSyBQjroCglS5CwoVCLAgRytYRQtoRBSKSWkTtUeksi7LXuzMzuyyu6y7OzP/ZmYDlZYvmZlv5s37fe8/7837RKLlBuAiAVbE9cAVgMsyb7i8f2r6RZ+UiWeW9ZdInM48aDm71xnNczGtug3xbYa4vR2G0gM91PWUXsPM5530QEST+hVnDIu+/GQp6KX0h68H1JEfRjXrM/d1UBf2d9MPDvaZrGkDDMSDHI4MAWlDduboLSCqzXKM9xECWhi7GnRukY3k/l+nbQNzVnbyL51dd09tZycIIHsEEA/YIe434egVAzcsszEKg4N5oHXYH9GAnHLcB/DCYpThDSr3hAvG0dQhoORnhr02BXAAOP4EML1/WpmEbopLuWTkUn40onjEhDtyO29jVRagfMQ0fe0u+fy/wDriUFKPxZTcZ0ZsB8UldRtgZzj8McsIYKuDQ86gCQldNJIvGhEtpZHWb+SBnPSeHTsbCENUDbHRmQysEIWUK9bHtOhliT3ziGun2M+6DUJodeMW3JyyCfNRuQ2x7TSSOmnsaaOQ0T8HGwOuatTM7W6dQ1S9Pp7nhUiGVwrgj77TDcd12RDdTDLxUkqA1IyacfB7Gk8cTu1lt8yIOK/H7mYSR/t4FUDlbZMjqp1BZD1RsiQxYd8SFTFSKz5uJNhPW/QCoH7cjMAaHdonLMK9gmaQ0KZH+DkC4ou08FnKhueYiJYniKgnryyps+ByIimy0Yxd52bZT84TTsm3TQiqnsWeRgJTpEN41v6LBX5lWhzqoYQIv7lhZEPPUviglpjyK1G+vAjcUazaGFqhtYdV6xBZOytorLo5h6ByLQLLtPjqEi0AHSyQLCWR2EyCYYHinwyCPbyGwI4zar9FoE/21OqA09rfgyv1CK/SsLxz+XUjfEvUCKvQwv+UGlfvzwvQkUkr9jYRsDEcCq/S8C1RsWE1Rmwr1R586k8RifxPqrsDys3YeVoj6Ds9YMDmEyoElWrgU6hCTK0WlEVYC+3jZhjmWRRcpuElUTJBFUb4FakbRE+n2luiyvUtNiLwpJLhnUr7aXjkzMC/QIlthUpsylGgctBZUnzmecl5P1D8c2bHKRpbjyvGRU+n2jNfGe2ZOwPvPIVQtAW9FNZnyLE1T4EtuQp45Sjgkz+D3x4/wcLI6iTxboac9T6uxeavZ9WbszVrhVYlJKZI/daawzIiuEgjAIt69Vh94BE8MqeFwzNLzr0plrH7ajUMw4LX7kiXUliXrmG3nLDAI3tmbHu6YtWS8mkaNj6irc6E2hwcc3dyngnIm2bXimXYkD6DTVk6vPEFBemYTaiEnC6SWpMqu/xe9vQJ9wz5uiX9kL+23pnvaxkDKvuN7NkbNrSOMvDNJeEuVuHtNBm5/tjj26+mTlVHlKiPAChQ0tj6n164QHQCRSH3fVcmTipWJU0aXBMmH4hiH3a9dliW+U7a36HuX8rdfBqW69BwEcXBdZGxxMD3xpNyt+35Ck/JMJ79v7Ow+sLWsHK57eEfAo6UC1R23N8AAAAASUVORK5CYII=",
      asSource: true,
      asTarget: true,
      seedDomSelector: "#top~table:first>tbody>tr:nth-child(6)",
      torrentDownloadLinkSelector: 'a[href*="download.php?id="]',
      uploadPath: "/upload.php",
      search: {
        path: "/torrents.php",
        imdbOptionKey: "4",
        nameOptionKey: "0",
        params: {
          incldead: "0",
          search_area: "{optionKey}",
          search: "{imdb}",
          sort: "5",
          type: "desc"
        },
        result: {
          list: ".torrents>tbody>tr",
          url: '.torrentname td a[href*="details.php?id="]',
          name: '.torrentname td a[href*="details.php?id="]',
          size: "td:nth-child(5)"
        }
      },
      name: {
        selector: 'input[name="name"]'
      },
      subtitle: {
        selector: 'input[name="small_descr"]'
      },
      mediainfo: {
        selector: 'textarea[name="technical_info"]'
      },
      description: {
        selector: 'textarea[name="descr"]'
      },
      imdb: {
        selector: 'input[name="pt_gen"]'
      },
      anonymous: {
        selector: 'input[name="uplver"]'
      },
      torrent: {
        selector: 'input[name="file"]'
      },
      tags: {
        hdr: 'input[name="tags[4][]"]'
      },
      category: {
        selector: 'select[name="type"]',
        map: {
          movie: "401",
          tv: "402",
          tvPack: "402",
          documentary: "404",
          cartoon: "405",
          sport: "407",
          concert: "406",
          music: "406",
          variety: "403"
        }
      },
      videoCodec: {
        selector: 'select[name="codec_sel[4]"]',
        map: {
          h264: "1",
          hevc: "6",
          h265: "6",
          x264: "1",
          x265: "6",
          mpeg2: "3",
          mpeg4: "4",
          vc1: "2",
          xvid: "5"
        }
      },
      audioCodec: {
        selector: 'select[name="audiocodec_sel[4]"]',
        map: {
          aac: "6",
          ac3: "8",
          dd: "11",
          "dd+": "12",
          flac: "1",
          dts: "9",
          truehd: "14",
          lpcm: "1",
          dtshdma: "10",
          atmos: "10",
          dtsx: "9",
          ape: "2",
          mp3: "4",
          ogg: "5",
          wav: "15"
        }
      },
      videoType: {
        selector: 'select[name="medium_sel[4]"]',
        map: {
          uhdbluray: "10",
          bluray: "1",
          hddvd: "2",
          remux: "3",
          encode: "7",
          web: "4",
          hdtv: "5",
          dvd: "6",
          dvdrip: "6",
          cd: "8"
        }
      },
      resolution: {
        selector: 'select[name="standard_sel[4]"]',
        map: {
          "4320p": "5",
          "2160p": "6",
          "1080p": "1",
          "1080i": "2",
          "720p": "3",
          "480p": "4"
        }
      },
      team: {
        selector: 'select[name="team_sel[4]"]',
        map: {
          hds: "1",
          chd: "2",
          mysilu: "3",
          wiki: "4",
          other: "5"
        }
      }
    },
    "PTer-offer": {
      url: "https://pterclub.com",
      host: "pterclub.com",
      siteType: "NexusPHP",
      icon: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAMAAAC6V+0/AAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAACu1BMVEUAAAD////Cl3f/sZv/88f/NgD/z6j/VAD/AAD/++v/NwCGe33/rGgAAAX/6dgABBr/zqgTL1vxCACLblsAAAwAEzYAAgiZgmoCAwX9AAAFBAb7q3IEAAADAgL217wFAAD//////////////f///f////9IPkDRiEj/mTr/lTr/lTr9mz3InGrZlFv9tXP/3r0AAAAkGh27YRL7gBBsUTKpVBb/exP/j0D/xJIAAAE5KiX1ewT5eQLpfhxhSzbOagv/lU3/7dkAAAArIBqFUSWNUh9+TCOtXxv5fgy0aimFTh6OUh6NWzJROCbneA3/gCf/yp0EAAABAAIAABQAABUNDB2YVhz7hiDCpYoAAAAAABIAAAsTFBmlXRv/fBX/vYQbGB+4ZRb/iCT/+eUBDx6PVSH/fhz/wowAAAAwJyP0jjnTuKXvx6kABUtfOybTcBP/hTD/1K0AAAJONCH8fwaPXCikcUz/unz/rnPpjT/dcg7/cQn/lUf///8AABVqQSL5gQ1iSCy1XhL/eAr+cgr+dgf+fSb/zKQAChyFTyHndw9bQi/TbwvrdgrrfC77rXUUFhumXBrFbhBhQCy8bByuYRWxYhiuYBunXh+OXDSai38AAAAsIB+kXQ9dRzqogmIjHRstKCgOFyoAAyAAAAk9KyPShTM1O0gAAAtWOSP+nksAAwxxRyPtcxv7pmwDAgNALB5zRyZnPh2WYzz82LoEAAABAAEAAAUAAAP/dwD/dAH/cwH/cgDTdRX2fAT+eAD/eAD+dwD4eAP0ewX2egT/eQD/bwb9ewH/egD/dAD/fQD/dgD+fgH/dQD/fAD/cwD+fgPUcRP+cwP/ewDpdgr+ewLzeQX+fAD+eQD9bwP7fQT/fwD/fQH+fQT0ewb/fgHBZxP/fgLYcRD/egfufAv+dgznew3ndwb///9+450wAAAAuXRSTlMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAkNDA4HASCOq6ipq2FhZxcCh/r8yuT4vjQVtf7+99b3tRYnq8fCyvH70sLBpNv981gIHBsXafLnTRYYH6n1/HOC/NEhafX3Xw+pui4IB5D+zSYdxv7PwHBdj+36egIw3P3c8Pf2/LIaUO773Pfrlx9y+/Tj9e3hyJdGBwOR87dgNikaBw+xuyEkz4ZA6PVdQ6WmqX0YBw0LDAI5k3AAAAABYktHRAH/Ai3eAAAAB3RJTUUH5QQKBzAvYbh7GgAAAUJJREFUGNNjYMAGGBkVFJWgQFlFlZERJMikpq6hqQUGmto6unr6zCwMDAaGRjt37dq9e/euXXuMTUzNzC1YGRksrfbus7bZf+DgocNHbO3sjx5zcGRjcHJ2cXVzP37Uw9PL28fX78RJ/wB2hsCg4JDQsFOnwyMio6JjYs+cjYvnANllkJB47nxSMicDQ0rqhbNp6VwgwYzMi+cuZWXncOfm5V8+X1DIAxTjLSq+cqKktKy8orLq6oHqmlo+oCB/Xf21Aw2NTc0trddv3GxrFwDpFuzovHW0q7vn9p2793r7+oXAfmKYMPH+uUmTp0ydNn3GzFnCYCGR2XMenHs4d978BQsXLRaFhojYkqWPTjxetlycESmYJFasfHLi6SpJZDEGqdVrnj1fu04aWUxGdv2GjZs2b5FDEZTfum37jtkMBAEAezt4kKiqYGgAAAAldEVYdGRhdGU6Y3JlYXRlADIwMjEtMDQtMTBUMDc6NDg6NDYrMDA6MDBMncp9AAAAJXRFWHRkYXRlOm1vZGlmeQAyMDIxLTA0LTEwVDA3OjQ4OjQ2KzAwOjAwPcBywQAAAABJRU5ErkJggg==",
      asTarget: true,
      uploadPath: "/offers.php?add_offer=1"
    },
    PTer: {
      url: "https://pterclub.com",
      host: "pterclub.com",
      siteType: "NexusPHP",
      icon: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAMAAAC6V+0/AAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAACu1BMVEUAAAD////Cl3f/sZv/88f/NgD/z6j/VAD/AAD/++v/NwCGe33/rGgAAAX/6dgABBr/zqgTL1vxCACLblsAAAwAEzYAAgiZgmoCAwX9AAAFBAb7q3IEAAADAgL217wFAAD//////////////f///f////9IPkDRiEj/mTr/lTr/lTr9mz3InGrZlFv9tXP/3r0AAAAkGh27YRL7gBBsUTKpVBb/exP/j0D/xJIAAAE5KiX1ewT5eQLpfhxhSzbOagv/lU3/7dkAAAArIBqFUSWNUh9+TCOtXxv5fgy0aimFTh6OUh6NWzJROCbneA3/gCf/yp0EAAABAAIAABQAABUNDB2YVhz7hiDCpYoAAAAAABIAAAsTFBmlXRv/fBX/vYQbGB+4ZRb/iCT/+eUBDx6PVSH/fhz/wowAAAAwJyP0jjnTuKXvx6kABUtfOybTcBP/hTD/1K0AAAJONCH8fwaPXCikcUz/unz/rnPpjT/dcg7/cQn/lUf///8AABVqQSL5gQ1iSCy1XhL/eAr+cgr+dgf+fSb/zKQAChyFTyHndw9bQi/TbwvrdgrrfC77rXUUFhumXBrFbhBhQCy8bByuYRWxYhiuYBunXh+OXDSai38AAAAsIB+kXQ9dRzqogmIjHRstKCgOFyoAAyAAAAk9KyPShTM1O0gAAAtWOSP+nksAAwxxRyPtcxv7pmwDAgNALB5zRyZnPh2WYzz82LoEAAABAAEAAAUAAAP/dwD/dAH/cwH/cgDTdRX2fAT+eAD/eAD+dwD4eAP0ewX2egT/eQD/bwb9ewH/egD/dAD/fQD/dgD+fgH/dQD/fAD/cwD+fgPUcRP+cwP/ewDpdgr+ewLzeQX+fAD+eQD9bwP7fQT/fwD/fQH+fQT0ewb/fgHBZxP/fgLYcRD/egfufAv+dgznew3ndwb///9+450wAAAAuXRSTlMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAkNDA4HASCOq6ipq2FhZxcCh/r8yuT4vjQVtf7+99b3tRYnq8fCyvH70sLBpNv981gIHBsXafLnTRYYH6n1/HOC/NEhafX3Xw+pui4IB5D+zSYdxv7PwHBdj+36egIw3P3c8Pf2/LIaUO773Pfrlx9y+/Tj9e3hyJdGBwOR87dgNikaBw+xuyEkz4ZA6PVdQ6WmqX0YBw0LDAI5k3AAAAABYktHRAH/Ai3eAAAAB3RJTUUH5QQKBzAvYbh7GgAAAUJJREFUGNNjYMAGGBkVFJWgQFlFlZERJMikpq6hqQUGmto6unr6zCwMDAaGRjt37dq9e/euXXuMTUzNzC1YGRksrfbus7bZf+DgocNHbO3sjx5zcGRjcHJ2cXVzP37Uw9PL28fX78RJ/wB2hsCg4JDQsFOnwyMio6JjYs+cjYvnANllkJB47nxSMicDQ0rqhbNp6VwgwYzMi+cuZWXncOfm5V8+X1DIAxTjLSq+cqKktKy8orLq6oHqmlo+oCB/Xf21Aw2NTc0trddv3GxrFwDpFuzovHW0q7vn9p2793r7+oXAfmKYMPH+uUmTp0ydNn3GzFnCYCGR2XMenHs4d978BQsXLRaFhojYkqWPTjxetlycESmYJFasfHLi6SpJZDEGqdVrnj1fu04aWUxGdv2GjZs2b5FDEZTfum37jtkMBAEAezt4kKiqYGgAAAAldEVYdGRhdGU6Y3JlYXRlADIwMjEtMDQtMTBUMDc6NDg6NDYrMDA6MDBMncp9AAAAJXRFWHRkYXRlOm1vZGlmeQAyMDIxLTA0LTEwVDA3OjQ4OjQ2KzAwOjAwPcBywQAAAABJRU5ErkJggg==",
      asSource: true,
      asTarget: true,
      uploadPath: "/upload.php",
      seedDomSelector: "#top~table:first>tbody>tr:nth-child(5)",
      torrentDownloadLinkSelector: 'a[href*="download.php?id="]',
      search: {
        path: "/torrents.php",
        imdbOptionKey: "4",
        nameOptionKey: "0",
        params: {
          incldead: "0",
          search_area: "{optionKey}",
          search: "{imdb}",
          sort: "5",
          type: "desc"
        },
        result: {
          list: "#torrenttable>tbody>tr",
          url: '.torrentname td a[href*="details.php?id="]',
          name: '.torrentname td a[href*="details.php?id="]',
          size: "td:nth-child(5)"
        }
      },
      name: {
        selector: 'input[name="name"]'
      },
      subtitle: {
        selector: 'input[name="small_descr"]'
      },
      description: {
        selector: "#descr,#body"
      },
      imdb: {
        selector: 'input[name="url"][type="text"]'
      },
      douban: {
        selector: 'input[name="douban"]'
      },
      anonymous: {
        selector: 'input[name="uplver"]'
      },
      torrent: {
        selector: 'input[name="file"]'
      },
      tags: {
        chinese_audio: "#guoyu",
        diy: "#diy",
        cantonese_audio: "#yueyu",
        chinese_subtitle: "#zhongzi"
      },
      category: {
        selector: "#browsecat,select[name='type']",
        map: {
          movie: "401",
          tv: "404",
          tvPack: "404",
          documentary: "402",
          concert: "406",
          sport: "407",
          cartoon: "403",
          variety: "405",
          music: "406"
        }
      },
      videoType: {
        selector: 'select[name="source_sel"]',
        map: {
          uhdbluray: "1",
          bluray: "2",
          remux: "3",
          encode: "6",
          web: "5",
          hdtv: "4",
          dvd: "7",
          dvdrip: "7",
          other: "15"
        }
      },
      area: {
        selector: 'select[name="team_sel"]',
        map: {
          CN: "1",
          US: "4",
          EU: "4",
          HK: "2",
          TW: "3",
          JP: "6",
          KR: "5",
          IND: "7",
          OT: "8"
        }
      }
    },
    "Piggo-offer": {
      url: "https://piggo.me",
      host: "piggo.me",
      siteType: "NexusPHP",
      icon: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAYAAACNiR0NAAAACXBIWXMAAAPoAAAD6AG1e1JrAAAFRklEQVR4nHWUa1AUVBiG1xmb+pHVr/rhNEVqYolXREQLIQNHQEXDNkNIbkaQUkCQ7rrimuIFXVy2QFFguMttl+WyIAuuLjdBIYQ0NHGE1FKG5SLsBfZplmYaa+zMnDkz5zvnme98530/geA5A5gJOHS1tETqKjQqVUbur0U/nftDeSbrfl1RmV5fo000GJ6sA2Y97/5/YbNaahuczx5OipTFilIVYmlr8neSgaTovUOyGNFjxb6DPcnxkuJTcRKRJr/IG3jrf2ESiWSmYdDwaZ4sVR/vF8i2hc5snLMYb7tF/0yfdxax1d6Rnas8SD94dLDvZm9KX0fHa8CMf8EaJJKZ7bor4v1fhPcl+AeTsjuKw4HBbLFfjs+cxWycu2QavvndZYS7ridrr4gjO8PY7eU3rMzIVo4+fPj6s898eXDQIEwIjuzb5eZFoUjMA005F2Un8bFz4OPZ89nwtgOeby7A224hivBI+itLaUxTsNdXSLin70h3a3uB0Wicb4O90N5wxTk7KaXR38mdQ8Id9BxLgJLzPFAWkhYvJk2UQMbBw5yVSDknkdJRmM9kXioTeamUiURssXfkVMw+S0V2ob8N6JB5XBYZs+lzvOwWUXlAgul8Mpw/xUSzjt87r2O4ewfTw36eDtzjj5vdDPd0MZUph5Jz3Mk8wxfLP+CT95xI2SdNE3Q2NX2dHCdJ3WK/Yro+N1Jk0FLPULOOXr2e9nI1vbpLPOrqoL+9jdZSJT11Wh62NTN1vZF7OecQe/myed4SkuMktwT16upymzQ2zVlC4NLVdBcVUqf4kS/XbiBwhSuBjq4EOLvjv9aTIA9vdntsJMRlHTuWfUj6Pgmt+bnIAoLwnbeUhOCIKYEqI+9XWax4YPO8pUj9g0kX7efAjmCEi13YbPvVuUvY7uyKOCSUQ+ERfPK+E37vOeE7dymBTm5IA8PIEh+YruMen08R2BxwfE+8wSaPCz8cIXqLEOHyNQQ4uRLk7M5XKz8i2W8nV6QnqJccJXqVJ2FrPKbjPnMWEea6nqJjx9m6YAWhbl4IytIy+49FxT/eusCRZoUCRdAuDm7ahjwknIzdMRRvj6ArVMxQ/GkexCRRtS2CrF3f8FNkFImfBXAm5Eua5KcROqwk3MMXgc2bsrj9PX72jnQfT8KUl4tVVcrURQ3Wi1o4cJanO6WMBCQwEZaIMeok5CqZ0l/CcrECii/wNCebUKe1xH8WbBU01WgTT8SIi7Y7rOKXEycx5+dCcSGTFSrM9XVYEs8wErCfJ97fYBB+j0kkx1KiYlKrYaqiDIoKGcvOInylG7IY0Z+C0SdP1iXFSkShLp7clJ/GfCEPa2UZFl0NptZLmOuq6RNGc232em65BWNUqzE3arG01DNZo4ayYsYKcolYvY6UvVK1TdivqLLyvbOOnBy8lZXOeFUJk7pqTM11mK7WY+7Q0f/tIXqc/Ln7eSxG215bPWbbelmDVVvBSGUp8qg4Mk4ovpv28vg4bw0ODMjvapTDY1eqsTTXYmrUYNZrMDfVMpqZzXCCnLFT6ZibaqZjJr3m7zMttRj0tZO1eUWdWo3W5dkG8erE/V6l8WrDiEVfhVGn5uklFWMN5Uw0qDFVqTCpyxjXlTOmUzGhK8dyuYKJptrJ8RvtPYA78NKzwBmjjx69MTX0uMDc3WaZaCrndlsB17W5/Fadw+9VOfRVZdOlyebna/kYLpfAjatM3rvdCRZ3q9X64vM7ttE4n3u9/qO919J+u996q75DO1WgzSG9Qk6mJh3l5Upr1/2WP4dut5VzpyeW4UGXZzP7C6k/2GzdSBujAAAAAElFTkSuQmCC",
      asTarget: true,
      uploadPath: "/offers.php?add_offer=1"
    },
    Piggo: {
      url: "https://piggo.me",
      host: "piggo.me",
      siteType: "NexusPHP",
      icon: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAYAAACNiR0NAAAACXBIWXMAAAPoAAAD6AG1e1JrAAAFRklEQVR4nHWUa1AUVBiG1xmb+pHVr/rhNEVqYolXREQLIQNHQEXDNkNIbkaQUkCQ7rrimuIFXVy2QFFguMttl+WyIAuuLjdBIYQ0NHGE1FKG5SLsBfZplmYaa+zMnDkz5zvnme98530/geA5A5gJOHS1tETqKjQqVUbur0U/nftDeSbrfl1RmV5fo000GJ6sA2Y97/5/YbNaahuczx5OipTFilIVYmlr8neSgaTovUOyGNFjxb6DPcnxkuJTcRKRJr/IG3jrf2ESiWSmYdDwaZ4sVR/vF8i2hc5snLMYb7tF/0yfdxax1d6Rnas8SD94dLDvZm9KX0fHa8CMf8EaJJKZ7bor4v1fhPcl+AeTsjuKw4HBbLFfjs+cxWycu2QavvndZYS7ridrr4gjO8PY7eU3rMzIVo4+fPj6s898eXDQIEwIjuzb5eZFoUjMA005F2Un8bFz4OPZ89nwtgOeby7A224hivBI+itLaUxTsNdXSLin70h3a3uB0Wicb4O90N5wxTk7KaXR38mdQ8Id9BxLgJLzPFAWkhYvJk2UQMbBw5yVSDknkdJRmM9kXioTeamUiURssXfkVMw+S0V2ob8N6JB5XBYZs+lzvOwWUXlAgul8Mpw/xUSzjt87r2O4ewfTw36eDtzjj5vdDPd0MZUph5Jz3Mk8wxfLP+CT95xI2SdNE3Q2NX2dHCdJ3WK/Yro+N1Jk0FLPULOOXr2e9nI1vbpLPOrqoL+9jdZSJT11Wh62NTN1vZF7OecQe/myed4SkuMktwT16upymzQ2zVlC4NLVdBcVUqf4kS/XbiBwhSuBjq4EOLvjv9aTIA9vdntsJMRlHTuWfUj6Pgmt+bnIAoLwnbeUhOCIKYEqI+9XWax4YPO8pUj9g0kX7efAjmCEi13YbPvVuUvY7uyKOCSUQ+ERfPK+E37vOeE7dymBTm5IA8PIEh+YruMen08R2BxwfE+8wSaPCz8cIXqLEOHyNQQ4uRLk7M5XKz8i2W8nV6QnqJccJXqVJ2FrPKbjPnMWEea6nqJjx9m6YAWhbl4IytIy+49FxT/eusCRZoUCRdAuDm7ahjwknIzdMRRvj6ArVMxQ/GkexCRRtS2CrF3f8FNkFImfBXAm5Eua5KcROqwk3MMXgc2bsrj9PX72jnQfT8KUl4tVVcrURQ3Wi1o4cJanO6WMBCQwEZaIMeok5CqZ0l/CcrECii/wNCebUKe1xH8WbBU01WgTT8SIi7Y7rOKXEycx5+dCcSGTFSrM9XVYEs8wErCfJ97fYBB+j0kkx1KiYlKrYaqiDIoKGcvOInylG7IY0Z+C0SdP1iXFSkShLp7clJ/GfCEPa2UZFl0NptZLmOuq6RNGc232em65BWNUqzE3arG01DNZo4ayYsYKcolYvY6UvVK1TdivqLLyvbOOnBy8lZXOeFUJk7pqTM11mK7WY+7Q0f/tIXqc/Ln7eSxG215bPWbbelmDVVvBSGUp8qg4Mk4ovpv28vg4bw0ODMjvapTDY1eqsTTXYmrUYNZrMDfVMpqZzXCCnLFT6ZibaqZjJr3m7zMttRj0tZO1eUWdWo3W5dkG8erE/V6l8WrDiEVfhVGn5uklFWMN5Uw0qDFVqTCpyxjXlTOmUzGhK8dyuYKJptrJ8RvtPYA78NKzwBmjjx69MTX0uMDc3WaZaCrndlsB17W5/Fadw+9VOfRVZdOlyebna/kYLpfAjatM3rvdCRZ3q9X64vM7ttE4n3u9/qO919J+u996q75DO1WgzSG9Qk6mJh3l5Upr1/2WP4dut5VzpyeW4UGXZzP7C6k/2GzdSBujAAAAAElFTkSuQmCC",
      asSource: true,
      asTarget: true,
      uploadPath: "/upload.php",
      seedDomSelector: "#top~table:first>tbody>tr:nth-child(5)",
      torrentDownloadLinkSelector: 'a[href*="download.php?id="]',
      search: {
        path: "/torrents.php",
        imdbOptionKey: "4",
        nameOptionKey: "0",
        params: {
          incldead: "0",
          search_area: "{optionKey}",
          search: "{imdb}",
          sort: "5",
          type: "desc"
        },
        result: {
          list: "#torrenttable>tbody>tr",
          url: '.torrentname td a[href*="details.php?id="]',
          name: '.torrentname td a[href*="details.php?id="]',
          size: "td:nth-child(5)"
        }
      },
      name: {
        selector: 'input[name="name"]'
      },
      subtitle: {
        selector: 'input[name="small_descr"]'
      },
      description: {
        selector: "#descr,#body"
      },
      imdb: {
        selector: 'input[name="url"][type="text"]'
      },
      douban: {
        selector: 'input[name="pt_gen"]'
      },
      mediaInfo: {
        selector: 'textarea[name="technical_info"]'
      },
      anonymous: {
        selector: 'input[name="uplver"]'
      },
      torrent: {
        selector: 'input[name="file"]'
      },
      tags: {
        chinese_audio: "#guoyu",
        diy: "#diy",
        cantonese_audio: "#yueyu",
        chinese_subtitle: "#zhongzi"
      },
      category: {
        selector: '#specialcat,select[name="type"]',
        map: {
          movie: "401",
          tv: "404",
          tvPack: "404",
          documentary: "402",
          concert: "406",
          sport: "407",
          cartoon: "403",
          variety: "405",
          music: "406"
        }
      },
      videoType: {
        selector: 'select[name="source_sel"]',
        map: {
          uhdbluray: "1",
          bluray: "2",
          remux: "3",
          encode: "6",
          web: "5",
          hdtv: "4",
          dvd: "7",
          dvdrip: "7",
          other: "15"
        }
      },
      area: {
        selector: 'select[name="team_sel"]',
        map: {
          CN: "1",
          US: "4",
          EU: "4",
          HK: "2",
          TW: "3",
          JP: "6",
          KR: "5",
          IND: "7",
          OT: "8"
        }
      }
    },
    PrivateHD: {
      url: "https://privatehd.to",
      host: "privatehd.to",
      siteType: "AvistaZ",
      icon: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABYAAAAWCAMAAADzapwJAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAACDVBMVEUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAQFGPyRwZTsXFQxVTS1nXTYpJRVwZTp5bT93az52aj51aj14bD9NRSgEAwIhHQ7FrlbUvF4rJhMDAwGfjUblymWPfj7RuV3jyWXiyGPgxmPfxmLLtFktJxM1LRDWt0HRskAqJA2chTDmxUaskzTPsD/Ss0B/bipwYSZ5aCnHqj7YuUJCORQ0LAzUsTDPri82LQwMCgIODAISDwOfhSTivjSojSbMqy/CoywcFwYPDQOxlSjYtTFCNw80KwnQrCbXsSe5mSGxkh+ykx/NqiXbtSiliR7JpiTAnyMbFwUPDQKwkiDWsSdBNgw0KgfQqhzYsB3Bnhu7mRq8mhrbsx6lhxbJpBvAnRobFgMQDQKxkRjXsB1CNgk1KgXVrBTSqRM8MAYSDwIVEQIYFAKigg/kuBWqiRDOphPEnhIcFgIQDQGzkBDarxRDNgY1KgPZrQzTqQwrIgIDAwCefgnpug2uiwnRpwvUqgyAZgZwWQV5YAXKoQvbrwxDNgMiGwHKoAXZrAUsIwEEAwCigATquQaSdATWqQXouAXntwbltQbltQXRpQUuJAECAQBJOQB0WwEYEgBYRQBrVAErIgBzWwB9YwF7YQF6YAF8YQFQPwD///9sRWxwAAAAE3RSTlMAD2jG8P0cpvgOpWf292nCxe3vW6icJgAAAAFiS0dErrlrk6cAAAAHdElNRQflBR0MDgqXgh1XAAABKUlEQVQY02NgYGBkYmZhFYYCVhZmJkYGIGBj5xBGARzsbAwMnFzCGICdk4GbB1OYl4+BXxgLEGAQxCYsxMAqIiomLiwsIiEpJS0jKycvL6egqMTKIKysoqomLKyuoamlraOrp6+vp2dgKMwgbGRsYgoUNjO3sLSytrGxsbWzdwAKOzo5u7i6uXt4enn7+ALN9fMPCAQKBwWHhIaFh0dERkXHxAKF4+ITEoHCSckpqWlp6ckZmVnZOUDh3Lz8AqBwYVFxSWlZeUVlVXVNLVC4rr6hESjc1NzSKizc1t7R2dXd09vb29c/YSJQeNLkKVOFhadNnzFz1uw5c+fNmztv/gJhBtaFixYvERZeuHTZ8hUrV60GgjVrp7Hi8jyOoMIRsDiiAUekYY9iAOujViqpcnSrAAAAJXRFWHRkYXRlOmNyZWF0ZQAyMDIxLTA1LTI5VDEyOjE0OjEwKzAwOjAw1eU6iAAAACV0RVh0ZGF0ZTptb2RpZnkAMjAyMS0wNS0yOVQxMjoxNDoxMCswMDowMKS4gjQAAAAASUVORK5CYII=",
      asSource: true,
      asTarget: false,
      uploadPath: "/upload.php",
      seedDomSelector: "#content-area .block:last table:first>tbody>tr:nth-child(3)",
      torrentDownloadLinkSelector: 'a[href*="/download/torrent"]',
      needDoubanInfo: true,
      search: {
        path: "/browse.php",
        params: {
          search: "{name}",
          "in": "1",
          order: "size",
          sort: "desc"
        }
      }
    },
    PuTao: {
      url: "https://pt.sjtu.edu.cn",
      host: "sjtu.edu.cn",
      siteType: "NexusPHP",
      icon: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABwAAAAdCAYAAAC5UQwxAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAABmJLR0QA/wD/AP+gvaeTAAAIP0lEQVRIx12We3BV1RXGf2ufc3OTmxcBkiAiLxHEOFqqEUlAqhaDOqVascKMWopOW6t9TbWjrf/Yqa120M5ULaMdbasdH9WqoDxFhIpKNaABoeH9JiEJ5CY3j3vvOWet/nEuEd1/7dnn8e31rW+t9YmpGQIYmIAYIEB8FG+HNlo4d4j2wMBeyGxBe5uRgSOIB5TWQGk9VjEHS03GIYXvHABiZgaKmSASI5mBSPySWYSIhxUeSHQU63gL2t5G05/ghWH8Qz9BZjCi+XAJo0p6mXpuFZx1E4z5EVZy/ukYELPI4gAcXwX+IrIQDU/gOl/B9i6FvnZwhloSERAFSQkv71nMvFvu59jhTzm7bRGpfBotH4u78C9Y1WzEwGEOG8IHQWKgwooA8Pl47T/4aNkj6GAXUpREwiJcJLgAJOVYvX04TTc9QHHZcCZNSuFyAurjetphy2LCU80gxBS7AogVeI7In0bHK4Bfdt0DTJ6/jZWn7mLbsQoo9pEoHMrqwYFZVFVV4cIdyHu3UhT0ogqmAgPdZJrvJRg8hagFJvhD9JkZKoaHw1AENxSwmGLi2NbyEaldP+G80v2Asbe9BJ35DpPGVcOWa3DtB0ASXxAlSqDCgdpf48DnzGWieFpQFA5MEUBQEIegXHzxDKqbXqVt4Bwo8Xnn8DjOm1KHa38Yju1GtaA8DSGMkBA8M8pOrsIJOnQTszhj9DYDYeF2bqgUFIPCZYZVTqD6urfJDiaZcNECtG87tvtFXCqJ84sgAA0FUYHAcIFxdkkvPri49gDEwx15Fvv4QWR0AzbxTqTyQkiOQsXDmWGaJ5/Nkszuwbc0RFV8vfwDWjfspLl5NF5yJNW6j6Zz04g4NFAcEgtTixA1M8PiTKVbCNfNxc/mMRRchKTOgeHjyXkVtGYvZWL9HYRhyNYNzzLm+OOMH97Pms6raJz/W1xRFVEExUUerRuWMOXU3ylPeJgVqqB6MmKRGk4wzaHvz8M78CHqeziNKRSNsKTy+v4Luf7ny9D215Ceo/i1syFZxZqXHuOaO5aS7Hwatj0JoWJjG9ALnqJz44PUtv8bNKbWRk453WmAw8/DO/eAJFHLYb7DCwU82NYhlH9nI+N5A9mwBCNCyko5NPGPjLtsEbbrEWTjw0SR4DwQTzlaUk/NvJdIvDUd0j2YgBt1QVx4FvbDZ09iKkQaAj5e4CAC9YUurWFEeQLZ+TLkFYIkqgGbVr8cp/7IKsiDwyGhA/Np29tKPpdBaichQSzGk5kwBpTja9FjraiCCxUXKpo3TBUXGueXdOFH/WS1Fop8JAk9mX7Kx9THDUMdSKxGDQBP6eoG9YdDlAMVUGPTyUk48mls1ysQxT+XyIjUkFAR3+OT/cKmXCNWehba8ATruyayck8ZW/07uXbhzwgPLyc/+lYygwkoA1cK7W0BpVfcRzJ/FN29GwQ6e32SY+fiW08r4cHNJCJHiOFIEEmAS3q8ty/J+NuXMbW2htL0chh2OVfev5V0x3FK/TTHV/2Clj0dzPvVGnZ2V7B5xXNUVEJdwyIaZzThrbyRqLcfG5ZgU9dEZl8xF5+2D5GBbjQCzzwUxRchG4X0T/kp1akcZSuuImrrxFWWkb7iGapcJ+++sIQxt/yVqxrKGWhfz7SZNzNt1s0Mtn1Aruck3vLrCHd9iu/7hP1GNGEhI0fWIMHq28xvWRYLxik+YOLY3a1U3d1CzdZ7sB3voSZ4xY6NWk/d/McQTTLC3w4rHoC+PhhfRzT3n8i6u3D/W4/mJW4k5RHL2idw7UOfkEgW4bzuI0ShoRbiVIkihTCkzHl4MohFxZgHnudDUYK9XQlGjptGssyHV35MeKKdsL+XaOfHHFu3BFe3gDAXN3x1OXp6ffz6+yhKJhExnOZymCoWgeUECRzkjJoiJbH1CYLZf2Rlx1g+Pyk8vaWSq29/iO79m8h37MOiAM88iBKID4cOt0HqHByCy8eMvBnO5Pr5txE3G4dzrggJfCSMLUUUGaYJJMpT8emrsO9trrx3GSMWreKHz+1j3NTL2bOzldLRF3GieBJi4JdEbN5rjJh5N70HP8IFOSSlrDk+gTl3LQXjC4uRf/275rauRiwAQMXhm0fgArzQwyWNlhFNXHT3v5C29bBnDTa+CcbNIcwc590X/0DQ30f9tT+gakQFyRe+BZkT7MiUMzD/NeqnN4KTIbfi+2MaibasBvWJUHwMjSKc83AIQRCyK3EZoz57g9pXv4eGEYPFzzNw+1tUZHYyZfoNFFfWMirzH+xvj0Kmi93ZBEdn/YmmGQ2xFbR4CMe9aOIcpGoMEil+YPEcEyOKItCQrj6P6ZdMZljnfyEynPNJZQdo2dZK7qxZVA8vp9zLsm75CiTdxZZMGQcan6LphoWxNYynN2IODBwjpiIzFuMUlMI4DsCPfMJQGOkbFUfeh7oFtPSVkR5Unkmfx/QrryeVP0TZ5t+T+vwpGhc/ytaJ3yfd9DRNNy4804cN+aMY2MwsUjr+fDXVJzZDIDgV8gbiInzzkGQJdttSemsbOXH0IBPq6kkMHEEfvxyXSXM86/h82r1cc+fvhnyRnJaJfAVXNTREyHW3s33JAi7JNiMOLPBBI0wUzPASJdi0b0BlDYd7kgybuZj8E99kQ3Y04799P1+bPR8/WRR7n4L709ijfxmwMPAxgexAH5uf/w3FLW8yI9UZJztyBZ8agRjmCTsypVT8ci0DPe2MmtJAxbBKnAmGneHeDREbAv8yYMFInXbfbXta+HDt64zs3MK57iQpy9JBgkOM5tSwOqZcejV1lzSQTKZgSIQG7iv8nRHt6fV/sz8MyW2UjeMAAAAldEVYdGRhdGU6Y3JlYXRlADIwMjEtMDktMTRUMTQ6MTc6MDMrMDA6MDDZbE3vAAAAJXRFWHRkYXRlOm1vZGlmeQAyMDIxLTA5LTE0VDE0OjE3OjAzKzAwOjAwqDH1UwAAAABJRU5ErkJggg==",
      asSource: true,
      asTarget: true,
      seedDomSelector: "h1~table:first>tbody>tr:nth-child(3)",
      torrentDownloadLinkSelector: 'a[href*="download.php?id="]',
      uploadPath: "/upload.php",
      search: {
        path: "/torrents.php",
        imdbOptionKey: "4",
        nameOptionKey: "0",
        params: {
          incldead: "0",
          search_area: "{optionKey}",
          search: "{imdb}",
          sort: "5",
          type: "desc"
        }
      },
      name: {
        selector: 'input[name="name"]'
      },
      subtitle: {
        selector: 'input[name="small_descr"]'
      },
      description: {
        selector: "#descr"
      },
      imdb: {
        selector: 'input[name="url"][type="text"]'
      },
      douban: {
        selector: 'input[name="douban_url"]'
      },
      anonymous: {
        selector: 'input[name="uplver"]'
      },
      torrent: {
        selector: "#torrent"
      },
      category: {
        selector: "#browsecat",
        map: {
          movie: [
            "401",
            "402",
            "403"
          ],
          tv: [
            "407",
            "408",
            "409",
            "410"
          ],
          tvPack: [
            "407",
            "408",
            "409",
            "410"
          ],
          documentary: "406",
          concert: "427",
          cartoon: "431",
          app: "434",
          sport: "432",
          music: [
            "420",
            "421",
            "422"
          ],
          variety: [
            "411",
            "412",
            "413",
            "414"
          ]
        }
      },
      videoCodec: {
        selector: 'select[name="codec_sel"]',
        map: {
          h264: "1",
          hevc: "10",
          x264: "1",
          x265: "10",
          h265: "10",
          mpeg2: "4",
          mpeg4: "1",
          vc1: "2",
          xvid: "3",
          dvd: "4"
        }
      },
      videoType: {
        selector: 'select[name="medium_sel"]',
        map: {
          uhdbluray: "9",
          bluray: "1",
          remux: "3",
          encode: "7",
          web: "11",
          hdtv: "5",
          dvd: "6",
          dvdrip: "7",
          hddvd: "2",
          other: "4"
        }
      },
      resolution: {
        selector: 'select[name="standard_sel"]',
        map: {
          "2160p": "6",
          "1080p": "1",
          "1080i": "2",
          "720p": "3",
          "576p": "4",
          "480p": "4"
        }
      },
      area: {
        map: {
          CN: [
            "401",
            "409",
            "411",
            "420"
          ],
          US: [
            "402",
            "410",
            "413",
            "422"
          ],
          EU: [
            "402",
            "410",
            "413",
            "422"
          ],
          HK: [
            "403",
            "407",
            "412",
            "420"
          ],
          TW: [
            "403",
            "407",
            "412",
            "420"
          ],
          JP: [
            "403",
            "408",
            "414",
            "421"
          ],
          KR: [
            "403",
            "408",
            "414",
            "421"
          ]
        }
      }
    },
    R3SUB: {
      url: "https://r3sub.com",
      host: "r3sub.com",
      siteType: "subtitles",
      icon: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAYAAACNiR0NAAAACXBIWXMAAAPoAAAD6AG1e1JrAAAEaklEQVR4nNWUe0zTVxTHf8zxcsOxyYQsLr6yzL2dj8w5kKnJfEyBgW+GmsmyCFkFUbQRBEqhlVrqWqGAkE6KOGq1pKniBItO0XYWeSjSIqwFaSn0Vyi1QOXR7/Ij6lDm/t9Jbs4v9+Z+fufc7zmHIP5Xlp+f787lcr2PHj3qIxaLp1GrvLzcRyaT+VZWVk6Xy+V+IpHIV6PRTJVIJFP+E5aSkvKKTCbdcKroVGZ+zsmzguM5ZXz+cWaO4JfDJwuKzkjK5PdLiqX6I8nJZQpF+QoAvgCmPAG7PQeTSCTeKpVqpcFgqbdYrNZeq/VRT0+P3WK1dnX39nX2WCz9pMUKkuzDX23t/SXic6qkQ8l5WUzmJutg57sAPKiA/klVInlDqayJaTf04kUbnbQDaJtboVFrbJLSshvpaRmJAPwBeI9DAXhy2Qc/yTy8WyQtznusvCCD8pIcN6ov435dPR5c08CoNWDAPjgJfLexGeyM7Pr8XN5ak8n0tsvl8iSuX69am0HfnLRtlfdwxFduoNamYC/s+vYdHNmxHFcSaFCXnkdXh3kc4gIw8gTocIzgqlLdF0+jFcvPnVtos9neIg7s+vxW3NY52h++IbA5iMCmQALhSwl894U7YjYuxv3bWjyyDWNk1IUx6glcGPdjFBlAv20AVZVqR1ryocKcHM4SYueG90xRawJsUV8TiFpJIHIFgfULCER8ORXZjHj02weepUgxxib4p9bf7wBfIDTnFxZuJfb9uDY9NjKwcMf6uW2hyzxc4csIxGz+GAXZSWhqrHt29SnI9YJgAyOAyeIAM4P9iM/n76ZE8a+6plmYsHcPI2TFvKuhwQG69KS9vbfv6CYGMcmGR4EmnWFEUXWrT35Z/SBx//4LubmCCKKjo8MbwOsPSXLmzZt/BhcIhTuYmcfExb/JzYZuO3oHBjHodMI55HQNDjldducQuu1DUNfrwWLxTBFh686yWBmxUqk0rKamZsl4h9y7d8+DJMlpbW1mf5PJNEskOh2WemBn2aHoRWClxoLDYQ9ncQW9Wcf4PdkcpjOT/j22rJ6HjesW3+Bx+bSKiorVKpVqUXNz8+zxwgbgRrWRXq/3AuAlEolXlRyLkV7JXo1yRhBo25eT0dHRp9MZqbykPSEPlbz1yIv9APRdgbeyeMKfamtrFzU1Nc1qb29/c1I/U16mUCyQFzEEF7jbH4sTl2JfZNDthARavKjgRGQabWN1BSdkTBgXBMbPYZeERb9u02q1841Go191dbXXvw4Ko9Hud74kL5xzMKo0LWbd76zkOHbJmTOhcvnFVTz2EfoJ+hYFPXrDxZSDsanKP5TBer1+NgCfl04g6gDAaw4HAvRGy/zGRu2ndXV1H+l0urkkSc40dA3NaTGYPrxz9+5nDQ0N77e2ts5oaWnxfG5AvGDUm7pTQnV1dc0wm83+drvdT6/X+1osFp/Ozs7pT/epVI1G41SCIF4Ke04oqgKov1MewKtU9NQ3VW6UiBqNxn1iqn8DP4ZZROQMmnUAAAAASUVORK5CYII=",
      asSource: false,
      asTarget: false,
      search: {
        path: "/movie.php",
        params: {
          id: "{imdb}"
        }
      }
    },
    RED: {
      url: "https://redacted.sh",
      host: "redacted.sh",
      siteType: "gazelle",
      icon: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JQAAgIMAAPn/AACA6QAAdTAAAOpgAAA6mAAAF2+SX8VGAAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAABYlAAAWJQFJUiTwAAAAB3RJTUUH5woaCDsMiZbcawAACId6VFh0UmF3IHByb2ZpbGUgdHlwZSB4bXAAAHic7V1bkqO4Ev3PVfQSsFIPWI7LwN9E3M+7/DkpsAEhQFCeGRGhcpQfICnz5FtKdzX9/6//0Z8/fx4WP8Qv7l3tKvuwbH+scVpVVlljnW1sx61SXf/z89MrheuN1XLFODa65Uq3rtKMsbVtSNfu6TDRsHvqzmiLVyzIjElKcc9d9eSXq/npaouJthVi9qEq+WxftnMs90gogBtte+GDn8ONz3DPybQMrv3IDP2ZoSpT69ZUpIS53vlLbFSH3xb8VPxggGTHDa492MhnrvmhXriq/H1WPV7lGe9JtXhR/MSlBs+YoqrgoQTe8B4gFXix/DRKa20ngOQRDjcFZO00HhU/Aap3/kd1DoNU5/l2nn4jD8+PwrPCc0vDIqp17KAlkYurAQ6SkvsTLyFHYAfKg2qUbUR2BJX2tgOL4wAIXoE2RC0cQtLPFdTxEWhNdLEG5TnqJm3iPVRiW8CtwXMlAKGESrQ6kKIjWliKI9KrwLOyr0lyJAPBgcFEI9YjcnI8UnxMFI8I0mBouoXJ/wKgbUkuJ4uUndbG2UERS6KUTlU81UHVGNMb5ZXfe0nBbbUhZwe5iNWk8yULLU2Yzkpjiy8Sxob1T/BUIQL18AIs69/BEumEplbT52ZJiTxouJKNOfabMEUoj5PWbrBHzocRiKyWyWdM8j3nTY6EXhgsPiHDWz1ChgQLA+2JfJSRRXv74m4ecMmsRYjgqxlLIRb73DLEKX9fNfzyJrEiQHMKyXwZrYdX7sb4bYeY/cCzYm20BHNEbvZRXOI3shcCv0T0aoOXcVGSVQ84GVOTHbh4rLkRZmjBjQZtjVvCU73JTXThNI56623LNXFuhBk6zU1kUWFkFbP55aP0E6Yt0biVwdxhqpiCE5+Hz3XWyfLzkfQeugfPB+KnFntiL53OBzPwxN0wQnWS16RYeQIiRiHjMSgAKpKk8jUJsiggOzFN5Q2Ujb/mvIwQl1iL2AnJVxJjPUlij/423/SZKPbN7pOSlox7AYNvRD/jJWOAoPFKAX+48yDPuAIeKWceUrigPGgFn4QffG5EoxJVrBQPId8f8jSnnyBw0WQzlIUA/dpYKB3IGgedArLJjzV0ChhiotckFnTNcgatJr5LO6jcPeLLx2YgQSJ0N1OhJRU36Em2GxOhr6yDFL0Oz9H6aKQ0lQxSx7HPLkgH8LxZWIPoRZJMW4OPIIXkyC+x645vb9w3Bjpp1XO4C/K0545HknMOCcyIIFjRMmAm5pLIYnSRF0nceIdlHqJBjSLCDd62TMDn8y8FjK4oTYT2OSc1oH5vIGDl6W4x9wr6jVtsusieW2DJh6+A9cqe/Di66hKhSdKOS0BJVjagfgs6bFG9i2hxCXn172qWffawFbXG7wqhfpYfMT7JcbsuEXrEZhg5conQI2jlEgYvCS5xMbDtGergEXTVJUKPoKsuEXJOo0aED9GG8ybXoQwPdRaMCMlECq1rnkdL17vueTt2dM7z6DvJCAulJiMUheJG4ESOgpAhW5+WjLdujS0EPEzewlph2ZKMGjkNwrNITH7hCCwb4QPPo+8kI+zXoslov3iPLrazpz3nefSdZKSw8ftKMvoYZGB8FzzvMEKmeh5NU9ZJ74znXSwiwlLQ+vMjOB9o6u3kl+KBtEVzgISFhh2skGLQtrgmJxFyt8IYiMHysKcdziF78IWtw/L4InI+I8e+vT+QDnaUtDL6KCfHUZK+UdLIJ/pGSRPa0bZ6PURsaP6psmYuT5qpVlx2YVXQzqa6Q23TVXWHAOmqukNtH0bIVGemq+oOxU9XKtiYptNT9kEape8csXBDsyOW5Ap210XOVLCxNEpXKthNjs5WsLE0Slcq2BghulLBxpIkXalgY55HqYF27qaxAxhaDEw84plB/cygsVP2CaT6E8rOJW3a9/NBvGM7ZdffKL1u3S9baV237tPfKWsC9i8ebNL2gWDKEdBEnmL0k4U/O06k8Dzx6vHmhROtGD/SO9rgJ27JqyPfjynTZMubbrDupj2lkQ7vBE9jF8DA+2FUr1j3LDZ8mxhFpjcS5kzl+bSQwEsWcGyUdlohCDYSskc/sN7uFYoIfNziJ7rgBke+PrK+Wz7owIwd9k82HQnpo3HRIkIovCea+h0w7Et67jMCwnA1PBAhJV+OjwXlrQUOoZkmjfIWYdpa4BByMEuctjMQHexT+/S8BBghMo3eCP6f3ujMEA2P33Exb/1tjaL3sDiUaRoSdOOkEniZWmtfnIoJ8Ef9/kBsQeloSpwkRRdoYgvskmzomOY8x4bfFplm0Hrw8GWX4Vs+En/C7/nEwR3sstMf//ZCiaXfPaClFYM3gXYWTM7Qot31u0JbK+a/5ugXCyWeQ94D2jmXyRzab/w/N2iHx9B3gnbYzboTtMSz2ntAO+My2UO77v8ZQvtdMZMXtMR+/z2gJR5D3wNaupXdANpVl8kS2nf8Pw9oiU2oe0BL/PrZPaClWtktoF1zmUyhfcP/c4E2YcmFo18sdPhtnztBS7Oym0C74jLZQvu9/+cDLfG7x/eAFlfMTaGlWNltoJ13mYyh/db/c4K28w+87wetNDNzhVaamZlCK83MXKGVZmau0EozM1NopZmZK7TSzMwVWmlmZgqtNDNzhVaamZlCK83MXKGVZmau0EozM1NopZmZK7TSzMwUWmlm5gqtNDNzhVaamZlCK83MXKGVZmam0EozM1dopZmZK7TSzMwUWmlm5gqtNDNzhVaamZlCK83MXKGVZmam0EozM1dopZmZK7TSzMwUWmlm5gqtNDMzhVaamblCK83MXKGVZmam0EozM1dopZmZKbTSzMwVWmlm5gqtNDMzhVaame+p/OLe1eP/e/Ajf4ZfVfK3/62W/6vGOaW4547+BpsUXSUgrfRUAAAAAW9yTlQBz6J3mgAABSFJREFUSMftl2tsFFUUgL/Znd2d2W5f2xe02wcSiwqFpAGl0BIkNhWVGASMGMHwKIH4h/jPH/zyHyEYBBNDQtHgIygEEGxJkxIICVJQKl3Ko4AF+lzodncLbVl2Z44/dgiF2EJB/nGSM7kzOfd899x7z7l3FEYXBXADucBMoAIoBQoBr2UTBNqAv4DjQCNwExgAZDTHI4kTmAR8BHzidLrGJyV5FF3XbQ6HQ1FVuyIChmFILHZPBgeHzIGBOxKL3esGdgM/Ay3AvbGANWARsMHl0ibl5eUzY8YsysvnMW3aVHw+H+npaQD09YVob79BU9NZTpw4SlNTIx0dHdy9O3gZ+BLYAww9CdgNfAp8kZWVk19ZuYDq6nVMmTKZvr4+gsEgAwMRotEoiqKgqg7cbg9ebwaZmZm0tl6mpmY7dXX76Onp6gI2AjuAO6OtqRNYDnQUFb0kGzd+I9euhcXvvyE1Nbtl2bJ1UlLyhqSleQUQRVEkOTlViotLZNGi5bJ1a42cPt0q16+HZcuWHTJxYrEA3cBqwDXaes8FWseNy5NNm76V69dvS339SVm6dLV4PKlibZYRVVU1qar6QPburZe2trBs27ZT8vMLBbgKVAH2/wJnANt1PUmqqz+XixdvycGDx2XOnMrHAh/VkpJS2bXrN7l0KSjr12+4P+gfgaxHoXbgLaBn+vRZUl9/RhoammX+/CWiKMqYwYCUlc2VQ4dOyLFjF2T27HlCIsUWACqAzQInAws9ntScmTPfIjs7l9ragxw5UovIiKk4qjQ2HufAgX243R7KK94mNS0zC1gCpA4HpwPv5+TkUVFRxfnzF2hoOEw0OvBUUADTNDh69DB+fzPl5ZXkjvcBVFosbJZOsNnsuYVFE8nN89Fy/iwt5049NfS+XLlyDv+5v0lJSaew8FVU1ZkDTAZUG4ltXqppSeLzvcat3j78/mZi8egzg0UEv99PT89NJkyYgq57BHgd0B6A9STFVzCJ7p4Al6+0jujMBawkUY72WG3XKPB/rl4mEAiQVzARTXMrwFTAqZIoGsVOp4vMjGz6ggGCvTdGdPQxsJ7EqaEAL5Moxj+MYB8OdxIK3SIjw4fD4QCYADgAxgOdHo9XysoWSlFR8agptAekFyRoaS/Ir6OmliJFRcUyq2KxeJK9AvQCuSqJzZU8MBCmqakeTdPxerOw2WzY7Tb6+yMMDo5tdyclJZGSkoppCqZpEomECAQOc/fuIIBuMfEBd1wut7w570P5asvvUnf4nJw+fU3a22/LqlVrH4pgBUjzsKibQZY9EuWaNZ9JKBST1tabcrKxTWq+a5CqqqWiaW4hcVj4VMs47vWO4933VpLvy8WlaWguHV3XUVX1oWh+stb2Heu9FvjlkYhVVUXXVXRdRxsyKSgoYPHitbS0nKKj46oBiGr5cTgcDrxeL4+TKFBj6ZOLQlp6OqrqgETJVGxj6v8/ygvwC/BzByuJh/IMrh4jysMtG2AAgXg8Rjgcfj5MBfoj/cTjcUjUasNGoiacCYUCZl3d93R1dxOPxTEMA8MwME3zfv+vgc3AHySurIOWdlvfNls2iJgYBhiGQTweo6uji/37awgGe0ygCYgqVtSliqLsdDq1V5JT0u0up1Ox222oqo1gsJdIJHwNWAH8CaSQOILvX1UNa/D9wHRgZ2pqWlFWVrY1eJNo9J5EIiEjGh26KCLVwKlhk8E0Ev88bYDJg6LfSeIITnmCWU2xbDuH9Tctn7sthg3gX0VnSK9SS2AvAAAAJXRFWHRkYXRlOmNyZWF0ZQAyMDIzLTEwLTI2VDA4OjU5OjEyKzAwOjAwW1pMhQAAACV0RVh0ZGF0ZTptb2RpZnkAMjAyMy0xMC0yNlQwODo1OToxMiswMDowMCoH9DkAAAAodEVYdGRhdGU6dGltZXN0YW1wADIwMjMtMTAtMjZUMDg6NTk6MTIrMDA6MDB9EtXmAAAAE3RFWHRkYzpmb3JtYXQAaW1hZ2UvcG5n/7kbPgAAABV0RVh0cGhvdG9zaG9wOkNvbG9yTW9kZQAzVgKzQAAAACZ0RVh0cGhvdG9zaG9wOklDQ1Byb2ZpbGUAc1JHQiBJRUM2MTk2Ni0yLjEcL2wLAAAAEHRFWHR4bXA6Q29sb3JTcGFjZQAxBQ7I0QAAACh0RVh0eG1wOkNyZWF0ZURhdGUAMjAxNi0xMS0yNFQwMzozMjoxNS0wNTowMCzxTqAAAAAudEVYdHhtcDpDcmVhdG9yVG9vbABBZG9iZSBQaG90b3Nob3AgQ0MgKE1hY2ludG9zaClYcSB0AAAAKnRFWHR4bXA6TWV0YWRhdGFEYXRlADIwMTYtMTEtMjRUMDQ6NDE6MzgtMDU6MDA4Ju9CAAAAKHRFWHR4bXA6TW9kaWZ5RGF0ZQAyMDE2LTExLTI0VDA0OjQxOjM4LTA1OjAwBIK8/AAAABZ0RVh0eG1wOlBpeGVsWERpbWVuc2lvbgAzMl01lwMAAAAWdEVYdHhtcDpQaXhlbFlEaW1lbnNpb24AMzKAo06GAAAAPnRFWHR4bXBNTTpEZXJpdmVkRnJvbQB4bXAuZGlkOmI1ZGM1Mjk4LTViZDEtNDI2ZS1hODE5LTZmZmM4OTA0ZmJhOThL8L8AAAA9dEVYdHhtcE1NOkRvY3VtZW50SUQAeG1wLmRpZDpiNWRjNTI5OC01YmQxLTQyNmUtYTgxOS02ZmZjODkwNGZiYTkCKwxvAAAAPXRFWHR4bXBNTTpJbnN0YW5jZUlEAHhtcC5paWQ6Mjc3NjNmZDAtYmM5Yi00N2FjLWFjNWItNzAxMGU0ZGE5NGY4ZKHHGQAAAEV0RVh0eG1wTU06T3JpZ2luYWxEb2N1bWVudElEAHhtcC5kaWQ6YjVkYzUyOTgtNWJkMS00MjZlLWE4MTktNmZmYzg5MDRmYmE5DvZinAAAAABJRU5ErkJggg==",
      asSource: true,
      asTarget: true,
      uploadPath: "/upload.php",
      search: {
        path: "/torrents.php",
        params: {
          searchstr: "{name}"
        }
      },
      torrent: {
        selector: "#file"
      }
    },
    SC: {
      url: "https://secret-cinema.pw",
      host: "secret-cinema.pw",
      siteType: "gazelle",
      icon: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAgCAAAAAAgK5ejAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAAAmJLR0QA/4ePzL8AAAAHdElNRQflBw0KAxGGHdK7AAAAuklEQVQoz2MUY8AHmBhGpbEAFgYGBgaGjZwYEt/9EdIauHQzijEwMDBwMWJI/P+G0P2NgYGBgaFM6lkXg2w6z5Iz2JzW8qjgYgZDw4aCGBM0pzEwMDAwPLE4upPB/eYZhgKEGDM3nHnmf1ziZ8GPVzA9xsDAwMBgsnMnw9zpAQwMsgyPsei2SxHwur/JT082+cAnVI9BgKz1nTMMDCYqK9D9TSBQS9kwJH51I3TfxKJRnQjDB3Fioqk0ADLEKO5/ENcdAAAAJXRFWHRkYXRlOmNyZWF0ZQAyMDIxLTA3LTEzVDEwOjAzOjE3KzAwOjAwgNGSrQAAACV0RVh0ZGF0ZTptb2RpZnkAMjAyMS0wNy0xM1QxMDowMzoxNyswMDowMPGMKhEAAAAASUVORK5CYII=",
      asSource: false,
      asTarget: true,
      uploadPath: "/upload.php",
      torrent: {
        selector: 'input[name="file_input"]'
      },
      search: {
        path: "/torrents.php",
        params: {
          action: "advanced",
          searchsubmit: 1,
          filter_cat: 1,
          groupname: "{name}",
          cataloguenumber: "{imdb}",
          order_by: "size",
          order_way: "desc",
          tags_type: 0
        }
      }
    },
    SSD: {
      url: "https://springsunday.net",
      host: "springsunday.net",
      siteType: "NexusPHP",
      icon: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAYAAACNiR0NAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAABmJLR0QA/wD/AP+gvaeTAAAAB3RJTUUH5QQKBjAw7XIc2AAAA6pJREFUOMt11F+o33UdBvDX8/19f2dtMk87W42tieco889GgQtBAhllobmzLBsUEiyoLrLQiXgT5J0RQU23izQk6sLdhYbbWTIxhtnUvCiqZcPtKDQw286O4M7Ozu/8vu8ufktc4Ac+F++L53m/P5/neT/xf2dyer+mu6jS26o8KD6PFn/Bz+kdZngXBspvZ2ceuAzf+2Cx5SeLlmdfIc2NeCIxGfl15PnwcXyTWod7IvN0L05cv9O5E4ff52g/SHjh6OOkWUX9AFeV3KOGf9T0kSfV8N6oH2IcR6pb1vRWXDbh+4Qbd/1CFhZUsoX6AmbIv6V3vepgWfKsqlvx5f/hOlw9vV/DyqiL7dT0Pui7cGGr5FNRnyg+ivmob0vGVbUYo0LWU+epzzW9Fad1y39vGFJfwb4WG1R3L7Ub8ziiakyyXpo9iQXSqmqLldSakk34ZLidejCsVs6WeqJV3U+jdqnqV/IC3gxV3F7V7SrNgWb+tXe7j91m9und8K+p6f1/HV4xcbh3/uwq1W2P+hF1JT6SqR17z6ZqAio5iT+HncqYOF+8FHmG/L6a5mRqODh1cA+YuvMxMkTuwEPK9zO1Y++BlK+KMdSlG0QVyUgQ3iIvFM/hb2ROvNsOx5eWm3N9ZRKnexOb7/hDcUasCVegjwaRS48f1RPi02FnuHskQt3WZXELhnhdaiFTd+51aY71uAGTiU3YhA1Ghl6L1UYNV6ItJYWkMFfM4MctvpR4+5ajD7x6bPu+t5tmg/rPa6zb2KSMYVWpcbI16roamXp9uFZsHTWttal8Q2xs8F08/vL2R29Ou0p1p2+xdsNkStcNlxa7qrnZQ3tmpXmp0hzHJDVZnKJ5uDihKBXc0ER1KTdF/crye9+h7qO+FgNp+t6cGSmq6Z0zWPgdnsK28HUsYV4iyXzJky164gzey2iH1xSTpf1nkreumX5svrioGyynv3IFOVk1PI5t1OawDs+RXybts20lr5AD0syouga3Rm3GDioli7igXBRXUiewiKERdqbkH3n96LwbP6uV3iM0y1Fder25Gg52UDeVHJFmP915NbJRsaxyVfhecVzVq3hn9tD9o2954zfa2YP3LcG1O/dJk9Swrq6yTWpjqlNpHu0P5s4MxtaIrKbbXUzgYcOld9J+SHxV1WhHiHhaeapSD6nhZwb98WOpbqm4GdfhEZpn9FY4dfD+DyPEcFglz1NvJHWs5AS+hS/WKML+RH4mXqQbzB66PP7hvxsRnTJglc+dAAAAJXRFWHRkYXRlOmNyZWF0ZQAyMDIxLTA0LTEwVDA2OjQ4OjQ4KzAwOjAwwTRopQAAACV0RVh0ZGF0ZTptb2RpZnkAMjAyMS0wNC0xMFQwNjo0ODo0OCswMDowMLBp0BkAAAAASUVORK5CYII=",
      asSource: true,
      asTarget: true,
      uploadPath: "/upload.php",
      seedDomSelector: "#top~table:first>tbody>tr:nth-child(3)",
      torrentDownloadLinkSelector: 'a[href*="download.php?id="]',
      search: {
        path: "/torrents.php",
        imdbOptionKey: "4",
        nameOptionKey: "0",
        params: {
          incldead: "0",
          search_area: "{optionKey}",
          search: "{imdb}",
          sort: "5",
          type: "desc"
        },
        result: {
          list: ".torrents>tbody>tr",
          url: '.torrentname td a[href*="details.php?id="]',
          name: '.torrentname td a[href*="details.php?id="]',
          size: "td:nth-child(6)"
        }
      },
      name: {
        selector: "#name"
      },
      subtitle: {
        selector: "#small_descr"
      },
      description: {
        selector: "#descr"
      },
      poster: "#url_poster",
      imdb: {
        selector: "#url"
      },
      anonymous: {
        selector: 'input[name="uplver"]'
      },
      torrent: {
        selector: 'input[name="file"]'
      },
      mediaInfo: {
        selector: "#Media_BDInfo"
      },
      screenshots: {
        selector: "#url_vimages"
      },
      category: {
        selector: "#browsecat",
        map: {
          movie: "501",
          tv: "502",
          tvPack: "502",
          documentary: "503",
          concert: "507",
          sport: "506",
          cartoon: "504",
          variety: "505",
          music: "508"
        }
      },
      videoCodec: {
        selector: 'select[name="codec_sel"]',
        map: {
          h264: "2",
          hevc: "1",
          x264: "2",
          x265: "1",
          h265: "1",
          mpeg2: "4",
          mpeg4: "2",
          vc1: "3",
          xvid: "",
          dvd: "4"
        }
      },
      audioCodec: {
        selector: 'select[name="audiocodec_sel"]',
        map: {
          aac: "5",
          ac3: "4",
          dd: "4",
          "dd+": "4",
          flac: "7",
          dts: "3",
          truehd: "2",
          lpcm: "6",
          dtshdma: "1",
          atmos: "3",
          dtsx: "3"
        }
      },
      videoType: {
        selector: 'select[name="medium_sel"]',
        map: {
          uhdbluray: "1",
          bluray: "1",
          remux: "4",
          encode: "6",
          web: "7",
          hdtv: "5",
          dvd: "3",
          dvdrip: "10",
          other: ""
        }
      },
      resolution: {
        selector: 'select[name="standard_sel"]',
        map: {
          "2160p": "1",
          "1080p": "2",
          "1080i": "3",
          "720p": "4",
          "576p": "5",
          "480p": "5"
        }
      },
      area: {
        selector: 'select[name="source_sel"]',
        map: {
          CN: "1",
          US: "9",
          EU: "9",
          HK: "2",
          TW: "2",
          JP: "10",
          KR: "10",
          OT: "3"
        }
      }
    },
    SoulVoice: {
      url: "https://pt.soulvoice.club",
      host: "soulvoice.club",
      siteType: "NexusPHP",
      icon: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAYAAACNiR0NAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAABmJLR0QA/wD/AP+gvaeTAAAAB3RJTUUH5QQKBzEdsHQb2wAAA2FJREFUOMut1FuIn9UVBfDf/r7/TKPJSJLGJrWJJo1WMKLgpcSoEYn4oq21gihSCvpii29qC0ZpQSKooeCDLwUvoKDWgigqiBeiBjUVNCApasTMkIpJkwzKjLnM5Vs+/D+pUEtf3LBhwz5ns85eax2+56gtO7oaTVZggOnwVcqM8Mf17Xdeuv/VC9BRg5bueLFIGcH+wcxc5weD5ib8Cp9jomQHXtn6bvd55uP2fvB9r6zXNgNdNz9W1W4gl1JrlVX4JMmtg7GRJpIJah3OLUL9VnkrXbaU2r51R9eZ2iBtK9386mrqjh7AD1F97uy6HGok8B4+wzFM9AcuL/WXyJnD5RTplqr6M27EYvwLX+JIeHMwaOaapCQmsB2jaMg27MU5VXVDKo1mCWzskX2FN3AQJ2C3+EcXmgrV1LTksR7dydRp5DXsJOeLZRa+oNRGfIHnsABn4Wji8ag9Cc1tFzQIjdcj9/bE/Iy6XPJ+4k0MspQk40me7wddiFk8ikcamfvDprc0cNvPW2FO1cPkN3gI46p+Qh2iaUysX4R9qpbiKJ4Jvwt3ah2MDFf9bX3d9/asZF7TjIyoGitaVSvE2Pz0VVPlwOKq+siQySmdo4rbN739H2H/L8Vfc+uoE9f+3uTev5+0csWqJZt/MTmindlzeHrBlyvXHlALDn63U74prtt8CtLQnFJVF+E0HEmy/7jRbttDN9UynEctxwx2hndqduZQjl+oXb6boUS4fvMalbal+WVVPY2HcYs4A4cfearZU2U8jPRk3IWni78aGT275mZ1e1cPB163eY3R0U4ql1TVvTgXB/C88qOqusxkVeIE6ooMey9jHr/GPemcnKL7cPUQ4bGZZnGVm4dy8VmS7Tgbl2L3ow/oovYVh4urw6LIG5jGpuLa6tJY2D+5yrreBdNJ/l1Vl/Ra+zDx4ksfUDGNv+FIcXGp0zN000C5MuXEVAyaZiCZ24BlmKuqdf1X9s/En7pkVyEV1HPFqbgFa2uoRzhD1enY33SZXYjze+YmsQsPJm6UPNuU7qkt49qVEyTTSbYmbsaTvVUncRzOK626/q41Y4mNkhb7sa/PY09uGf8vnc3u/akobc2N4cdiObW8yj7mtw9YNlXlBcUTd7/r/8XIqk+/Kaf6/Pjb/a8BRYVt72oJuZAAAAAldEVYdGRhdGU6Y3JlYXRlADIwMjEtMDQtMTBUMDc6NDk6MjkrMDA6MDCTeNgtAAAAJXRFWHRkYXRlOm1vZGlmeQAyMDIxLTA0LTEwVDA3OjQ5OjI5KzAwOjAw4iVgkQAAAABJRU5ErkJggg==",
      asSource: true,
      asTarget: true,
      uploadPath: "/upload.php",
      seedDomSelector: "#top~table:first>tbody>tr:nth-child(3)",
      torrentDownloadLinkSelector: 'a[href*="download.php?id="]',
      needDoubanBookInfo: true,
      search: {
        path: "/torrents.php",
        imdbOptionKey: "4",
        nameOptionKey: "0",
        params: {
          incldead: "0",
          search_area: "{optionKey}",
          search: "{imdb}",
          sort: "5",
          type: "desc"
        },
        result: {
          list: ".torrents>tbody>tr",
          url: '.torrentname td a[href*="details.php?id="]',
          name: '.torrentname td a[href*="details.php?id="]',
          size: "td:nth-child(5)"
        }
      },
      name: {
        selector: "#name"
      },
      subtitle: {
        selector: 'input[name="small_descr"]'
      },
      description: {
        selector: "#descr"
      },
      imdb: {
        selector: 'input[name="url"][type="text"]'
      },
      anonymous: {
        selector: 'input[name="uplver"]'
      },
      torrent: {
        selector: 'input[name="file"]'
      },
      category: {
        selector: "#browsecat",
        map: {
          movie: "401",
          tv: "402",
          tvPack: "402",
          documentary: "404",
          cartoon: "405",
          sport: "407",
          concert: "406",
          variety: "403",
          music: "408"
        }
      },
      videoCodec: {
        selector: 'select[name="codec_sel"]',
        map: {
          h264: "1",
          hevc: "2",
          h265: "2",
          x264: "1",
          x265: "2",
          mpeg2: "5",
          mpeg4: "1",
          vc1: "5",
          xvid: "5"
        }
      },
      resolution: {
        selector: 'select[name="standard_sel"]',
        map: {
          "2160p": "3",
          "1080p": "1",
          "1080i": "2",
          "720p": "4",
          "576p": "4",
          "480p": "4"
        }
      },
      team: {
        selector: 'select[name="team_sel"]',
        map: {
          hds: "1",
          chd: "2",
          frds: "3",
          cmct: "4",
          other: "5"
        }
      }
    },
    SpeedApp: {
      url: "https://speedapp.io",
      host: "speedapp.io",
      siteType: "SpeedApp",
      icon: "data:image/x-icon;base64,AAABAAEAICAAAAEAIACoEAAAFgAAACgAAAAgAAAAQAAAAAEAIAAAAAAAABAAABMLAAATCwAAAAAAAAAAAACdnZ0Ao6OjA01NTXwuLi7HAAAA8QAAAOsAAADqAAAA6gAAAOoAAADqAAAA6gAAAOoAAADqAAAA6gAAAOoAAADqAAAA6gAAAOoAAADqAAAA6gAAAOoAAADqAAAA6gAAAOoAAADqAAAA6gAAAOsAAADyLCwsyU5OTnujo6MDnZ2dAJiYmAw2NjbLAAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/zY2NsuYmJgMRkZGkAAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/0ZGRpARERHjAAAA/wAAAP8AAwT/AB4p/wAhK/8AHyn/AB8p/wAfKf8AHyn/AB8p/wAfKf8AHyj/ACQs/wARFv8AGiD/ACUu/wAeKP8AHyn/AB8p/wAfKf8AHyn/AB8p/wAfKf8AHyn/AB8o/wAiLP8AHCX/AAAA/wAAAP8AAAD/ERER4wAAAPAAAAD/AAAA/wAtNf8A2f//ANH//wDK//8Ayv//AMr//wDK//8Ayv//AMr//wDJ//8A2P//AKLM/wCkzf8A7f//AMf//wDJ//8Ayv//AMr//wDK//8Ayv//AMr//wDK//8Ayf//ANb//wDM/f8AHCX/AAAA/wAAAP8AAADwAgIC7QAAAP8AAAD/ADQ8/wDj//8A1v//AND//wDQ//8A0P//AND//wDQ//8A0P//AM///wDR//8A9///AG+M/wCXuP8A+P//AM3//wDQ//8A0P//AND//wDQ//8A0P//AND//wDP//8A2///ANb//wAiLf8AAAD/AAAA/wICAu0DAwPsAAAA/wAAAP8AMDf/ANX//wDK//8AxP//AMT//wDE//8AxP//AMT//wDE//8AxP//AO///wCbuP8AAAD/AAAA/wCv0/8A6///AMH//wDE//8AxP//AMT//wDE//8AxP//AMP//wDP//8Ayf//AB8p/wAAAP8AAAD/AwMD7AMDA+wAAAD/AAAA/wAwN/8A1v//AMv//wDF//8Axf//AMX//wDF//8Axf//AMf//wDX//8AgZn/AAAA/wAAAP8AAAD/AAUJ/wCVtP8A2P//AMb//wDF//8Axf//AMX//wDF//8AxP//AND//wDK//8AHyn/AAAA/wAAAP8DAwPsAwMD7AAAAP8AAAD/ADA3/wDW//8Ay///AMX//wDF//8Axf//AMX//wDF//8Ayf//AN7//wA/Vv8AAAD/AAAA/wAAAP8AAAD/AFt1/wDj//8Ax///AMX//wDF//8Axf//AMX//wDE//8A0P//AMr//wAfKf8AAAD/AAAA/wMDA+wDAwPsAAAA/wAAAP8AMDf/ANb//wDL//8Axf//AMX//wDF//8Axf//AMX//wDE//8Azv//AN///wBKYP8AAAD/AAAA/wBief8A4///AMn//wDE//8Axf//AMX//wDF//8Axf//AMT//wDQ//8Ayv//AB8p/wAAAP8AAAD/AwMD7AMDA+wAAAD/AAAA/wAwN/8A1v//AMv//wDF//8Axf//AMX//wDF//8Axf//AMX//wDB//8A1f//AOz//wA1Q/8AR1n/AO7//wDQ//8Awv//AMX//wDF//8Axf//AMX//wDF//8AxP//AND//wDK//8AHyn/AAAA/wAAAP8DAwPsAwMD7AAAAP8AAAD/ADA3/wDW//8Ay///AMT//wDG//8Axv//AMT//wDF//8Axf//AMP//wDR//8Avef/AJ3J/wDW//8Az///AMH//wDF//8Axf//AMX//wDE//8Axv//AMb//wDD//8A0P//AMr//wAfKf8AAAD/AAAA/wMDA+wDAwPsAAAA/wAAAP8AMDf/ANb//wDK//8Aw///ANz//wDf//8Ax///AML//wDD//8A1f//ALfg/wCCqP8Ax/P/ANL//wDC//8Axf//AMX//wDF//8Awv//AMn//wDg//8A2P//AMH//wDP//8Ayv//AB8p/wAAAP8AAAD/AwMD7AMDA+wAAAD/AAAA/wA1PP8A3///AMr//wDu//8AfJn/AGmA/wDr//8Ayf//ANL//wC34f8Agqj/AMPv/wDR//8Aw///AMX//wDF//8Axf//AMH//wDR//8A4v//AGB4/wCTtf8A7P//AM3//wDJ//8AHyn/AAAA/wAAAP8DAwPsAwMD7AAAAP8AAAD/ACIo/wDA6v8A+///AJy3/wAAAP8AAAD/AHeN/wD8//8At+P/AIGn/wDD7/8A0f//AMP//wDF//8Axf//AMX//wDC//8A0P//AO///wBkev8AAAD/AAUH/wCv0/8A+P//AMf//wAeKP8AAAD/AAAA/wMDA+wBAQHsAAAA/wAAAP8AKjP/AKnO/wBsgv8AAAD/AAAA/wAAAP8AAAD/AFVi/wCgy/8AxO7/ANH//wDD//8Axf//AMX//wDF//8Awv//ANP//wDX+v8ARVj/AAAA/wAAAP8AAAD/AAAB/wCatP8A7P//ACMu/wAAAP8AAAD/AQEB7AAAAOwAAAD/AAAA/wA4Q/8A8///AGd+/wAAAP8AAAD/AAAA/wAAAP8AQ1j/ANv//wDS//8Awv//AMX//wDF//8Axf//AMP//wDR//8Ax+//AJ/L/wAwQf8AAAD/AAAA/wAAAP8AAAD/AG+I/wCoyf8AHiX/AAAA/wAAAP8AAADsAwMD7AAAAP8AAAD/AC02/wDa//8A+P//AICW/wAAAP8AAAD/AGR6/wDt//8Az///AML//wDF//8Axf//AMX//wDD//8A0f//AMLu/wCAp/8Avur/AO7//wBMYf8AAAD/AAAA/wCbuf8A9v//AKXQ/wAWHP8AAAD/AAAA/wMDA+wDAwPsAAAA/wAAAP8AMDj/ANT//wDP//8A7///AGd9/wBTZ/8A6P//AND//wDB//8Axf//AMX//wDF//8Aw///ANH//wDD7/8Agaf/ALfg/wDR//8A1f//AN3//wBHWv8Afpv/AO7//wDR//8A1///ACIs/wAAAP8AAAD/AwMD7AMDA+wAAAD/AAAA/wAwOP8A1v//AMn//wDH//8A2f//ANv//wDL//8Awv//AMX//wDF//8Axf//AML//wDS//8AxPH/AICn/wC24f8A1f//AMP//wDB//8Azv//ANz//wDY//8AxP//AM///wDJ//8AHyn/AAAA/wAAAP8DAwPsAwMD7AAAAP8AAAD/ADA4/wDW//8Ay///AMT//wDI//8AyP//AMT//wDF//8Axf//AMX//wDB//8Az///ANj//wCeyP8At+P/ANL//wDD//8Axf//AMX//wDE//8Ayf//AMf//wDD//8A0P//AMr//wAfKf8AAAD/AAAA/wMDA+wDAwPsAAAA/wAAAP8AMDj/ANb//wDL//8Axf//AMX//wDF//8Axf//AMX//wDF//8Awf//AND//wDt//8ARVj/AFVl/wD7//8Ayf//AMP//wDF//8Axf//AMX//wDF//8Axf//AMT//wDQ//8Ayv//AB8p/wAAAP8AAAD/AwMD7AMDA+wAAAD/AAAA/wAwOP8A1v//AMv//wDF//8Axf//AMX//wDF//8Axf//AMP//wDL//8A6f//AGJ5/wAAAP8AAAD/AHWL/wDr//8Ax///AMT//wDF//8Axf//AMX//wDF//8AxP//AND//wDK//8AHyn/AAAA/wAAAP8DAwPsAwMD7AAAAP8AAAD/ADA4/wDW//8Ay///AMX//wDF//8Axf//AMX//wDF//8Ayf//ANz//wBNZf8AAAD/AAAA/wAAAP8AAAD/AGd//wDh//8Axv//AMX//wDF//8Axf//AMX//wDE//8A0P//AMr//wAfKf8AAAD/AAAA/wMDA+wDAwPsAAAA/wAAAP8AMDj/ANb//wDL//8Axf//AMX//wDF//8Axf//AMX//wDI//8A2v//AGd8/wAAAP8AAAD/AAAA/wAAAP8Afpj/ANz//wDG//8Axf//AMX//wDF//8Axf//AMT//wDQ//8Ayv//AB8p/wAAAP8AAAD/AwMD7AMDA+wAAAD/AAAA/wAwOP8A1v//AMv//wDF//8Axf//AMX//wDF//8Axf//AMT//wDH//8A8P//AH6V/wAAAP8AAAD/AJe0/wDu//8Aw///AMT//wDF//8Axf//AMX//wDF//8AxP//AND//wDK//8AHyn/AAAA/wAAAP8DAwPsAwMD7QAAAP8AAAD/ADM7/wDd//8A0f//AMv//wDL//8Ay///AMv//wDL//8Ay///AMn//wDP//8A9///AGV+/wBogf8A/f//AMr//wDK//8Ay///AMv//wDL//8Ay///AMv//wDK//8A1v//ANH//wAhLP8AAAD/AAAA/wMDA+0AAADwAAAA/wAAAP8AMTn/AOf//wDe//8A1v//ANb//wDW//8A1v//ANb//wDW//8A1v//ANT//wDa//8A9P//AKTK/wC76P8A4f//ANb//wDW//8A1v//ANb//wDW//8A1v//ANX//wDj//8A2f//AB4o/wAAAP8AAAD/AAAA8AcHB+UAAAD/AAAA/wAHCf8AMTn/ADM6/wAwN/8AMDf/ADA3/wAwN/8AMDf/ADA3/wAwN/8AMDf/AC43/wA5QP8AKDL/ACAo/wA1Ov8ALzf/ADA3/wAwN/8AMDf/ADA3/wAwN/8ALzf/ADQ7/wAuNv8AAwT/AAAA/wAAAP8HBwflVVVVowAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/1VVVaOqqqobERER6gAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8RERHqqqqqG6GhoQBeXl4dNzc3nA4ODuIAAADxAAAA7AAAAOwAAADsAAAA7AAAAOwAAADsAAAA7AAAAOwAAADsAAAA7AAAAOwAAADsAAAA7AAAAOwAAADsAAAA7AAAAOwAAADsAAAA7AAAAOwAAADsAAAA7AAAAPENDQ3iNzc3nF5eXh2hoaEAgAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIAAAAE=",
      asSource: true,
      asTarget: true,
      seedDomSelector: "div.row.d-sm-none + div + div",
      uploadPath: "/upload",
      needDoubanInfo: false,
      search: {
        path: "/browse",
        imdbOptionKey: "4",
        nameOptionKey: "0",
        params: {
          search_area: "{optionKey}",
          search: "{imdb}"
        }
      },
      name: {
        selector: "#name"
      },
      description: {
        selector: "#torrentDescription_releaseInfo"
      },
      imdb: {
        selector: "#url"
      },
      mediaInfo: {
        selector: "#torrentDescription_mediaInfo"
      },
      bdinfo: {
        selector: "#torrentDescription_bdInfo"
      },
      screenshots: {
        selector: "#torrentDescription_screenshots"
      }
    },
    SubHD: {
      url: "https://subhd.tv",
      host: "subhd.tv",
      siteType: "subtitles",
      category: [
        "subtitles"
      ],
      icon: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAsAAAALCAMAAACecocUAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAA5FBMVEUAie0Aie4AiO0Lje4wn/FBpvIsnfAIjO4mmvCo1vnb7vzc7vzc7/yd0fgcle8Fi+6j1PjR6ftNrPMzoPFktvTk8v2Py/cBie4Tke/V6/wHi+4Ahe0Bh+1etPRwvfUGjO4HjO6h0/j1+v5kt/QNj+4ble9/w/bJ5vvo9P3q9f3B4vpRrvMSke8PkO5lt/TP6PvY7Pwfl+8Ah+0om/C94PpQrfMAhu0AhO1suvUvnvEQkO+/4frM5/tMrPPF5Pu+4PoAiO44ovG84Prg8Pze7/y33fo1ofERkO82ovFFqfIPj+7///92Ih8bAAAAAXRSTlPpmTCCugAAAAFiS0dES2kLhVAAAAAHdElNRQflBgQEKCzi8yjzAAAAgUlEQVQI1xXK5xbBQBRF4TtHlAgG0YPoojMEiRYtyvs/kOvft9faRAIRLRqLQxAzoSeNVDrDAZnN5c1CsVQGoVLVa1a90bTZrXZH75o98CPQHwyd0Xjyf+RUzrT5YrlSpNYb19ru9o6nCP7h6Hqn88UHBbje7sbjGSIgjtf7E36ZP28ZDcGwKhEtAAAAJXRFWHRkYXRlOmNyZWF0ZQAyMDIxLTA2LTA0VDA0OjQwOjQ0KzAwOjAwUjx2WwAAACV0RVh0ZGF0ZTptb2RpZnkAMjAyMS0wNi0wNFQwNDo0MDo0NCswMDowMCNhzucAAAAASUVORK5CYII=",
      asSource: false,
      asTarget: false,
      search: {
        path: "/search/{name}"
      }
    },
    TCCF: {
      url: "https://et8.org",
      host: "et8.org",
      siteType: "NexusPHP",
      icon: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAYAAACNiR0NAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAABmJLR0QA/wD/AP+gvaeTAAAAB3RJTUUH5QQKBzILb439SQAABFZJREFUOMuV1MlvVVUcB/DvuecO597XN7Slw6ulLdQCEqcAQQZBIzEhLnRDjNFo4tqd/4BxZ3RhjAtNTIzGGAwKYnAgBEVaEgQBGxFf6SvQuX19452Hc+69LupAE2Lgm5ztJ998T/IjPX19qCwuYuSxvXTvtkc3M017RtGNrsB1T0yNX75U6O4Jvv7qS9xtZNdsgUnYKjK5g9eyfU91bnlkqE1W1eXRU4NVR3y0AuvHu9YAyMe/+yH/8TffH8r2D76SFDdunEGezDV5avJMf1QYupRk8vcGakzPFDeO7Bl8YOuwUrwflSszmLi5AGGLWEoldeXEB7kikI+BJAKScPXFCcABWADSNaAfBr5tNhuWaQrFaNHEMTlfmXXjxdI4cWYTaeeTzwZIN1ACoUskLFAaaVQKFQmNqNW4GNSry7KR4TcnSqvg6M9nrXPHjx/d/MTTvay9tKM6US7L1//8SY6DznD744eSLTsG3XwXzUpJmlcIiqqU9ioEGc+0fz/y6bd1x36fZdom/2343ttvxYHrnukc2TqXCUVHbFbohoF1L287+Nx2OrCpr0qY4VEVSBJIaYIMlVCgBKSpZfO9Q/sloh5WmDGJy7+ugrbrAkBj7MhnFw+99jr09f19iqq+sfvhB4fWD2+Sm14AJxLweQJPxFi0AqzUPYS1SAqDuC1OoBDx34zy7YNqjEEIAU1V074Mw3BWQ0sG3CiGGQoEIkG14WN+tgJvatJuVatjYbOyQjXjzmCrZYILkTBNdZyQCzuKZTuMYYUcC3YI0+eYr7qozi+kXulirTlb/nypPD6dK3TcGTQtC0KINNQ0x4+EcHkMlwu0QoFS3cGF8XnM3KjBr4ckpus7IV3f193dWZZY+7QsU9Rr1bWgbdvgnCdM112PC+FEAhU3wpwdIKfKyLQbiAhgOjEkqSOndu98EYQtRxNnj5GcsQwA9HYw19uPwPcNpOn+7Xv2bTLaO43ysoVz11eQzzCougqbx2hYIbgnJMisIFOyjrblWvWF8g2NIFrTMLQtRGGQSLEwzYBHVhijagX4rbQEYZu4b7AHxf4O1JwISwEHdyRCM/275IQ3ugdG5lLKzqxpaBgM3LVkinRwYNvuh8CMrkrDSf+4Nh01pkoWZQq0QlYGU0lLJIhtn4hEh5z4Xboch9RoP7UGlCQJbrMeS7K86Hn+UM20B5uNGmlcHb0a3LryYezWWaSwIjqLChSauj4nSSCgRi5TpGQGStvRNWDo+0iSNAWRXIXpkyEXl9xm7bS3NHPYny2Ncd+dSvW2Dp6SLVFuHfwUJDVdqK05W3OnzyP2T67Z8J/4thmXL4xN4MLYrb8/zgMA1Kt10tFryAnRY54eSFNdUv2ZGnUWTqZe5VhKlITi/xNj9UwBABgQN+duLOjZQkVlTNc1VmeL46fprV8+2XXw+dHzJ78AuZfjmc3lYJkm3nznXbXY29OTb8sMe54/8epLLywTQkApxV987U+PhqXfyQAAACV0RVh0ZGF0ZTpjcmVhdGUAMjAyMS0wNC0xMFQwNzo1MDoxMSswMDowMBODZaMAAAAldEVYdGRhdGU6bW9kaWZ5ADIwMjEtMDQtMTBUMDc6NTA6MTErMDA6MDBi3t0fAAAAAElFTkSuQmCC",
      asSource: true,
      asTarget: true,
      seedDomSelector: "#top~table:first>tbody>tr:nth-child(3)",
      torrentDownloadLinkSelector: 'a[href*="download.php?id="]',
      uploadPath: "/upload.php",
      search: {
        path: "/torrents.php",
        imdbOptionKey: "4",
        nameOptionKey: "0",
        params: {
          incldead: "0",
          search_area: "{optionKey}",
          search: "{imdb}",
          sort: "5",
          type: "desc"
        },
        result: {
          list: ".torrents>tbody>tr",
          url: '.torrentname td a[href*="details.php?id="]',
          name: '.torrentname td a[href*="details.php?id="]',
          size: "td:nth-child(5)"
        }
      },
      name: {
        selector: "#name"
      },
      subtitle: {
        selector: 'input[name="small_descr"]'
      },
      description: {
        selector: "#descr"
      },
      imdb: {
        selector: 'input[name="url"][type="text"]'
      },
      anonymous: {
        selector: 'input[name="uplver"]'
      },
      torrent: {
        selector: 'input[name="file"]'
      },
      category: {
        selector: "#browsecat",
        map: {
          movie: "622",
          tv: "623",
          tvPack: "623",
          documentary: "404",
          concert: "626",
          sport: "627",
          cartoon: "627",
          variety: "627",
          app: "625",
          ebook: "629",
          magazine: "631",
          comics: "632",
          audioBook: "633",
          onlineCourse: "634"
        }
      },
      videoCodec: {
        selector: 'select[name="codec_sel"]',
        map: {
          h264: "1",
          x264: "7",
          hevc: "8",
          x265: "6",
          h265: "8",
          mpeg2: "4",
          mpeg4: "1",
          vc1: "2",
          xvid: "3",
          dvd: "4"
        }
      },
      audioCodec: {
        selector: 'select[name="audiocodec_sel"]',
        map: {
          aac: "6",
          ac3: "4",
          dd: "4",
          "dd+": "4",
          flac: "1",
          dts: "3",
          truehd: "9",
          lpcm: "10",
          dtshdma: "8",
          atmos: "8",
          dtsx: "3"
        }
      },
      videoType: {
        selector: 'select[name="medium_sel"]',
        map: {
          uhdbluray: "10",
          bluray: "1",
          remux: "5",
          encode: "11",
          web: "9",
          hdtv: "6",
          dvd: "7",
          dvdrip: "4",
          other: "0"
        }
      },
      resolution: {
        selector: 'select[name="standard_sel"]',
        map: {
          "2160p": "5",
          "1080p": "1",
          "1080i": "2",
          "720p": "3",
          "576p": "4",
          "480p": "4"
        }
      },
      team: {
        selector: 'select[name="team_sel"]',
        map: {
          torrentccf: "1",
          tccf: "1",
          tlf: "2",
          bmdru: "3",
          catedu: "4",
          madfox: "5",
          other: "7"
        }
      }
    },
    TJUPT: {
      url: "https://www.tjupt.org",
      host: "tjupt.org",
      siteType: "NexusPHP",
      icon: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAYAAACNiR0NAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAABmJLR0QA/wD/AP+gvaeTAAAAB3RJTUUH5QQKBykVPLQLsAAABCVJREFUOMuVlctvVVUYxX97n3PPvb0t0BZKSKW0FdpSDCAkViMmjU9kAImaMDVGnOo/4IApGo0xccLQmYkgJhhfCSA4sgUJjz5JsbVwS/q6lN7bc/brc3AanGiiO9mjb+1k7d/KXlvxP9ax04tsfyKmMucatGYrsAysnHln82ON+rfDB967RXU+Zc/hroZSSTeXErVNKfq0Ym8cq6cizQ7rZKyeyYdxxFQ9Fc69u5kYYLxi8Q4aSiq5Mp2VhmZse93SGxS7g7BHK/qiiO44Ui1xRBxppZUC6+TpWMvVjw4WP/n6QeAcoE58s8xCVXZtKKmXTwyUD+/cHHWlTppTK80La7Lxh8ksWloLaKUoFWCwK+HJlhgBRIRI8WtXS3S8oFWlIdHElYWwt6msT0UFdeTStGEpjTnSWySJQIBqKpwfz/AiiFWMzjs2FTWD3QUmFz0/T2StFzxxMcrpxcAhYJ8XmJh3LNQCg90J09VAZ3PEoc4CN+Ys4wsOreBmxZFZ2L8t5uo9y6W7ZkOtJluBPwG0dVzNrCxlRjAOjBVEYHjWMjRr2VLWvNidUECRGcE6wTjBeGGpFgieFgV9CnjliwW0MWHEmjBjTMCagLUCwKO1wPmRlPlVz0BHgYPtMcYEjBXcusYHwXtpEpE9v99ew3tBX3x/S81YGXEu4HzA+wDrwEcrhh/HUwoaXu8t0lZWWJtrRCB4wftACNK/qzPZGIKgj56ex1q5YYxYawRrBRHBeyHNhJ9GUkYfOHraYl7aVUS84JyAgPe52+ClVylpQQT9qBbwPoxZEx46G3A2dxg8eBe4v+w4c61O3QRe6yuye0uMMYIA3gnWBLwLHRJkByLoNBMyIxVj5K5ZZygCzkvOzAhXJte4OJbS2hjxxv4GmhIIQXKNDTgnjc5Jf6wCsXMQhCpaJpSSZx4Dd4I1gkJYyeCroRr7ticMdBWp1sPfmkxQSmIvau9vS41o74VStlZzVkZsFoIxOXDvBJMFjMkxjM4azg7XiDS82l9iY0njbH5lawLehv7u0mqLvn6ynVUSrJMxa+WRMzlw5/OArMl3lga+HV5leCqjIdEkETgnmPW5s7IteGnXkKflvUxYK8utZU0hgnKs8OshORvwLlBZcnx5eYVq3aOUwjtZnwvOyR8SWIwBerYWKBfV7As9xeXne0pdm8qa48810dEa8fn3Ve4vO7TK3+rlkTX57lotvPVsky4X9YzzXItidV0JZ0Pq52KAYwfKbGiMaosP7egvt+sHLt6s5Q6CSGokeE8mmorSTNaMjF0YSWfeHGgqHT3YePnkmepQT2diAZn8uD0v2Ia3p+hrU9xbkcGCklME2kQxh2IyKeibkeIWSk2pSC8prR4iuDufdvxjMT9u7O4PpkGhEXYi0opS0yjmAX/3s87//E38BWXDuj9j0ViVAAAAJXRFWHRkYXRlOmNyZWF0ZQAyMDIxLTA0LTEwVDA3OjQxOjIxKzAwOjAws0DWvgAAACV0RVh0ZGF0ZTptb2RpZnkAMjAyMS0wNC0xMFQwNzo0MToyMSswMDowMMIdbgIAAAAASUVORK5CYII=",
      asSource: true,
      asTarget: true,
      uploadPath: "/upload.php",
      seedDomSelector: "#top~table:first>tbody>tr:nth-child(5)",
      torrentDownloadLinkSelector: 'a[href*="download.php?id="]',
      search: {
        path: "/torrents.php",
        imdbOptionKey: "4",
        nameOptionKey: "0",
        params: {
          incldead: "0",
          search_area: "{optionKey}",
          search: "{imdb}",
          sort: "5",
          type: "desc"
        },
        result: {
          list: ".torrents>tbody>tr",
          url: '.torrentname td a[href*="details.php?id="]',
          name: '.torrentname td a[href*="details.php?id="]',
          size: "td:nth-child(5)"
        }
      },
      torrent: {
        selector: 'input[name="file"]'
      },
      subtitle: {
        selector: 'input[name="small_descr"]'
      },
      description: {
        selector: "#descr"
      },
      imdb: {
        selector: 'input[name="url"][type="text"]'
      },
      douban: {
        selector: "#external_url"
      },
      category: {
        selector: "#browsecat",
        map: {
          movie: "401",
          tv: "402",
          tvPack: "402",
          documentary: "411",
          concert: "406",
          sport: "407",
          cartoon: "405",
          variety: "403",
          music: "406"
        }
      }
    },
    TLF: {
      url: "https://pt.eastgame.org",
      host: "eastgame.org",
      siteType: "NexusPHP",
      icon: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAYAAACNiR0NAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAABmJLR0QA/wD/AP+gvaeTAAAAB3RJTUUH5QQKBzMtpJtJ9QAAArNJREFUOMuVk7+OHEUQh7+q7umZm929s2wJjCAhQESEPAIJgXMewvIrOPSDIJEREPAEZEiIiMTZSZjDt3vr3Z2d/93lYJa7PVsW65J6unvU9fXv19Ut3724dIuZY1E6Ls6UhwvhwcxxMRMezRyfzD2PSsUrNNFY70eW25F1PbJpI3Ub6YbEy8stv/1xhQd+BhCm+K83jkMO37u/drToeK0fkj0ZkxGTMSZjsCnfC6iAYUQz1CCmKVWdkB2aV8gUvAJi+H0TUTEEw1DUKcELmZtsqkybZQp9NKou0vSJYUikmEgpEWNkHEfiMOA3q46uVupSqUqlrh1VM7IsHRelcH4mzAPkqiSMbjTaPtH3I+2YGMbErh5YrmraTY1fX3dkORRnSlEI60KYlcq8cJS5UuSQe6Hwgvc2HYNBNANLiMLrVc3VPxu6N3t8W7fEHmIn9LnS50JfC22uFEHJg5BlQghCnkHmBe8EVRA1khnXr3esrt4QuxafYnyeEKKASCKijCI6kH6QJF+RFDMBBEGnWhsvMyc/iZCGMdE2PV3dYzHe3pLb+PbZ7wDO4Bfv+b4ISsgnpSEoIRO88qvBEyD++PSbe/n+XWAId3t4LxMog5AJwUN2sPuheA9Y5BPQbAKGI2WZV8wS3ZDet/YhYB6OgJmSH2BOYVe1rK53VNsWETkNKGKHHlKM1PuBbT/Q1B03y4r1akfX9Kcr/PfV9nacYqTvBup9S7VtqDY1cejvven/Bf7156ujWQKLmEVICWycHFg6HWgp3gMaCbEExAlkET5GIXoEFHBOcV4AJXYQ+4jFj1Ao7q7KIVfK85zZPGCSaHYN1bqia1vgxCq7oAfrUJ7nfP7FBY8/XeA83CwrLi9hdWO316Y7HWjM5jmfPV7w9ZcPKIPj70WgaRqarkd1Au7eyX8L7wlhtfLjAQYAAAAldEVYdGRhdGU6Y3JlYXRlADIwMjEtMDQtMTBUMDc6NTE6NDUrMDA6MDBA7iTqAAAAJXRFWHRkYXRlOm1vZGlmeQAyMDIxLTA0LTEwVDA3OjUxOjQ1KzAwOjAwMbOcVgAAAABJRU5ErkJggg==",
      asSource: true,
      asTarget: true,
      seedDomSelector: "#top~table:first>tbody>tr:nth-child(3)",
      torrentDownloadLinkSelector: 'a[href*="download.php?id="]',
      uploadPath: "/upload.php",
      search: {
        path: "/torrents.php",
        imdbOptionKey: "4",
        nameOptionKey: "0",
        params: {
          incldead: "0",
          search_area: "{optionKey}",
          search: "{imdb}",
          sort: "5",
          type: "desc"
        },
        result: {
          list: ".torrents>tbody>tr",
          url: '.torrentname td a[href*="details.php?id="]',
          name: '.torrentname td a[href*="details.php?id="]',
          size: "td:nth-child(5)"
        }
      },
      name: {
        selector: "#name"
      },
      subtitle: {
        selector: 'input[name="small_descr"]'
      },
      description: {
        selector: 'textarea[name="descr"]'
      },
      imdb: {
        selector: 'input[name="url"][type="text"]'
      },
      douban: {
        selector: 'input[name="douban_url"]'
      },
      torrent: {
        selector: 'input[name="file"]'
      },
      category: {
        selector: "#browsecat",
        map: {
          movie: "438",
          tv: "440",
          tvPack: "440",
          documentary: "443",
          cartoon: "442",
          sport: "444",
          concert: "445",
          variety: "441",
          music: "446"
        }
      },
      videoCodec: {
        selector: 'select[name="codec_sel"]',
        map: {
          h264: "1",
          hevc: "6",
          h265: "6",
          x264: "1",
          x265: "6",
          mpeg2: "4",
          mpeg4: "0",
          vc1: "2",
          xvid: "3"
        }
      },
      audioCodec: {
        selector: 'select[name="audiocodec_sel"]',
        map: {
          aac: "6",
          ac3: "9",
          dd: "9",
          "dd+": "9",
          flac: "1",
          dts: "10",
          truehd: "14",
          lpcm: "12",
          dtshdma: "11",
          atmos: "13",
          dtsx: "10"
        }
      },
      videoType: {
        selector: 'select[name="medium_sel"]',
        map: {
          uhdbluray: "10",
          bluray: "1",
          remux: "3",
          encode: "7",
          web: "4",
          hdtv: "5",
          dvd: "6",
          hddvd: "1",
          dvdrip: "6",
          other: "9"
        }
      },
      resolution: {
        selector: 'select[name="standard_sel"]',
        map: {
          "2160p": "6",
          "1080p": "1",
          "1080i": "2",
          "720p": "3",
          "576p": "4",
          "480p": "4"
        }
      },
      area: {
        selector: 'select[name="processing_sel"]',
        map: {
          CN: "1",
          US: "2",
          EU: "2",
          HK: "3",
          TW: "3",
          JP: "4",
          KR: "5",
          OT: "6"
        }
      }
    },
    TMDB: {
      url: "https://www.themoviedb.org",
      host: "www.themoviedb.org",
      siteType: "tmdb",
      icon: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAsAAAALCAMAAACecocUAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAA4VBMVEUDJUEDJUEDJUEDJUECJEABI0ACI0ACIz8CIj4QNUobRFQQOU8PPFIQQlkJOFINVHAHUnEDME0TOk0oVl8rY2wpanUjbHwWZXwhr8kQqc4ET3ARN0scRlUXRFYbUWMVTWIMQVsNU28IWnoDNlQBIj8oU1xHf3kxbHJGn54fZXYVWnALTGgIZocDQF8RNkstXmUlWmYoaHQSR10NQ1wIP1oGTm4DOVcfSFVvtZxmvKpVurM1kpsWYHcPXXgKbo8ESWoLL0YqWWIpX2kiXm0USl8LP1kIPFcFQmADNFIBIj7///8y4y3nAAAAA3RSTlOL8/J7NBHxAAAAAWJLR0RKHgy1xgAAAAd0SU1FB+UEDxE0CxaidT8AAAB5SURBVAjXY2BgZIYARgYGJhZWFjZ2Ng4OFiYGFk4ubh5ePn4BQRYGViFhEVExcQlJKQ4GNmkZWTl5BUUlZXYGFVU1dQ1NLW0dXXYGFj19A0MjYxNTM6C4uYWllbWNrZ09UNzB0cnZxdXN3YMFaL6Kiic7EADNR7IXAHnLC6fWgfiqAAAAJXRFWHRkYXRlOmNyZWF0ZQAyMDIxLTA0LTE1VDE3OjUyOjA5KzAwOjAwD2XHBwAAACV0RVh0ZGF0ZTptb2RpZnkAMjAyMS0wNC0xNVQxNzo1MjowOSswMDowMH44f7sAAAAASUVORK5CYII=",
      asSource: false,
      asTarget: false,
      search: {
        path: "/search?query={name}"
      }
    },
    TTG: {
      url: "https://totheglory.im",
      host: "totheglory.im",
      siteType: "TTG",
      icon: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAYAAACNiR0NAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAABmJLR0QA/wD/AP+gvaeTAAAAB3RJTUUH5woaCC40liGC4QAAA+FJREFUOMttlEtTVEccxX+3+5K5wzyAASKPMaLRLCAp3fhKstG8voRV2eXb+CHMB4hJ9mZhrIpVwZTCiEYepgYYYAZl7ozcV7+yuDBClV3V1b06fc7/nNPenTt37n566dL5YjEYy7LEWuNwzmGtxVpLkiSE3ZA0TdFaY63FGIPWGmMMxhiUUhhjAPA/v7ww/82tby9OT03XtNbW4cABgBCC3d0dHv/1mNbODlppjM3BlFKD8/junMOvVivVs/X6xJkzU6N8YAVBQON5A7ErEEKAB9ZahBB4nvd+4+Gw+HEcJf13PV2r1fA8ge/7AGRZhtaKdmePbrdL2OthjiRrc3QeM8xyhtYZ/O7bLq9fr+OcpTY2zvj4JADd7lt2drZZX9/gXb+PFB5OCJxzOMcpuceSjTX4B297/PPkGe29N8zPz1OrTeB5kKQJ3bAHnmB+YQGjDc5ZrHO02x0ayw0ODw/JlMJoPTDMV0oRxzFRFJNl6mhyHpMTHzM8XEYrjZACj9wrKSRra6tsbjZptVqkaYZz9j1gHo88KidXsThMsTj8IZ8IwxCVKcKwh9IZzoEzFiFFDqhPUAZwOHq9kDTJCIKAarUKDrrhAb1ej/X1NYJiwKXPLiKlIEkS9vbavNl/g38ypAOWDl68XGF7a5uz9U+4evUaOFhuLPFkcZEsU9y4eYOz9TqlUolOp8ODB3/w26+/42utjyKiT0nf2+2wtrqBL4aO3rDs7+8zXC5xdf4Lrly+wtDQEEIIpqamaTabSClzyc45+v0+GxvrBEEBay2rq6uEvRDw8qh4sLAwD3jMTM9SKpUGeY2iiHeHh8RxnDME6Pf7rDxfodlsopSi2WwyMjKClDKvoSc4d+48vvSR0idNU1ZePGd5aZl2p83Ll/+SpmkOaIwhiRP6/T7xf/Hg1UKhAB6DahU+CoC8ent7O9y//wutnRblUoVyucz169dyU5RSeF4uTUqJ7/s45zDGcDwSz/MGsUmzlK2tLZ49fcr3P3zHrdu3CYIivbCXMzwGVFqdqlOSJERRRJZlSCmQ0kcIgZSScqXC9MwU9foss9N1yuUqZtYgL1y48GMQBGestcNpmp7qplKKg4MDXr16xaNHf6KNYmxslFKpTCEIqNVGmZwcZ3RkjFKpnKs7KfkkGOTONxoNlpaWiKKIza1NCoWAr778mtGRUa5fu0mcRARBcTAO3xgjtdae53mDxuSgZiA773rEw4ePqNVqlMsl5s6dp1yuUCpVMMbQ7rTZ3t5Czs3N/RQEwQRQHHxDJ9pzXEcpJd0wpLXdIo4iZmZnqFSqSF8SxxGLi39z7+d7/A+iMsWK5Inr3gAAACV0RVh0ZGF0ZTpjcmVhdGUAMjAyMy0xMC0yNlQwODo0Njo1MiswMDowMO+VxjIAAAAldEVYdGRhdGU6bW9kaWZ5ADIwMjMtMTAtMjZUMDg6NDY6NTIrMDA6MDCeyH6OAAAAKHRFWHRkYXRlOnRpbWVzdGFtcAAyMDIzLTEwLTI2VDA4OjQ2OjUyKzAwOjAwyd1fUQAAAABJRU5ErkJggg==",
      asSource: true,
      asTarget: true,
      seedDomSelector: "#main_table h1~table:first>tbody>tr:nth-child(2)",
      torrentDownloadLinkSelector: 'a[href*="im/dl/"]',
      uploadPath: "/upload.php",
      search: {
        path: "/browse.php",
        replaceKey: [
          "tt",
          "imdb"
        ],
        params: {
          search_field: "{imdb}",
          sort: "5",
          type: "desc",
          c: "M"
        },
        result: {
          list: "#torrent_table>tbody>tr",
          url: '.name_left a[href*="/t/"]',
          name: '.name_left a[href*="/t/"] b',
          size: "td:nth-child(7)"
        }
      },
      name: {
        selector: 'input[name="name"]'
      },
      subtitle: {
        selector: 'input[name="subtitle"]'
      },
      description: {
        selector: 'textarea[name="descr"]'
      },
      imdb: {
        selector: 'input[name="imdb_c"]'
      },
      douban: {
        selector: 'input[name="douban_id"]'
      },
      anonymous: {
        selector: 'select[name="anonymity"]',
        value: "yes"
      },
      torrent: {
        selector: 'input[name="file"]'
      },
      category: {
        selector: 'select[name="type"]',
        map: {
          movie: [
            "51",
            "52",
            "53",
            "54",
            "108",
            "109"
          ],
          tv: [
            "69",
            "70",
            "73",
            "74",
            "75",
            "76"
          ],
          tvPack: [
            "87",
            "88",
            "99",
            "90"
          ],
          documentary: [
            "62",
            "63",
            "67"
          ],
          concert: "59",
          sport: "57",
          cartoon: "58",
          music: "83",
          variety: [
            "103",
            "60",
            "101"
          ]
        }
      },
      videoType: {
        map: {
          uhdbluray: [
            "109"
          ],
          bluray: [
            "54",
            "109",
            "67"
          ],
          remux: [
            "53",
            "108",
            "63",
            "70",
            "75"
          ],
          encode: [
            "53",
            "63",
            "70",
            "75",
            "52",
            "62",
            "69",
            "76",
            "108"
          ],
          web: [
            "53",
            "62",
            "63",
            "70",
            "75",
            "52",
            "69",
            "76",
            "108",
            "87",
            "88",
            "99",
            "90"
          ],
          hdtv: [
            "53",
            "63",
            "70",
            "75",
            "52",
            "62",
            "69",
            "76",
            "108",
            "87",
            "88",
            "99",
            "90"
          ],
          dvd: [
            "51"
          ],
          dvdrip: [
            "51"
          ],
          other: ""
        }
      },
      resolution: {
        map: {
          "2160p": [
            "108",
            "109",
            "67"
          ],
          "1080p": [
            "53",
            "63",
            "70",
            "75",
            "54",
            "67",
            "87",
            "88",
            "99",
            "90"
          ],
          "1080i": [
            "53",
            "63",
            "70",
            "75",
            "87",
            "88",
            "99",
            "90"
          ],
          "720p": [
            "52",
            "62",
            "69",
            "76",
            "87",
            "88",
            "99",
            "90"
          ],
          "576p": "51",
          "480p": "51"
        }
      },
      area: {
        map: {
          CN: [
            "76",
            "75",
            "90"
          ],
          US: [
            "69",
            "70",
            "87"
          ],
          EU: [
            "69",
            "70",
            "87"
          ],
          HK: [
            "76",
            "75",
            "90"
          ],
          TW: [
            "76",
            "75",
            "90"
          ],
          JP: [
            "73",
            "88",
            "101"
          ],
          KR: [
            "74",
            "99",
            "103"
          ],
          OT: ""
        }
      }
    },
    UHDBits: {
      url: "https://uhdbits.org",
      host: "uhdbits.org",
      siteType: "gazelle",
      icon: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAYAAACNiR0NAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAABmJLR0QA/wD/AP+gvaeTAAAAB3RJTUUH5QQMAxYgELsSrwAABEJJREFUOMtFlE1vXeUVhZ/9fp1zP3x9bcc2TnCCQwIFVIUCA0/opEiIEYNW7RipP6I/pr+AYVVVQkJCKghKFYKliEBCCIkTwHEcfJPre4/PeT92BwZ3S1ta0paewdJaW8796e8fqTF3xZgdEXZw/tuU3eStC4+7v16+pquyTydBAcRGibMRN//Vk/v/bbxIN7JFLir6uyzltULZcoj8xtfVlg/uDYP+nFPZV7F708ff7d2cf3Io7pujeaEDsBV+9nB90Oy/suTN1prx5qw3ds0UWY6xGzWlqRzGjF3wvqq9tSgpa9FSPa0rOwk1U+849oX4C9CFntR17Ydd1V80Po2tFStZUMjSttFhaK0V65213ggWMVqqcfBm7CtwDlwBABvAVxAqS+VrrE9gFRXFRltEpHWiCAgCiChGBSOCtWAtGAdOQQHrwVhBrCBGUCOcXH5ZVXF1cNTBYq1BtWCMMHCWqupjQx9jLKQMAsY6bOjj6gF+1MOGjBhFYyFppswU985rZ1lcWuSbvSO+3v2ZzdWad14/y4C3WdOa4ZOap7c/BWBpa5v+md8zXP8tg/ULLJ5fwQZL6TIPvrjFtfc/xL3wzAJLZ0bsTTtiVvrBcuX8AvOyyqCbEPQamj8DIIwuYOwV6vHLjF9YpOka5s0R/ZURy69usnHvMk7g1IOiiuqJ1hwx1TLDZ7dZO44AjM5tczxZoW0j88mUr/7xCQffPWDjyiXWX3mO5UsbONUTUDn1FYoquTvCjs6ydP49hpf+AoDrDXm4c5/5wWPSFCaf3+fgi9v0msB4ZQVjDU4B7wyDyrHQ8wxqhzGC8YFuNmH/xnUefX8TgOXnXyLOBhjnsc6ysLpEe26dhdVlQq8mNhH3w/5Ttq9s8vqLz/DnN7cYBIOXwpPOUuJdjvc/YO/qPwGoeu/iwx/w/YssXRyz/bc/EqcNvTMjjmZTfvzgU9zVW/s8v7nMq5fXGFihnWau3pswnXdU4TqL0x1Mvo0CzcEOc12jmxWauERvdQEzMLSzQ/au32H3PzdwN/dmvP/vO3z29UN6wdAmZfeJ8py/w8bwY9bct9RjBaA5vMX8wDPZ/ZHm43XcwCBWKF1i+sMBj27s4giBW4eJO9MploKKRaoRG/VdSvmSFB6AP6lenu0SJy3N/cjh7QjSghRISooRjzmJTV17enXAG8gYojhc8LjKYB2nYzy42hDqmt5wiLHhtClt09A1EacKIoI1gjGg+msy5VSj/4eigmAwCEYMGEUsiDEg4FTV5VxMzBktkFTpSqIjEVG6BO2v3yZBPC7ENhK7DqsJyUBSSsoGVedQPcopPY2dHGdKU9QcR5W209J0aNMlujZRAFzBxLb4rkt1jG0/k2qESjL9nFOlqHWiZVdjfNzldI8Yd0vRn5If7bUD96j07MQ75vmYqEAd8GD7KbLYpPlqys2GCOtB/KZSzhfR1f8B1roU+C5nEcAAAAAldEVYdGRhdGU6Y3JlYXRlADIwMjEtMDQtMTJUMDM6MjI6MzIrMDA6MDAKmfIIAAAAJXRFWHRkYXRlOm1vZGlmeQAyMDIxLTA0LTEyVDAzOjIyOjMyKzAwOjAwe8RKtAAAAABJRU5ErkJggg==",
      asSource: true,
      asTarget: true,
      uploadPath: "/upload.php",
      search: {
        path: "/torrents.php",
        params: {
          order_way: "desc",
          order_by: "size",
          searchstr: "{imdb}"
        }
      },
      needDoubanInfo: true,
      description: {
        selector: "#release_desc"
      },
      imdb: {
        selector: "#imdbid"
      },
      anonymous: {
        selector: "#anonymous"
      },
      mediaInfo: {
        selector: 'textarea[name="mediainfo"]'
      },
      torrent: {
        selector: "#file"
      },
      category: {
        selector: "#categories",
        map: {
          movie: "0",
          tv: "2",
          tvPack: "2",
          music: "1"
        }
      },
      videoType: {
        selector: "#media",
        map: {
          uhdbluray: "Blu-ray",
          bluray: "Blu-ray",
          remux: "Remux",
          encode: "Encode",
          web: "WEB-DL",
          hdtv: "HDTV",
          dvdrip: "Encode",
          other: "Others"
        }
      },
      videoCodec: {
        selector: "#codec",
        map: {
          h264: "AVC/H.264",
          hevc: "HEVC",
          x264: "x264",
          x265: "x265",
          h265: "HEVC",
          mpeg2: "MPEG-2",
          mpeg4: "AVC/H.264",
          vc1: "VC-1",
          dvd: "MPEG"
        }
      },
      resolution: {
        selector: "#format",
        map: {
          "2160p": "2160p",
          "1080p": "1080p",
          "1080i": "1080i",
          "720p": "720p",
          "576p": "Others",
          "480p": "Others"
        }
      }
    },
    ZHUQUE: {
      url: "https://zhuque.in",
      host: "zhuque.in",
      siteType: "TNode",
      icon: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGYAAABmCAYAAAA53+RiAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAa8ElEQVR4nO19e5hcVZXvb629z6mqrupXukMIdAgS8hDlFQggEnlckUhAkUFQcRwfcxXxznBlxufo8KlzER1GvTCo4wtBUNFBISACYiDyEgwkBISEQCC0CUknnaQf9Tx7rzV/nFNJ6HTS1V2dTvy++n1fpdPVdc5+/M567rV3AQ000EADDTTQQAMNNNBAAw000EADDTTQQAP7MWhfd2AsIAIxiIjAqrv9jKpCBaqq2M2nGqgbTCDLZAkwo72WAGOZLNFfz4O433fUELECJKoeiDvclQszb+jIHj6zNZw9qzk8tDljDxBFkwJqCIWeYrRxTV/55ee3lVY93Vt8YVPRlav3YyJDgHpV2WeDqgH7LTFMIIBY4gnUGa2p9oXT284+53Wt5x3dmT2pNWUODpnID6PLCAARIfIim4qu+5ktxUfuXtt3221rtt29dqDcTwAxEStUZD9Vc/slMYbIiKoqIHMnNx32qblT/++C6S3vawltR9mLFpyQiz8gwJCJpe3vEBFMyISMZU0Zps0lt/Hetf03fvOpDdc+0ZPvJgIziHwijfsT9itiiEBMZLyoO7Q5bPvKSV1fPH9G+6WWKd1X8epFhYmUCEwA13BLVUBVIaJK1hC3hoac6OBNq3q/dcVj6656NR/lDZEVVbc/ic5+Q0ziaRmv6j5yROeCq06e9v3WlOnaWnKigBgigzr7q4B4VWGAO9IBbyhUXrj8oe6//8XqLUsMkRWo3188uFF7OHsDTCBVUMay/85p079yxQkHf6/kpXmwIt4wMY8DKVCAFMQgJhAGKt5nrOm8eHbH37WEpnhfd/+DCpiAyQC0Oy98wrDPJYYJJAo0WTa3nn34DQumt73v1XzFWaZa1dXw0ORFAAyUjAJGAYYSgaFQL/DioFNSQfCbF/u+e+HdL3684KTqPBgmwIv6fUHSPpUYiiUFTZbpV2cffsuZ01ou2lCIopApoLE8NDvIUEoruFmUW0VNiyduFnBWibNK1KSgJiWTVbY55cEg8kdOS59w1qzmU9pzRopONq3vjwZEYxINE0+0ittnEpM4T8Yy+dsXHv69BYe0/e+NxSgKmIIx3VAAWFXOCiiroEBpJw9tqO+2CzxUsgFTOjRULPuBh1/O/+Y7f+y95q6VA4+WnMAwGdWJc6/3GTGGyHhV/7WTuz756eOmfmN9PnIhkx31jQQAQ7nFg3MCWNB2yRntrRReVGEIJpcyCCzhye7i3Z+7+9XP3rt64KmJDE73CTGGiL2qnH9Y+7yfL5jxUG/JBZZp9P0RgDKqpt0DoRLGb7rUK7yqci7FHBp2P1225T8uu2P9FVsKvmyZjJO9G/tMODFV7dIaGv7ju1//4EG58OSSU880SnunALd64Vbh6u97AxIThI6cNS/0lJd+4JZXLnq0u7DGMlkn6vZOq/V4PWNtMHZ98cljDvz72e2Zk/ORuFGREhOgptMrtwmPVW3VCiYYw8SbBpzraguOv+ejMx5779y2NzlRZ8eiemvEhHplFLvGMjUbZK47dfoNCnQidr9qk9zE4zKTnVKT8jiqrpFAhonLTj0RchcfO+midX2VR5b+pfiSZbKi49+TCZUYBjEAfPSYzgu6cuHsshc/ylhFTYcDZSaUlO0wTMYL/Na8y333/K7b3jYrd6wTdYZp3B/wCSOGAHhVCZhw3vT2v8s7AdMoTJwA3OaVsuNq5EcNJhgFfKGsbTe/Z/otcyanOr2o53Fe65kwYpiIAei8KdlZM1sypxSdgKnG9gWgJlFulX0iKUPBBFP24toyZuYPLph2nWFA9K+UGEpIeOu0ltMzllOi6lCrbTFQbpfxM/Lj4DBYJru14P2bX5e78PNvPeBi7Ei0jgsmjBivcV7wpANzp1S8omYtJgC3+DiSH620KAAhJKs2MR2sCqMCo9VnXF/zuVHAGqK+gsPl8yd/+fDOsMXr+Km0CfHKkthFW1MGnzvuoCtCQwcm+cU9D0IBBKpmUrKqXMuQd86XhQpu8srNHpzzMMnP5EWcFVCTB6cFFIqCEZPjibYnQPc8LnKiblLadhBo629XDTzCTFbHwUubEImpFkFMzgQdk9J2mosV8sjTrADnRGGSNMsIn4UAFKhymxNzQAXmgAq4PWLKClFKCVYJDEL1X6NEgRJlhLjFsemIyB5QgemIhDIStzjCFBsm7it7vPfYto+9blKQ9aJuPKRmYohJFNehLanOpoDbhlunHxYGSk068tObEGI6IjUHVMAtnilQgoJ2UmW72hXd6SUU/2QQZYXN5IjM5IpS1uuebBIBHHn1nVk747w3tC4Etjs6dWGibAwBQJrRYuI2R1YUAlBKkEzwbj8DgnJ7LCGUFQJAw1QCjA6StB8qmQ4XExSoQobvMhOhHCkuOKrtPQDgpP51tgkNMBUUjEbIKbOHAQqgoTh0lJ00OYgA4qDOq3eiThT1Jxmr6jGlFEuiGzbpzwQuRoI3TEnPf/2UdAcAqVed7bVcz3BQha/5SWYohcNLi3dwlPPcPMXbIMUACKiuM1oYCCEqKfJlUSKIMXU6OUnVDbc5IBCVrQGgr3FGyIlKZ8Z2ntjVdOxzG0v3MRFLHdU3E0WMAgAZHUhcNMKeLIcCsAqyOlQlqXOQ1ili7SRxq7orSxY/V7p75frS06s2lDcTg2YdHEye0xUcfcYbMwtmHxye7EtsBvvhLXFs8KkOLSMAZ4XIROo3BzqEHAHAJ01Nz/0xcN9ux1YjJoQYRaySugvl3oKXfiZqGekaslDwDm9MAYWHdk6Febhn4NYrv7/livv+XPhzxevO65S456kiANwVBLjyzLmpY7/8gdZ/O252+uyBjXBUDhgRc+zojpEgASgtZDoSchICiIDIKQ6fljoCALzUZ2YmxMZUu7ixz2/uL/lXLRN2kYUhF5DR7ZGLAqoe1NKJ0ufvXf/+U77UfcFdK/LPRl7ZMhlryBgGGwZbQ8YyGefAdz1WXv6mf9y08Mqbt13SfJCH6SwSTyoKpZ1CMfZFYgEo44knRdsjFgKRV2BSEHQlfa4rlpkYYuIpMBuLkV87UP5zaAgjFjfs6JmqgNrbqPChX6w956u3b7nZMgWWiZM6MadQEIOJwQpVr+pUIdaAFRr8y/X9//Wp6/r+JpMlQcqzmVSE6SgpBbJbT2tECIGznrnZK4RABPKiaMtxe2uWAUBHk6Pd/fD3MgzF3XxiU+GRtCGIjuBSJrk151XbswZf/N2GS37y8MD9gaHAq0ZO1BsDBsDewzsH5xyc9xAQmBnsPLwXRIFFePV/Dy761k0DlzXlDLwjobRj01kkbq4odIx6TQjc6uKsgcb+R4vlsNkmxIzppjEm0l0WALh/3cBirwDRiPZNRdW3pg3/4aXBX/y/ezb9hAnWeY1UAWaw95BcFnTuOZh39Vfx4au/ig+eew6OzTVBRaCG4/0zzqMCwHzu5oHrnl0T3Z3NkBFHHgC4tUymvQRgjKqNQdzi4qtJ4YXFj8Nq94QRk1Tt4w/r+pety5eXpgzvWQ8n6o8Z8o0/bLoKChCRKGJSRCDvWIij/vwkHlp0Bx6//DP4weWfwY8W3YEnn/0jFp9yAmZ6gVTJsQYoVRTfvKPvq0gBqsnYhUBNEZmOIkBjIEcAygiQFg2JsX7A5TcORgBqSCPtARNGjAIwRHZryePWF7f9NBcwvOy+DEgcJGMZz/WUH7j3+YFlAFhExZiYlHedg2NuvxNLug7BSX4LxG+F91vhXS+kazZO++09WHLyiTE5zGAv8ADo1iWlP6zrrfwpHRBtTzYKgVJ+7OQAxM1OiYCKd5uSwJ/3ucRQjYv2ijjgumlV781FpxtNXMww7AYXH0EzlrHk5cJ9JacwTAwCvIdkm4Crr8Y1KKPN51ExFmwtrLWwNgC7PlRyzTjwu/+FbwYWEInbMAyzdRvw4LOlxSZDENlJYqvktJcw6hBEAYRCYUbxYm/lxbitekz/+EkM1ZKUF4UykXlqU6HnltWbr2sLDYatzyJAHTGU8Pzm8orqW9UI/pyFmHfYbMx3gxBrEQ693AYIfR9w5Btx1vxTMAeAMu9YyV66urICKYEOXXUUAmUccUtZRuutKYEoq1i1sfJU0t+6UBcx1cZbm6DZdG3XKGL19W9LX/3/m8vR6pDZDmdrSIhdCVjZW+6Jr9vR5PFz8cbkt92qQgU8DOwh0zEH2L70oAAgqj1I+V2JAWJPK1ehONapeXqVAaPW+UfWFh5P2t93cQzH7iouODM48W0n2DcCgOE931MVaojM2v5K/1VPrP/0pLRBNFw2VgEtESB+l9kpFLYPupaZG26CCCmftDIciLilMqrdGCoECpVtzid5uX0Y+VdLj854U7jwnQvC85M3R7ynV/UEMtcs33Tbopd7r5mSsSYSjXaeZSVVGzFmd6anJG2haqyfWI4V8Yd23xYBBh6VV9biOWB7kEsAkE3RFFgB7W4zugIUeqKmCDWqNFJVB0t04oz0CQBAda7J1HVx1age3EmvP/vk4KJ0CvAeviazR7FK+8jv1/7T072l37elTFARjXb8HeJLhFnN6WMAQBWUGGtavBjL1qzG72wLyEWoDLmzRhVUTDuwdCnuWPwAVgOxJ1el4Zg59hhAQXYP+QclcDbC7k8SGDIcAiCKOVPDo+L+7kOJkTi/ivYW6uzsMq+/aEF4KmJDO2KaPVZp4M1F7z5w75p3by27ZS2hCVxCDjNRMVLMP6DlzHRI8KqCOLCkwTzwwQ/iHwYGscG2I/QO4hy8c/DeQYMOhAPb8PJll+GT8b3i6fcC195CdPLR9n+hpDBWd+9PKkCBEGVcTVJDROSd4vAp4YykrbqYGTMxiTGVKZMIXZ3cgYLinz6Q+ucwALyvzWx6hRgmfnpLYevZi54/q6dYebwtZYNINGKACt5jdrZp/lu7Wk8CIMxkRCDGgB98BKvetgDzn16Ke0wrYCbBmHYY0w598hHcdurpmP/IY+hOglE1ycPy7rcFb53axcdUyipslPc4fQpwxtUcKqoCoeXOxP0baxYOQB1eXbJFT7umcOr5XzWvCpim21bCJ75cOPfbPy/faQ2M87WtIla3ZRzYFOR+8fbDb5x/UO5dG/ORF8C3hiZ8clPhjjN+vfIdTtVA4yUxEweNai301PmYc+h0vB6AvrwWzyx5EC84B2KO1R9RHOm3ZCFLf9Zy/8xp5jRXES/9KZZ8QCOEguo2ZYARSiwUEEPgUqQrjvz8y0ev3+aQtDsm1B3HaFypRWwAzSu+8g/pr804hHPOwzPXRrxXFUPEGwpR4czbVp3/zeUbPt2etr4lNGFvyVVOOjB37hfmTb1EFd4yhURAkm4hEfDv78fKH/4Yv/7hj3Hb7+/HCyIwVVIAwBhYAPL5j6QvmTnbnFYuqKdYgkbuHytRKDWnJNmAOVHk+zSJSYwKCBUioFJBNKmNj7juc5mvJX82tXbOqwoT1InYyx/s/vez71g1d9XW4n0H58IwH3l8au7Ua/7PUQcsjEQrDLI2UWtV1VaN/JOUja+SYg2Mc3BnnmCP+MyH0ldFWxXWbB93TbEGhTXsj1XAGsKmfilvGRBg7EtxAOop+ItnnCqi8qF3pd7f3swHQ4GoBJ19hD0xzfjLfX90T1iDoNZtCtXFSsNkXuwr99y4svfGF/rKj81uS3dNaQoOPXfmpPc3BSgs7h54KKlN2/5SJfGx57V9PhJ1JzOnUfNt/5m7oznNh4qDUBJrSTEAaqmdVIIW7R5LDhWQlCVet9U9e+3vtv4EO6qBxoS6ihQIMC6CXnxWsPDgg8wcX4EaA/ZF4NQ3BwvXdssTT670qwKLQKX2SDgJQtmr0vLNhdU3ruy94fGN+dvF6+B7Du/48Ptnd5xFJJvX5d3G/oqvDFf2VbVBrVmyt12b++85h9m3VPLqdxRmkEo+AGSEM5kS31+LQTLk4SEKyaSYl60tPXDzIwOLkl0BY47+61rzZwPyHni+W5+ddxzOE4UyQETQaFDt9VdmbyXG+dffXvltIjlOanQjvaoQAMtkSiL6m7XbnvrN2m1PNVn+zEkH5uae0dX8ho+9YfKZG0qVNY5896ruUt+S3oIjAgzDOg/XmqPg7u/kfjnvKLuwvE2dtTvGq0JQX0P2VQEijRWT7MG7VgUMYdWG6FkgrjWrp7ysLmKS2kU89oxbevH5YfJW4korpJLX1I++nl00ezp/9LPXlK4ngrEGqNVbUwBO1BPiTUNQpYITv/gv/UsX/6V/KQCEhszkrKVKWTwRyCQ25YjXceeia7O/mDHdnl4ZQkq8WYdGlpadPk+sMZG7BwPAildKT+zU/TGj/gATwKPL3eMoan8SK8SlSgRmAJVepc9cmvnR3f+Zve6gyRw6D28Yxo6i1ksRn1DhFY4QB6aWyTARV7z6df2R31TxrAA5B/fBc4L5D9/UvHTGNHt6pV+dsUMeQFJIxYxm8bdqynbbRWuIB/J+46MvlJbHc1PflvO6iEnsBj/xnF+3fLU8atOvXeNInmCubFF31unhpStubV724XeGZyrgnYcQga2BHSnx+Zo2EQemoirMSoZhKM4b+9cdzC13fiv7reuvzj2QC+mQKK9+F1KA2JiXzWj8JsUeHBgvkGyKsfTl0pKV6yvbiGDqPaihPmIAWBNnk+56qHILMoDs2n0yBrbSp741Q7N+eFX23mU/a77zorOCEw1DnIfzCcHGwFoDawyMMeChL2tgrIGtDtwLxAv8YQdz6/e+kLn8z79qeW7hmeFllS1xzScPJ5UEaMQa5xZqHShBdfdqT1VBlrDoycGfA0ielPpQ/3aBJAMwazq3L7ulZUWa0SXxSsYu9xaFqABBjpgsdPVK//CiBys3/Or+6LePP+3XuRosT3VRZepkTp19ipn3N6eF7zn1pODCplaa7PtUvY/jmt2OjRW+L1QZDEeK+Hc06Ejdpqbqb69BHPETFyK/au6/rD26e6srJ2fk1CUx47P7ycB4D//tLzT968cvTn2pvGWIsR0CL/BQUJghRhMgJS289JI8uXSl/+Oza9xTL6yTlzb0aK9hLSAp6yZGy8xD+KBZh5g5c+eYeUfPMic1T+bp8IDPK1wEbwyI9rTsQIB6Urc5E5fp1gJSaNmq780MW17rvLq2Vmu/fe+Wf/zEj3uuNQyT1BfUhXEhZrvUHMKTlv2yZXmaMC3JUe1RVYrElaSGYGyagBTiyEoAeAhUK3ECkQIAO6iOACkpoije/cKxnaklvQLflxIZDLjmUglWyEAo0pfa5ZpqUWFfSZ474V9fPr57iy+Mh7QA47TVTxFLzeZtWggCbD39tOC8KB9Xp+zpOkoK84igPoK4EsQXIFIC+QrYV2B9BUHyf7gCvC9CJIJA4yAyub6GvLxCI6O+L4z3k40CMhgOmyHwotLcbPnzt2y+5HfPFFYYhhmvwxjGRWJ2AlsDeejG5ltPPMqeXxlQlyQQx4KhT119fSWo25yGRqPcuSIUZ5eHFLw6r64tZ+w9TxeuX/D17g9z7JCM28E/41pXxgx1HvjwF/MfHxiUF20AK2PXtzTkVUfHFL4/VK2Y0ZHCCimbWFp2ghf1TSm2PXm34tIfb7gseXtcTyAYV2JE4hKjZ9dIz0X/XLiQm6gPBFMHOfWDFTIYqORHYVeqiJOXr3ETvMCnAjIVrz0XXbP+wjU90YBh8HgfMDfu28lVodbAPr9W1m3aJI+euzC8QCpIS7w+M7GnPbFC8lZ9f2r0G+9IoWWjMhBut0hO1KUDtk6x5dxvrHv7A88Vn7bx+TLjfl7HXtnnL7G3Yh97xr/0/Av+/nPOCN+ZTlMuKsGxGQfVVAsSSfH96bHthiSo9KUBbwgEjZy6lgwHFdFXzv2PdQseeK6wzBqye+tAub06QdbEWd43HWkO/dnXsz+ffpg5sdKrHnEGeO8c/hBHoOr7Q9SwbDw8WCEFq7I1A68iBEJLqzFPv1S6/2+/++r7nnqlvGFvn/K3V0/GSCTHvLJBt954Z+WGqc2EucfZkzmgwJUgqvDENZc+7xkEgBVaMeq3paAlOzZS4iBUot60VwE1Z40JLMo/vG/rFy+87tVLunvd4HgFkSN0Y+/DxGaXRODPenNwxFc+lr5y3vH2HVCQH1Q4B88M1FL2tAsISYzCKvkAUrDxu2MYWfWwUu7LmAyFAKt/ZGXxl5+9pecLD60uvcgMA4XujYPjhmJCiAHi7ABRvNRLBD3nLcFxl70ndelbjrfnBS00SUqqvqjKTHsuKSIgXr0CIKQaMaRoVYqW4lzD2Jwj7+FTTcS2nKb+ddxz33P5W7+/pO/b96zIP6MKSjwvGY+ovhZMGDFVGAOjCq0uD8w51HScM9+e8oGz0x89cnZwdrngIhvAxKW22+cg3oMmUBWCOlatGGiFSSOOg78xEqLxFnXf3EH2T8vcrTcsin509zMDD7/YE/UB8dlkRHEme1wmoEZMODHVRjkmCCpxnVg2RbjtS53XvfXNqUvz25xjo0jW50kBgYBUuHp8FcX5a61rBPEJsUC2nc1Nd+W/9rFvbftsoaxEgBLDEAh+Lx/juzvssyPkVePvEGMCGQtbcaCb7y/e2R7S4CnHZt6mZTblInkWQ3DM8ExIjt2vNx+giEtqUymy6Sy7f7+p/xOXXtv3NS+wxsQnEU6k2hoO+/zbMBRAtVqSAHvXn8oPr34l+v0Zx6Xe3N5hDojKql7UE28vy62nLfHx0jZl29is7/HL//arW8697o78ndbAisb1aPuMjZ2wz4kZAjEMs+Ilt/ani4s/zAVUPG5OeFwmx00aKSIP1fiYtypDI9a4KKBJASACC8q0sClXdMsPFuW/+N4rt3x0+YvROpu4v/sDIVXsExszEpL0uapC5s4Mpnx8Ye7j735L+kOt7eYQeKgvC5WjOE7C7pOHzAxOWcCkWGFB/T1+zU8fLH7/678c+MFLG/xmpnjJYG/HJGPBfkkM8Fr3GoBOnWQyb5+XOuO8kzPvPH5WcMqUSWYGhxTGbvPQixHrrYqWNm7xLzzxfOUPv360dPtvHy0tebVPyiCQIRhV+MaXx40RJk4hGi/Yfo5+S5bMkdODQ446zM5szZpps7vMAaGlJgJQcsivXud6Nmzxa1e+4lc/2x39pS+/vUSEDO/fhFSx3xNTBROI4yCPZCeSagAxwzDFsdP+TkgVfzXE7Iz42/9AiZe2S4lEMqj4K321rkrVBhpooIEGGmiggQYaaKCBBhpooIEGGmiggQaGw/8AI1mCR30LotcAAAAASUVORK5CYII=",
      asSource: false,
      asTarget: true,
      seedDomSelector: "div.layout-container > div > form",
      uploadPath: "/torrent/upload",
      needDoubanInfo: false,
      search: {
        path: "/torrent/search",
        imdbOptionKey: "imdbid",
        nameOptionKey: "title",
        params: {
          type: "{optionKey}",
          keyword: "{imdb}",
          sorter: "seeding",
          order: "desc"
        }
      },
      name: {
        selector: "#form_item_title"
      },
      subtitle: {
        selector: "#form_item_subtitle"
      },
      description: {
        selector: "#form_item_note"
      },
      anonymous: {
        selector: "#form_item_anonymous"
      },
      torrent: {
        selector: "#form_item_torrent"
      },
      imdb: {
        selector: 'input[placeholder="tt123456"]'
      },
      douban: {
        selector: "#form_item_doubanid"
      },
      tmdb: {
        selector: ".ant-space.ant-space-horizontal.ant-space-align-center >.ant-space-item:last-child > input"
      },
      screenshots: {
        selector: "#form_item_screenshot"
      },
      mediaInfo: {
        selector: "#form_item_mediainfo"
      },
      tags: {
        chinese_audio: 'input.ant-checkbox-input[value="603"]',
        chinese_subtitle: 'input.ant-checkbox-input[value="604"]',
        hdr10: 'input.ant-checkbox-input[value="613"]',
        dolby_vision: 'input.ant-checkbox-input[value="611"]'
      },
      category: {
        selector: "#form_item_category",
        map: {
          movie: "电影",
          tv: "电视剧",
          tvPack: "电视剧",
          cartoon: "动画",
          concert: "其它",
          documentary: "其它",
          variety: "其它"
        }
      },
      videoType: {
        selector: "#rc_select_9",
        map: {
          uhdbluray: "UHD Blu-ray",
          bluray: "Blu-ray",
          remux: "Remux",
          hdtv: "HDTV",
          web: "WEB-DL",
          webrip: "Encode",
          encode: "Encode"
        }
      },
      videoCodec: {
        selector: "#rc_select_10",
        map: {
          h264: "H264",
          hevc: "H265",
          x264: "x264",
          x265: "x265",
          h265: "H265",
          mpeg2: "Other",
          mpeg4: "H265",
          vc1: "Other",
          xvid: "Other",
          dvd: "Other"
        }
      },
      audioCodec: {
        selector: "#rc_select_3",
        map: {
          aac: "AAC",
          ac3: "AC3",
          dd: "AC3",
          "dd+": "DDP",
          dts: "DTS",
          truehd: "TrueHD",
          lpcm: "LPCM",
          flac: "FLAC",
          dtshdma: "DTS-HD MA",
          atmos: "TrueHD Atmos",
          dtsx: "DTS-X",
          mp3: "Other"
        }
      },
      resolution: {
        selector: "#rc_select_12"
      }
    },
    agsv: {
      url: "https://www.agsvpt.com",
      host: "agsvpt.com",
      siteType: "NexusPHP",
      icon: "data:image/png;base64,AAABAAIAMDAAAAEAIACoJQAAJgAAABgYAAABACAAiAkAAM4lAAAoAAAAMAAAAGAAAAABACAAAAAAAIAlAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADEZADQxGgD/MRoA/zEaAP8xGgD/MRoA/zEaAP8xGgD/MRoA/zEdADQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADIbAf8wGwD/MRoA/yISAf/z683//vbZ//Przf///tz//fTS//n01f/58M7/+/nb/zIhB/80HAD/MBgA/zAbAP8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAxGgD/MRsC/+newP/j2L3//v7W//Dqvf//9cX/49is/9nTpv8uGQD/MBgC/+HRo//347r/6dqs//Dnu//++dL/+PDS///02P8zHQH/NhsB/wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMRoA/zIbAf/t5MP/9+/H///0zv//+tH/VEAn/zIdAv8yGwH/MBsA/zAbAP8wGwD/MBkD/zAaAf8yGwH/MhsB/zIbAf8iDwD/+/HC/+HYrP/i2bT/8+zR/y4bAP8xGgD/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADIbAf8xHAD////b/+TYsP/w4bP///XG/zIbAf8yHAD/MhwA///9/P/+/v7///////////////////////////80HAD//////y4bAP8wGwD/MRwA/zIcAP/s3q3//e+///7/1f/49tj/MRoA/zEaAP8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMhsB/zUdAf/j2rX///nO//rvyf8yHAD/Mx0B/yoYAf8wGQP//f///zUbA/8wGgH/LxkA/zAaAf8wGwD/LxkA/y4bAP8xGQP//////zEcAf///v3/NBwA/zIeAP8yHAD/MhwA/+japv/s4bX/6eC//zAeAf8xGgD/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAyHAD/qp2D//324//89uP/LhsA/zIbAf8yHAD/MxsD//z++P8xGgD/o5eL//79///////////////////////////////////9/f3/MRkF/y8fAv//////NBsB/y4WAP/y8/H/MRwA/zIcAP8zHgL/7d+q//nsvv//8tL/MRoA/wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADIcAP/4993//vng//v35P8xGwL/MhsB/7OSYf82HgD/LxgC////+f/6+uL/9PHi////+f////n////5////+f////f////7////+////vb////+//7//f////v/LhcB/y8ZAP//////MRwB//////8yHAD/MhsB/9zDZf//9bn/5dSh/zEaAP8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMhwA//f43v/7997/+fje/zQbAf8zHQH/+/78/7ueZf8zGwP/NBsB//////8yGwH/MhwK/ysYAP8tFQH/KRQA/ywUAP8qEQH/KxYA/y4XAf8wGwD/MBsA/zMbBf8uHgH/5dCZ/zghAf//////MBsA//3///8rFgD/Mx0E/zIbAf/8+OX/9vji//742/8yGwH/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAyHAD/4NCi/zIbAf///+X/MRsA///+9P84IAT//f///8OucP/aw3P/Mx0B///9/////////////////////////////////////////////zEcAP/ZwX//2sKA/zQfA//19uL/+Pfi/zIbAf//////MRwA////+/////r/NR0B////9/8zHQH/38Rq/9m+bf/Zvnv/MRoA/wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADEcAf8yGwH/9eSx///8z/8xHAD/Mx0B//f07/89Igf//f///zMdAf/48tv/9/TV/zIbAf8yGwH/MRoA/zMaAP8wGQD/MxsD/zUcAv8zGwP///////7+/v8zHgL/MRwB/zAbAP8wGwD/MRwB/zEcAf//////Mx4C/zMdAf8sGQD/Nh4A//Lu7f8zHQH/MhwA///9/P/+/v7/LRMF/zEaAP8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADIbAf//98j/uKZ3/zEcAP8wGwD/NB4C/+jm5f86IQf//v7+/zIeAP8zHgL///7p//j44P/5+eH/+fnh//n45P///+z/2MB0/9nBdf/exYX/+fXq//3////+/v7//v7+///////+/v7//////zAaAf//////Mx4C/861a/8lFQX/Mx0B//////8xGgD/HAwA/zIbAf/8//3//////zUeBP8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMBsA///0zP/45r3/MhwA/zMdAf+1mVz/Nh4C//39/f85IQP//v/9/zEaAP//////LBgA/y0fA/8pHgL/LRwB/ywbAP8tHwP/LB4C/ycaAP8wHwT/Mx4C/zYfBf82Hwn/Mx4C/zUgBf82HgL/TkEx//////8uGwD/Mx4C/zQfAP//////NB4C//////8yGwH/LhgA/zIbAf80HAD////////+//8xGgD/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMx8A/9vKo////+H/Mx0B/zMdAf/GtnT/OCAC//////81HQH///////3+/P8qHAr//v/9///////////////////////////////////////////////+/y8YAv/ZzpL////j//j44P/7++P/MhwD///+/f//////Mx4C////////////MRwB/y8cAf/9/////f////////8yHAD/+//+//////82Hgb/AAAAAAAAAAAAAAAAAAAAAAAAAAAxHAD///PP//710P8zHgL/Mx0B/zMbA/81HwP/Nx8B//////8yHgD/NhwE/62ml///+fb/MBsA/zEcAf8xHAH/MBsA/zEcAf8xHAH/Mx4D/zMbA/81HAL///////////8yGgL/MhsB/zIbAf8yGwH/Mx0B/zIcAP8xHAH/Mx4C/zMdAf8xHAH/Mx4D/zMeA/8zGwP/Mx4D/zMbA/82HQP/Mx0B///////9////MRoA/wAAAAAAAAAAAAAAAAAAAAAyHAD/8ejH//DkyP8zHQH/+vbd//z42//6+Nr/Nx8B//7+/v80HgL/2sF7/97Efv/lzHb/2Ltm//X21v/8+N//+Pjg//v24f/5+N7//Prc//v43P8pEgL//vv3//78+//7+vb//Pvt//745f/2+eD/9vng/ykUAP9YQRP/Mx0B//j12f/5+N7/9PbZ//n43v/5+N7/+vXg//v33v/59uH/MhwA///////+//3/MRoA/wAAAAAAAAAAAAAAADIcAP/Pxa3/MRwB/zIcAP8wGwD////x////8P///+X/NB4C//7//f8zIQT//v/l////5////ub//f7q////6v///+r//f/p///+6f///+r////n////5/+bkHz///7p////5////uz////t///97v/7+OP/+fbh/zIcA//+/v7/MhwA////6////+r///7r////7f///+3//v7s//7/6/////D/LxsC/zMdAf8yGgL//f/p/zIbAf8AAAAAAAAAADIcAP///vr///34/zMdAf82GwH/MRwB/zIdAv8zHgL/NB4C//7//f81HQH/Mx0B/zIcAP8zGwP/Mh0B/zEcAf8xGQH/LxoA/y8YAv8wGgH/MBoB/y4YAP8zHgD/MRwA/zMdAf8yGwH/MRoA/zIYAP8xHAH/MxwC/zIbAf8zHgL/NB8D/zMeAv8wGwD/LhsA/zAaAf8uHQP/MRoA/zEaAP8xGgD/MhsB/zMdAf////7//f///zIbAf8AAAAAAAAAADEcAf///un///3y/zQeAv/+/v7//////yERAP/Txnj/MBsA//z9+f8uGQP///////////8xHAD/Mx4C/zUgBf////////////////////////////////8eCgD/Mx0B/zIcAP81Jhb/////////////////+/f2/zEcAf8xHAH/0Llp/9C4ZP/Wumb/Mx0B////////////NSAE/9G5bf/RuGj/0bho/zIbAf/QuKT////x/zIbAf8AAAAAMR0ANDEbAv/Ny8D/Mx0B/zMdAf///v7///////3///8rFgD/KRMB/yYSAP////////////////8zHgL/Oy0a//////////////////////////////////////8ZBwD/Mx0B//////////////////////////////////z+/v8uHQL/Mh0C/zEbAP8zHQH/NR0A/////////////P/9/zMeA/8zHQH/MBsA/zQbAf8zHQH/8uvi/zIaBP8xHQA0MhwA//Pn2//5/Oz/Mx0B/zMdAf8yGAD//v7+/////////////////////////////////3FoWv8yHwT//////////////////f////////////////////////8bCAD/pJqJ///////////////////+//////////////////81IAT/MR0A/zUbA/8zHgL///z4/////////////////y8dAP8xHAD/MhsB/zMcAv8zHQH///v2//j48v8xGgD/MhwA//vy7v/Evbr/Mx0B//3///8zHQH//f///////////////////////////////////zEcAP////7///////////8zGgD/MRwA/zMeAv8xHAD///////////8dCwD/Mx0B/x4SAP/+//3/MhwA/zMdAf81IQL////////////37uT/MhwA/zEaAP8zHgP//////////////////////0M2Jv8xHAD///////79//8zHQH/8ern//Xz8/8xGgD/MhwA//779////vn/Mx0B/y4dAv8yGwH/qZ+V//3/////////MBsA/////////////f///zEcAP////////////////8yHAD/Mx4C//////////////////////8fDgH/Mx0B/zMdAf8wGwD/Mx4D/zYfBf///v////////////80HAj/Mx4C/zIcAP8qFwL////////////+//3///////////8wGwD/Mh0B/y0eAP8zHQH//Pj3//////8yHAD/MhwA/+fn5/////v/Mx0B/zQeAv8yHAD/Mx0B////////////oJaM////////////NRwC/zIcAP////////////////8zHQH/Mx4C//////////////////////8iDwD/MhwA/zUdAf////////////////////////////7//f8xHAH/MBsA/zIcAP////////////////8uFQH///////////8vHAH/MRwA/zEcAP8zHQH//Pz8//////8yHAD/MhwA//7+/v/4+vr/Mx0B/zMeAv8tGgD/Mx0B//7//f//////////////////////Mx4D/zIcAP/+//3///////////8zHQH/Mx0B/zIeAP80HAD/MRoA/zMaAP8zHQH/Mx0B//////////////////7+/v////////39/zEaAP8wGgH/MhsB/zMdAf///////////yMRAP82HgL//////////////v3/MhsB///9/P8zHQH//v/9//7//f8yGwH/MhwA//j4+P///fz/MhwA/zQcBP8zHgP/MhsB/zcfA/////////////////8iFgD/MRwB/zEcAf/+//3///////////8xHAD/MRwA/zIcAP8zHQH/NRoA/zEcAP8zHQH/NiEC////////////KBkA/zAbAP8xHAD/MBsA/zAbAP8yHAD/MhwA///9/f///////////zMdAf8zHQH//v7+////////////MRoA/zIcAP8zHQH/4ODg//39/f8yHAD/MhwA//7+/v///P3/MhwA/zIcAP8yHAD/MhwA/zMdAf////////////////8xHAH/MRwA/zIbAf8jEgD//////////////v//MRwB/zEcAf/9/////////zIdAv8zHQH/MRwB//////////////j1/zEcAf8vHAH///////7//f8xHAD/MhwA////////////+//+/zMdAf8zHQH/MxsF////////////MxsH/zMdAf8zHQH///////v+/P8yHAD/MhwA///////7/vz/MhsB////+//+/v7//f///zMdAf+hmof///////7+/v8xHAD//f///yQUB/8zHQH///////////////////////////////////////39/f8zHQH/Mx0B//7//f////////////////////////////////8zGgD/KhwF////////////NyEF/zcoGP////7/Mx0B//7+/v///////f78/zMdAf8zHQH///////3+/P8xGgD/MR0ANDcgBv///fz/MhwA/zIcAP8yHAD/NB4C/zMdAf8zHgD//////zIcAP8yHAD/MRoA/zEaAP8yHAD/MhwA/////////////////////////////////zEaAP/+/f//49bI/zMdAf/+//3//////////////////////y4XAf8yHAD//P7+////////////MhwA/zUdAf8yHAD/MhwA/x8OAf///////////zAbAP8zHQH//////xIJAP8xGQA0AAAAADMdAf/z9PL///3y/zIcAP8yGwH/MRwB/zEcAP8yHAD//P/9/zIcAP8yHAD/MhwA/zIcAP8xHAD/MhwA/zIcAP8yHAD/JREA/zEcBv8yHAD/MhwA/zIcAP8yHQH/MhwA/zIcAP8yHAD/MRwA/yANAP8vGAL/MBsA/zIcAP8yHAD/NR0F/zMbB/8vGwL/MhwA/zIcAP8yHAD/MhwA/zIcAP81HgT/NR4E/zYeCP+7rqD//////zEcAf8AAAAAAAAAADIcAP///fz//P37/zIcAP/exWn/18Bq/9bAaP/Yumf/1r5m/9a4Z//WuWj/NB4C/9u8Z//Yumf/2b1o/9a/af/Yv2n/0bln/9q6Z//Zu2T/27xn/9i7YP/Yu2D/2rxl/9m7ZP/bu2L/2rph/9i6Yf/YumH/2rph/9q/Zf88IgT/2b9z/9m+bf/Wvmz/2rlp/9q8bf/Yu2r/2bxr/9W6af/WuWj/1r5q/zIcAP/a2Nj///7//zEcAf8AAAAAAAAAADIcAP+Bbl///f///zIbAf82IAT/4djL//z+/v8dEAD/Hg8A/xcLAf8YCQD/NB4C////+//Ks2///////x4MAf8dCwD/HAwA/x8OAf8gDwL/IBAA/826d//+/v7/Oyki/yUQAf8gDQD/Hg0A/yQQAP8jEQD/IA0A/9jDhf80HwD/IhIC/52FQ//Cr2z/x7Ny/8iycf/Hs3L/yLVy//////8qGgP/MhwA/zgeAP/m4uH///72/zEaAP8AAAAAAAAAAAAAAAAyHAD/+vr6//z9+f8xHAD/9Pne//z53f/8+d3/+/jc//v52//7+Nz/Nx8D//v33v/6+d//+Pjg//j44P/5+eH/+fnh//r64v/6+uL/+vnf//z74f/6+d//+vnf//r53//6+d//+fnh//n54f/6+uL/+vnf//n43v83IQX/+/fl//n45P/5+eH//fjj//z43//8+uj////t//n54f/3+eP/Mx0B////+P/z8fD/MRoA/wAAAAAAAAAAAAAAAAAAAAAyHAD///79//7+/v8wGwD/MhwA/zIcAP8yHAD/MhwA/zMdAf8zHQH/Mx4D/zQeAv8zHgL/MRwB/zEcAf8zHgL/MhwA/zIcAP8zHAL/Mx4C/zMeA/8zHgL/Mx4D/zAZAP8wGAD/MBgA/zAYAP8wGAD/MhsB/zIbAf8xGgD/MBsA/y8ZAP8xGgD/MRoA/zMbA/8yGwH/MRoA/zIbAf8yGwH/MxsD/9TU1P///v3/MRoA/wAAAAAAAAAAAAAAAAAAAAAAAAAAMx4A//39/f///v7/MhsB////+/8uGgH/MxsA/0gqAf+uj1D/wKFi/zYeAv+rhjT/LxwB/9m+bv8zHQH/2cJ2/zEcAP/WvG//Mh0B/8e0d/+7o2n/jXdH/zMcAv///////////zIcAP/Zu2j/1Llp//////83HQX///////////8yGwH///79///+///+//3////+/////v8yHAD///z+//r49/8yGQD/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMhwA//7+/v/k5OT/Lx4E/zIcAP8cCQH/HAkB/zQcAP/v1JT/wqZm/zYeAv/auWr/Lx4D/9e+bv81HQH/2MB0/zMeA//Vu27/Mx0B///usf/myJf/Oh0C/////////////////zIcAP/WuGX//P/9//////8zHQT//////zMdAf8gDQD/IA0A/yIMAf8fCwD/HgoA/zQfAP8zHQH///////37+v8yGwH/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADIcAP///////////zEcAf8xHAH/NB8D/zMdAf///v3/28CH/zQbAf/cu2z/2L1s/zQfBP81HQH/2L5x/y4eAf/EqGv/NR0A/4NtPf84IAT/KhoD/////////////////zccAf///f///v/9//v///80HQP/+fj0/zQbAf8yHAD/MhwA/zIcAP8yHAD/MRoA/zIcAP/7/Pj///38/zEaAP8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADIcAP82HwX///////36/P8xHAH/KhYF//////81HAL/7dmq//nnuP8xGwL/17xr//7/9v8zHQH/3cOA/93Kjf8sGwD//+yz/zQcAP8zHQH//v/9////////////FQgA//3x5f/////////5/zMeAv/+//3/MRoA//3////7/f3/+/39//z+/v8qFAL/MRwA//38/v/9/f3/Nx0F/zEaAP8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAyHAD/OiYV//j59///////MRwB/zIcAP8zHQH/OB8F/9zIpf/p26v////x//////8jEQD//f39//LepP/e0J//WUkf/9rCiP8zGwP//v/9///////v7ur/ORwB////////////MRoA//7+/v/+//3/MhwA/zIcAP8yGwH/MRwA/zIcAP8yHAD/+Pr6/////////Pf/MRoA/wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMhwA//z9+f/5+vj//v/9/zEaAP80HAT/Mx0B/yoVAP///tj///////////////v/MhwA//z//f/ZzZf/KxoA/9i+cv82IQL//v/9//////8yHAP/NB8A//////8yHgD/rpdZ//z//f8xGgD/KBIA//v5+f/8/Pz/MhwA/zIcAP/9//////////////8xGgD/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADIcAP/8/vj/5+fn//3++v8xGwL/MhwA/zMdAf/8/vj//////zIdB/8yGwH/MRoA/zIcAP///v///vPY/9q9cv82Hgb//v/9////////////Mh4A/zQfAP81HQD//f7u/y8cAf8vHAH/NRwC/zEcAP8yHAD/NBwA/////v/////////+/zEaAP8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAyHAD//f/2//v7+///////GwgD/zIcAP8zHQH/Mx4C/zIcAP8vGQD/MRwB/zIdAv8yHAD/8e7m/9q/df81IAH//v/9////////////MxwC/zIcAP8yHAD/MhsB/zEcAP8xHAD/MhwA/zIcAP8vGQf///////////////r/MRoA/wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMhwA/zchCP////////////7//f8xHAD/MRwA/zEcAP8rEwH/PCoZ//v7+/8xHAD/NSAA/+7dnv/Ft4b//v/9//////8xHQD/MhwA///98/8zHQv/MRkB/zEYBP8yGwH/MhwA//Lx8//9+/r//////yIRBP8xGgD/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADIcAP8wGwD///79/////////////////zQhBv8zHQH/Mx0B/zAbAP8wGwD/SkAv/zIcAP/79ML//v7+/zEaAP8vGAL/MhwA/zIcAP8yGwH/MhsB/y8dBv/9/f3/8vLy//39/f/+//3/MRoA/zEaAP8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMhwA/zIZBf/9/////f///////////////////zAZA/8vHAH/MRwA/zIcAP8wGwD/MhwA/zEcAP8zHQH/NBwA/zMeAP///f3/9/f3////////////9vj4/zMaCv8xGgD/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAxGgD/MBkA///9/P/+/v7//v/9///////////////////////c2dH/t66k//v7+////////////+zq6f/h4Nz///7///z//f8vGQD/MRoA/wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADIbAf8yGgT/MhsB/yEOAf/+//3//f/////////9///////////+/v/+//3//////09AN/8wGwD/MRoA/zEaAP8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADEdADQyHAD/MhwA/zIcAP8yHAD/MhsB/zMcAv8xGgD/MhsB/zEZADQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA///gB///AAD//wAA//8AAP/8AAA//wAA//AAAA//AAD/wAAAA/8AAP+AAAAB/wAA/wAAAAD/AAD+AAAAAH8AAPwAAAAAPwAA+AAAAAAfAADwAAAAAA8AAPAAAAAADwAA4AAAAAAHAADgAAAAAAcAAMAAAAAAAwAAwAAAAAADAACAAAAAAAEAAIAAAAAAAQAAgAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIAAAAAAAQAAgAAAAAABAACAAAAAAAEAAMAAAAAAAwAAwAAAAAADAADgAAAAAAcAAOAAAAAABwAA8AAAAAAPAADwAAAAAA8AAPgAAAAAHwAA/AAAAAA/AAD+AAAAAH8AAP8AAAAA/wAA/4AAAAH/AAD/wAAAA/8AAP/wAAAP/wAA//wAAD//AAD//wAA//8AAP//4Af//wAAKAAAABgAAAAwAAAAAQAgAAAAAABgCQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADAbAP8zHQH/IAkB/ycTAf8xGgD/MRoA/wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADEaAP8mGQD/7+bB//3uwP8vGAL/MBsA/y4bAP8rFgD/va59/9DEoP+hlnj/MRoA/wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMR0A//fsxv81IAH/MhsB/zIcAP84JRD/PS0c/0M1I/8uGQP///76/zEcAP8yHQH/7+a6/y0aAP8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD99tv//Pjg/zIcAP80HwD/MRwA/zEcAP80GwH/MhsB/zIcAP8wGwD////////tsP/r6+v/MRwB//Pdlv/968b/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADIdAf/18tb/MhwA/zcgAP8yHAD//////zgcAP82GwD/MxoA/zMeAv8xGQH/Lx8C/+3Xp////////f///zIaBP/z+eL/3sNy/wAAAAAAAAAAAAAAAAAAAAAAAAAAMx0B/+3drv8zHQH/MhwA/zEcAP81Jgz/+Pfj//r45v8zHQH/Mx4A///////+/v7/////////////////NB4C/zMdBP8qGAH//////y8ZAP8AAAAAAAAAAAAAAAAxGgD//fPD/zMdAf8yHQL/MBkA/0o/Mf8zGwD//////////////////////zIdAv/068b/+Pjg/////v8hEAP//////zMdAf8eDgH/MhwA//3///8xGgD/AAAAAAAAAAAnEwH/NCAB//v74/8vFwD/MRsA/zQcAP8xGgD/+vnf//v74//9+t7////n///////+/vL/+vri//n54f/Xv3P/+Pjg//f54//3+eP/+Pjg/zUcAv+QhYH/AAAAAAAAAAD29eH/NB8A//r64v8xHwL/Mx0B//r23f/3+N7/9/nj//f54//6+d//+vTh//j65P/6+d//+Pjg//f33/81HwP/+Pnf//b44v/3+eP/+fnh/zIcAP/49OH/AAAAADIcAP/t6tz/JBIB//////8wGwD/MRwA//////8zHgL//v7+/////////////////zIcAP////////////////8zHgL/MBsA/5mPiP//////MBsA/zAYAP///Or/MBsA/zIcAP///v7/Mx0B/////////////////////////////////zEcAP/+//3//////xwPAf//////NR0B//////8yHAD/NBwA////////////MRwA/zIcAP////v/MRoA/zAZAP83HgT//f///////////////////zEaAP//////IREA/zAeAf///////////zMdAf////////////////8xHAD/Mx4D///////////////5//////82IAT/Nh4I/zMeAP83HwH/NB8D/zUcAv///////////zEcAP//////IRMA/zMdAf8yHAD/Mx0B////////////LR0A/zAbAP8yGwH///////39/f81IAX//////zIbAf8zHQH/OCEL/zQfAP////n/MRwA/zIcAP//////LxkA/zAbAP/+/v7////////+////////Mh0C////+v////////76//////8zHQH//////zMdAf8zHQH//////zMeAP+Ddmj/MhwA/zIcAP/9+/r///////7//f8sGwD/MhwA//3///8yHAD/+PLl//3///8qGQT/MhwA/zMdAf/+/Pv//f///zEbAP9eUUH//////zAYAP////v///////z//f/9////MhwA/wAAAAD+/v7/MhwA/9W7Yf/Vu2H/1bpj/9e8Yv/Uu2X/07tn/9K6Zv/WvWf/1rpm/9e8Yv/Xu2T/1rpj/9i7Zv8zHgL/2bxr/9q9bP/XvGv/1Ldm/zMdAf//////AAAAAAAAAAAwGAD/PSYM//X34f/0897/9Pbg//ny4f/48eL/9/Tl//f14//29OL/9fXj//fz4P/59OX/+fXj//j14P8yHQH/9vPk//j25P8wGwD/+fXj/zEbAv8mFAP/AAAAAAAAAAAyHAD/8vDv/zIdAP8yHAD/KxEA/6+TVv+ogzP/2r9v/+HIgv/SuGz/7tSY/zUdAf//////38F6//3//P8zGwP/Mx0B/zIcAP8wGgH/MhwA//////8yGwH/AAAAAAAAAAAAAAAAMx0B//7//f8xHAH/NB8A//Peqv/bumr/MhsB/9W7bv/44rL/clw4//////////////76/zMdAf/+/v7/MRwA/zIcAP8yHAD///7//zEbAP8AAAAAAAAAAAAAAAAAAAAAAAAAAP/////k4uH/Mx0B/zciB//z4bj///////////8xHQD/n4ZU//////8pFAD///////7//f8xHAD/Mx8G/zIcAP/+/f////7+/wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD///r//v7+/zIcAP/8//r/MhwA/////////v//3sBz////////////Mx0B/zYeDP81Hwb/MhwA/////v/8//3/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMRwB//////9mWk7/MhwA/zMdAf81HQH///rJ//3///8yHAD/MhsB/zIbAf8fDgH//v/9/y4WAP8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADIcAP8yIhb///////////////7/MyAF/yoaA//07+7//fv6///////Wz8b/MRoA/wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADEaAP8xGgD/KRgF/xwMAP8yHAD/MRoA/wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP+B/wD8AD8A+AAfAPAADwDgAAcAwAADAIAAAQCAAAEAgAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIAAAQCAAAEAgAABAMAAAwDgAAcA8AAPAPgAHwD8AD8A/4H/AA==",
      asSource: true,
      asTarget: true,
      uploadPath: "/upload.php",
      seedDomSelector: "#outer > table",
      torrentDownloadLinkSelector: 'a[href*="download.php?id="]',
      needDoubanInfo: true,
      search: {
        path: "/torrents.php",
        imdbOptionKey: "4",
        nameOptionKey: "0",
        params: {
          incldead: "0",
          search_area: "{optionKey}",
          search: "{imdb}",
          sort: "5",
          type: "desc"
        }
      },
      name: {
        selector: 'input[name="name"]'
      },
      subtitle: {
        selector: 'input[name="small_descr"]'
      },
      description: {
        selector: "#descr"
      },
      imdb: {
        selector: 'input[name="url"][type="text"]'
      },
      douban: {
        selector: 'input[name="douban_url"]'
      },
      anonymous: {
        selector: 'input[name="uplver"]'
      },
      torrent: {
        selector: 'input[name="file"]'
      },
      mediaInfo: {
        selector: 'textarea[name="technical_info"]'
      },
      category: {
        selector: "#browsecat",
        map: {
          movie: "401",
          tv: "402",
          tvPack: "402",
          documentary: "404",
          concert: "408",
          sport: "407",
          cartoon: "405",
          variety: "403"
        }
      },
      source: {
        selector: 'select[name="source_sel"]',
        map: {
          uhdbluray: "10",
          bluray: "1",
          hdtv: "4",
          dvd: "3",
          web: "7",
          vhs: "8",
          hddvd: "8"
        }
      },
      videoCodec: {
        selector: 'select[name="codec_sel"]',
        map: {
          h264: "3",
          hevc: "0",
          x264: "3",
          x265: "0",
          h265: "0",
          mpeg2: "17",
          mpeg4: "1",
          vc1: "16",
          xvid: "5"
        }
      },
      resolution: {
        selector: 'select[name="standard_sel"]',
        map: {
          "4320p": "0",
          "2160p": "7",
          "1080p": "1",
          "1080i": "2",
          "720p": "3",
          "576p": "5",
          "480p": "5"
        }
      }
    },
    fearnopeer: {
      url: "https://fearnopeer.com",
      host: "fearnopeer.com",
      siteType: "UNIT3D",
      icon: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAYAAACNiR0NAAAACXBIWXMAAAPoAAAD6AG1e1JrAAACnklEQVR4nK1UO0hjURA9KRIw6EOUYIgWaqVRMRjBQtFnWgujkCLgBwsRERRMZZIiiJqAKIiVqPgjLAiSNJqPIClsBBtFxC4WtjYr2OlZ5vKy7Kq7G1wHhvvevJnz5pw79wIfmwWADmADwBWA7wBejPXKiOtG3j/NBsADIAwgBSAP4BnAq7HmjXjYyLP9CcgEoAxA0ChiEZ438suM+t9Mgt8APBYJVvBHo67sLc3gJ8D4C2iwQN9saFEszb/R9wigbrVaQ1VVVWxoaGBLS4vy1tZWut1utZaWlr4DqK2tVXlNTU2qrq6ujpqmhQRww263p0dGRnh0dMREIsHd3V3u7OwwmUxyb29PFQmIyWSixWJRz0tLS8xms9zf3+fy8jLX19fp8XjSAnitaVq+v7+ft7e3jMVibGxspNlspnRdUlKingXE4XBQfizvq6urzGQyHB8fZ2VlJS8vL7m1tSW08VRdXf08Pz/P+/t7lej3+xVdKQwEApyYmGB9fT1dLhcPDg5ot9t5eHjIeDzOrq4uFX94eODi4qLMKV6cTufr8fExb25uVPuDg4NKF5vNxlwux7OzMw4PD7O3t5fb29tsb29X3Z2cnHB6eprBYJCbm5vs6emR4cdTR0fHs4CJhkJJqIpWAiBFqVSKKysrnJycVBRHR0d5fn6u9J6ZmeHs7Czb2tqkRnV43dfXl7+7u+PU1BQrKip+7mIkEuHc3BwHBga4tramKIoUIsvFxQXHxsbej47P59uIRqPp09NTRaWwi6LT0NAQu7u71dh4vV6Gw2G1YQsLCwpU1/W3gGl0dnbqbrc71NzcTKvVqkZDPgqwaFiYwfLyctbU1Khdl+7FNU17Cxj68KQUQD97Ur78LMOwL71txL78PizYf93YPwA8btamn3E35AAAAABJRU5ErkJggg==",
      asSource: true,
      asTarget: true,
      uploadPath: "/torrents/create?category_id=1",
      needDoubanInfo: true,
      seedDomSelector: ".torrent__buttons+.panelV2",
      torrentDownloadLinkSelector: 'a[href*="/torrents/download/"]',
      search: {
        path: "/torrents",
        replaceKey: [
          "tt",
          ""
        ],
        params: {
          name: "{name}",
          imdbId: "{imdb}",
          sortField: "size"
        }
      },
      name: {
        selector: "#title"
      },
      description: {
        selector: "#bbcode-description"
      },
      imdb: {
        selector: "#autoimdb"
      },
      tmdb: {
        selector: "#autotmdb"
      },
      mediaInfo: {
        selector: 'textarea[name="mediainfo"]'
      },
      anonymous: {
        selector: '.form__group input[type="checkbox"][name="anon"]'
      },
      torrent: {
        selector: 'input[type="file"][accept=".torrent"]'
      },
      category: {
        selector: "#browsecat",
        map: {
          movie: "1",
          tv: "2",
          tvPack: "2"
        }
      },
      videoType: {
        selector: "#autotype",
        map: {
          uhdbluray: "1",
          bluray: "1",
          remux: "3",
          encode: "12",
          web: "4",
          hdtv: "6",
          dvd: "1",
          dvdrip: "12",
          other: ""
        }
      },
      resolution: {
        selector: "#autores",
        map: {
          "4320p": "11",
          "2160p": "1",
          "1080p": "2",
          "1080i": "3",
          "720p": "5",
          "576p": "6",
          "480p": "8"
        }
      }
    },
    iTS: {
      url: "http://shadowthein.net",
      host: "shadowthein.net",
      siteType: "its",
      asSource: false,
      asTarget: true,
      icon: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAYAAACNiR0NAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAABmJLR0QA/wD/AP+gvaeTAAAAB3RJTUUH5QQMAxcfv8YO0wAABQ5JREFUOMutlF2MVPUZxn//c86cMzOH2ZllZ2YZYIddlv2gyAJiEWK9MKXEQk1TUYGqbaQ3LdoES1pNbFou2qSJadI0XDTWikntRzBpVD6k0hBJU8S1iwou7MCwOw7L7Lq7M+zsfJ3vvxerTZv2ss/Ve/HLm/d9nuSB/7PEXKpTm+hfZ06s+Edzdd6Obr5I/fw2jOQc4b7rcGErSLE1+NXTv61uHlkf6i4QaURZ2H+UWGEVmm3AwDWFE7u+7jxw4i917Ur/qt3Uc4fc0sCpjsrVHefu7T9yx+hoFthf13D7rqFMp3OzTu6Rbz30Kmsb8dhPSxvuO1Ruf+N7bQvcJQX+bCquhuqjw/qR5w5oq/K5+bzSXGcpy1N6S8nMyOmHkSFZU9S+UqdPf93Ft6xB74PUfb3jV6vFjuaW95SLu7e12BBEGPAV0J0q7lxbevdZ/zfa1NLl8zfsZrXRmvzDgpbs7ilUH/3Y8IP2sEKnHeCGw7ieQSqoRYKOFW/WDW90qLzwdKlDk2nLQ0iQIiCkiZCRQtOu3tVstoyhCcVLfzL84chaoyxZ3rKU/oZNMwKGDVpIRzYS8vUd6XQmNyajcw1Cniqk8PAVUAQ4ARTHQdvx2lT7hYw/dGvVmqC7Xlo/ZnjcE4D0QbdBCh+BT6RmBFtyf+03q3K9p4AbAtUDXwdfBflZykpuaHPvkrmqLqYLqt50ZO/8Am4koBiDyRh4IXClpLHSxZExpKWBhIgFjgFhCzQHVBfiAtTeR7ZXJmYraxur7+yyPdcpWCSy4CWFo4a9xXemTBNscamcHDjzTuCnroUjbRnctnDgC1dfvPR6IuFYyTv+qDz20hvF7xTLr6y5Pb5ma/Pj7sEus1Fvz0ybDQi7ix5aBKi11gE/0uw6WCjsXdj25V3pOlckoHngK1AP6aXKxtCU1nO7wkgmmWzNVOz5+lK77DbjCTVu2gbYOpgWVIhKA5GYjJl7FSnPBkIft3W31lRA+OD7UBDOjRdnsuNaAJSz2cCLBd6oHvHFzSJh6QuzsWi02oT8uvhkd8vMRwjtOvm1L506d8/g7NDlfEr1W/gq1FSFmY4Om1uPo/38wFMIX/1z4BcyD57/4FBbpURD1WlFQAC5lEHeajsTbN76fNtM/idD71/dV2WBmgpRINqCtxOdVPX06Ydv9vlKvbeHt/bvW9g4p32UKs97qqviSQPVB9WC4UjaHlm54k3riYeKG2/X87rXQOKB9ACYDcP5ZHuxNtjzd/Xe7ajHLl9m03sj38gWLx017PISXw+IeQ6ocNFYwvGevrPBzu2/fuLIC7/MFke/b1h1ITXQFIg6cNzsdM4tjR8+eez4qeErOZQVpZIiBXuXTU2ZIU9iuLCkKckpCke7+kanB1LP3S1NNTl7e/uy6YqCANODRA1eb0vwau/gyWDNht9/89Fvy+d/+CwaIDxNM/FASLBROd0e9c90rr70/qah7z7QcP7pes5KgUQBhCuouAqvrEw4b6cHTl784qYnzWJm/m/HngFAk0L4p7bc/eE7RvSrk5GQHDaXjY0vjb+s79z5p7Gx0Zt7+7+Ap6rudEivzWkRzkVizkSm492Psl0vZHfcf+LOWm3+rc+WAWg/3rMHRSgv30olqo2wcsONLx9+8KXfFScvvCtPAxw+zM8OHvzE2rPnR1OJeP98Mn49RPL8yLEXK18R+/gFP/jPxpZS/msGpBDiv2r935hF8H8wn+tTfi1WST2Ov5MAAAAldEVYdGRhdGU6Y3JlYXRlADIwMjEtMDQtMTJUMDM6MjM6MzErMDA6MDDUs4OrAAAAJXRFWHRkYXRlOm1vZGlmeQAyMDIxLTA0LTEyVDAzOjIzOjMxKzAwOjAwpe47FwAAAABJRU5ErkJggg==",
      seedDomSelector: "h1~.line>tbody>tr:nth-child(2)",
      needDoubanInfo: true,
      uploadPath: "/upload.php",
      search: {
        path: "/browse.php",
        params: {
          incldead: 1,
          search: "{imdb}",
          search_in: "names",
          sort: 5,
          type: "desc"
        }
      },
      name: {
        selector: 'input[name="name"]'
      },
      imdb: {
        selector: 'input[name="imdblink"]'
      },
      description: {
        selector: 'textarea[name="descr"]'
      },
      mediaInfo: {
        selector: 'textarea[name="mediainfo"]'
      },
      tags: {
        hdr: 'input[name="HDR10"]',
        hdr10_plus: 'input[name="HDR10Plus"]',
        dolby_vision: 'input[name="DolbyVision"]'
      },
      anonymous: {
        selector: 'input[name="anonymous"][value="true"]'
      },
      category: {
        selector: 'select[name="type"]',
        map: {
          movie: "68",
          tv: "65",
          concert: "61",
          music: "6",
          ebook: "26"
        }
      }
    },
    "nzbs.in": {
      url: "https://nzbs.in",
      host: "nzbs.in",
      siteType: "nzb",
      icon: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAYAAACNiR0NAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAABmJLR0QATwB9ALSzxfhxAAAAB3RJTUUH5QQMAx4c9w3kIAAAA6xJREFUOMt1lM9rVFcUxz/nvDszieOYMUrGxAR/RU0VreBCUFIo7UIRUqEroUJLVyJ02x9QaKHrLtq/oKUUpKvSdV0VoRulBEG0JJpR44+aTExiMvPuPaeLN5lQ2x54D+65j885993v+crZz645/4ju0gUnQ9SpkHCB3DLMQTAQB4TivRnhXzDf3DaLHB6pcumtfYgIP/x6j9tzy2gmuNOD8r/ALs9RUkqc2Fdj6tQog+M7cHHezSO/XH/A9OwLyDJwR16Bhk2WI9284hwcrTJ1apTjxxt81emwps7nx3YylSDv3Ofu43VS7wcVUAG0B3PBXcgEdg2U+PDsOG+cGOZ5jDQ9Z94TC9GYPN7g/XMHGa4HsgzEpfsUWMWLAgJkRBp14eOLRzi6t455YixkvBeUDzTjoAZM4OieOh9fPMbueongEe0d2VEXBxGiJQ4M93PlwhH276pRDoqIUBI4Hyqcz8pk4kWulLGnsZXL70ywf2QL0SJO0WIIYiQpcWhvjbdf38nE2CC5wbV7OQ9XjLGqMDlWwgWuz0XmVpzRmjM5Eji8ZzvnTo9RuvGMO3OriIBcvnrPV2NgohE4s7ePTJU7C86NVomyRE7WE2utZRZXE82lyFJHKKVF1m/+xMulBXB43mrzvNVBRAhP/rxBa1XJZw2ZEYI4TR/gafU1tvc7z1S4df8FFRfWOhGLQifvMHv/MU8ePcQMREGl0Ka8+dGPLgJu4BF2bqvwyaWTfDc/xPXH4O40thpfninz/bTx2wPh9AhcmVjn66u3eLq0hoj0pBMqtRHEQUjgTq3ex67hBvZXiRUvdDW/bnz7B8wsBVZESJlTq1aIrrSjdIHFTQfFMTXcHHMnOkR3zCF1P3uZC7/PG6iCFrmeiHFMQLsWEBbtNn1a5VA2jmrGYKmfIMpudY5oQivGtpoytyDUvMPDFBBXRKAeKvSFosKGEtU1kHmZdjTWUyK5kQHJnVUzDg8KX5wOTGw3TIr8RrQt8TLltGOkHXPaMUfrNk7wBo/IabLGI1smx5g3ZSaVaXnG8Bbn08nAYCOw7IrjGLBiOQ+8TVPWadKmSZuAOI6jruCyOUTuuAnujgoM90MVw5KSKG5VETIE9WLaem4jPccohrqkwtSBjKODcGAAgijgXNgPx3Yo+waUssRNrxHpWe0rBiu0c2N6ZpGhWomhLSC5cPNusTckzlDVsQjTsx3aeexZ3n8arIjSWja++fk2Ilb07pvFpGt1LoAX4A3xbMTfU7u3vspnhj4AAAAldEVYdGRhdGU6Y3JlYXRlADIwMjEtMDQtMTJUMDM6MzA6MjcrMDA6MDBRcNLMAAAAJXRFWHRkYXRlOm1vZGlmeQAyMDIxLTA0LTEyVDAzOjMwOjI3KzAwOjAwIC1qcAAAAABJRU5ErkJggg==",
      asSource: false,
      asTarget: false,
      search: {
        path: "/search",
        params: {
          query: "{name}"
        }
      }
    },
    zimuku: {
      url: "http://zimuku.org",
      host: "zimuku.org",
      siteType: "subtitles",
      icon: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAMAAABEpIrGAAAABGdBTUEAALGOfPtRkwAAACBjSFJNAACHDwAAjA8AAP1SAACBQAAAfXkAAOmLAAA85QAAGcxzPIV3AAACXlBMVEUbbZ0ZbJwAWpCpx9n///4DWIoZbJ0abJwEXpP6/P3///+5yNEAW5EIYZbK1NlMgJ8QaJsZa5wDXpQAQ3rd4+b///0AUIMDXpMYbJ0OZJcYX4kYbJ4LYZQTR2UYbqEabJ0AWo8FQGIab6EAGC4ALU8ALU0ALE0AIUMAPWIBXJETTW4WcKYZcKIacKMMZpoKRmkZbqARZZcJRGUnd6YWaZoNZJcMY5YJYZUIYpUeU3MYbaAPZ5qjq7CnpKOZlZNCa4MOWodzjJuBhol8foAISG0bb6EabZ0KYJIHW4wAV4pbmLshUm8MZ50NZJgOZpkbbZ4SaJtYkrUjVHIXbaAPZpgrUGYVPVQOOlQKOFMLOFMAK0oiRVr08vBeX2AJTXUbb6AXbqEYb6IZcKMSa6AAXJWHtdC4sawAHzQMYpUbcKIRZ5k4fqjs8vZFTE8APWYac6gbbp4Ya5sgb53l3dkCHzAOZJgccaMIYZUBXJICXZIASoWkpKQAEjcAY50CXpQCXJIWa50HYJTW4+z9/f33+fr2+Prz9vjy8/T1/P/9/f4oapEXa53n7fM1YHgVbJ/09/s5ZHwVa50+c5NXZm9DW2k/WWk+WWkqSVv5+fmLkpc1U2Q/WmpOZXNmdn+EiIoLQ2QacKEVa5wSap4TbKAUbKD6+/xthJMJaKASa58QaZ0OZZn7/PxxhpQPaJwOZZcAVY32+PlmnLyArcdqnr1kmrtwhZIGYJTf6O5OanoTa59tnboAMU8acKIWapsoc5/99PA6Q0cQZpgSaZyFkplXanY2VGYJNU8ANlsSaJobbp8uYKy2AAAAAWJLR0QKaND0VgAAAAlwSFlzAAAOxAAADsQBlSsOGwAAAAd0SU1FB+UGBAQjFV4CeTAAAAGYSURBVDjLY2BAAEYmZhZWNgacgJ2Dk4uLmwebDBTw8nFxcfELsMMBVF6QAwqEhEW4uETFxGF8DgmIzZJcuICUNFiBDE4FsnIgBfIKOBUoKoHt4AEylVVUUYGaOlBUA6yAXRPI1NLW0UUBOnpAUX0DsBsMgUwjYxNTM2RgbgEUtbQCm2BtY2tnj2G/g6OTs4sr2A1u7h6eXhgKvH18/VxhQekfEIihICgYObDdQkLDwiMigSAiKjoGJB8bF48SHW4JiUkgkJySCpJOS8/IxBqhWdk5IPncvPwClMiEsQqLQNLFJaVlyBLs5ZoVlVBQBZSvrqmtA3MqNOsbQAoam7iaW1ohoA2ooL0Dwm7p5OLq6gYq4OjBGVlcvX0gBf24FUwAKZg4afKUqdMgYPoMLq6ZsyDs2XPmzpu/AOSIhYsWL4GClKVcXMuWQzkrVq5SQg+HitVcXGvW4k74lCrIWheyfgMeBVkbN23eAvTaVlwKtm2H+H3HThwKQnZBFOzeg0PB3n0g6f0HDvrjUMB+6PCRo8eOnziJKgwAyLSNK8OfEhgAAAAldEVYdGRhdGU6Y3JlYXRlADIwMjEtMDYtMDRUMDQ6MzU6MjErMDA6MDAJeY68AAAAJXRFWHRkYXRlOm1vZGlmeQAyMDIxLTA2LTA0VDA0OjM1OjIxKzAwOjAweCQ2AAAAAABJRU5ErkJggg==",
      asSource: false,
      asTarget: false,
      search: {
        path: "/search",
        params: {
          q: "{imdb}"
        }
      }
    },
    "豆瓣电影": {
      url: "https://search.douban.com",
      host: "search.douban.com",
      siteType: "douban",
      icon: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAsAAAALCAMAAACecocUAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAA2FBMVEUWgSUAdQ4AdA0AdQ0NfR1sr3aZyKCWx50KexlUn110r3tyrnlWn14LehoAdhAegiuGuYuRwJaOvpOOv5OGuowhgiwCdhEAdg8wjT3j7+WgyqRdo2Fgpmadx5/i7+QHdRR3sn8efyojgi9zsHvf7eIJdRUpiTbS5dWz1biv0rRipmnw9/FPmlgngzPu9e9cpWYMdRcHehcdhCtLnVbY6dp1r3wthTZInVQihC4VeR8oizaq0LDR5dTY6dvV59jO49Gr0LApizYhhjAwjz07lUg6lUc6lUj///+7fLO6AAAAAWJLR0RHYL3JewAAAAd0SU1FB+UEDxExDPWxFNkAAAB/SURBVAjXFcbZAoFAAAXQWyqEKEtDTMJUyF7WCm3//0nMeTqAINY4UQAkWalziiyh0VRbnNruQOv2dKNv6IPhCCYZT6ypNaPE/p/OnYWzXBEG0/Wov/ap5zJo9mYb7IL9gR1xOl/C6BqFt/sDz1ecpO80iT9fZHlRVkVVFnn2A2t6DyUkoLRcAAAAJXRFWHRkYXRlOmNyZWF0ZQAyMDIxLTA0LTE1VDE3OjQ5OjEyKzAwOjAw+Ka3VAAAACV0RVh0ZGF0ZTptb2RpZnkAMjAyMS0wNC0xNVQxNzo0OToxMiswMDowMIn7D+gAAAAASUVORK5CYII=",
      asSource: false,
      asTarget: false,
      search: {
        path: "/movie/subject_search",
        params: {
          search_text: "{imdb}"
        }
      }
    },
    "豆瓣读书": {
      url: "https://search.douban.com",
      host: "search.douban.com",
      siteType: "doubanBook",
      icon: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAsAAAALCAMAAACecocUAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAA2FBMVEUWgSUAdQ4AdA0AdQ0NfR1sr3aZyKCWx50KexlUn110r3tyrnlWn14LehoAdhAegiuGuYuRwJaOvpOOv5OGuowhgiwCdhEAdg8wjT3j7+WgyqRdo2Fgpmadx5/i7+QHdRR3sn8efyojgi9zsHvf7eIJdRUpiTbS5dWz1biv0rRipmnw9/FPmlgngzPu9e9cpWYMdRcHehcdhCtLnVbY6dp1r3wthTZInVQihC4VeR8oizaq0LDR5dTY6dvV59jO49Gr0LApizYhhjAwjz07lUg6lUc6lUj///+7fLO6AAAAAWJLR0RHYL3JewAAAAd0SU1FB+UEDxExDPWxFNkAAAB/SURBVAjXFcbZAoFAAAXQWyqEKEtDTMJUyF7WCm3//0nMeTqAINY4UQAkWalziiyh0VRbnNruQOv2dKNv6IPhCCYZT6ypNaPE/p/OnYWzXBEG0/Wov/ap5zJo9mYb7IL9gR1xOl/C6BqFt/sDz1ecpO80iT9fZHlRVkVVFnn2A2t6DyUkoLRcAAAAJXRFWHRkYXRlOmNyZWF0ZQAyMDIxLTA0LTE1VDE3OjQ5OjEyKzAwOjAw+Ka3VAAAACV0RVh0ZGF0ZTptb2RpZnkAMjAyMS0wNC0xNVQxNzo0OToxMiswMDowMIn7D+gAAAAASUVORK5CYII=",
      asSource: false,
      asTarget: false,
      search: {
        path: "/book/subject_search?search_text={name}"
      }
    }
  };
  const BROWSER_LANGUAGE = navigator.language.toLowerCase().split("-")[0];
  const getSiteName = (host) => {
    let siteName = "";
    try {
      Object.keys(PT_SITE).forEach((key) => {
        const siteKey = key;
        const hostName = PT_SITE[siteKey].host;
        const matchReg = new RegExp(hostName, "i");
        if (hostName && host.match(matchReg)) {
          siteName = siteKey;
        }
      });
      return siteName;
    } catch (error) {
      if (error.message !== "end loop") {
        console.log(error);
      }
      return "";
    }
  };
  const CHINESE_REGEX = /[\u4e00-\u9fa5]+/;
  const getSortedSiteKeys = () => {
    return Object.keys(PT_SITE).sort((a2, b) => {
      const aHasChinese = CHINESE_REGEX.test(a2);
      const bHasChinese = CHINESE_REGEX.test(b);
      if (aHasChinese && !bHasChinese) return 1;
      if (!aHasChinese && bHasChinese) return -1;
      return a2.toLowerCase().localeCompare(b.toLowerCase());
    });
  };
  const SORTED_SITE_KEYS = getSortedSiteKeys();
  const CURRENT_SITE_NAME = getSiteName(location.host);
  const CURRENT_SITE_INFO = CURRENT_SITE_NAME ? PT_SITE[CURRENT_SITE_NAME] : void 0;
  const CONFIG$4 = {
    URLS: {
      IMGBOX: "https://imgbox.com",
      PTPIMG: "https://ptpimg.me",
      HDB_UPLOAD: "https://img.hdbits.org/upload_api.php",
      IMGBOX_UPLOAD: "https://imgbox.com/upload/process",
      PIXHOST_UPLOAD: "https://pixhost.to/remote/",
      PTPIMG_UPLOAD: "https://ptpimg.me/upload.php",
      IMGBB: "https://imgbb.com/json"
    },
    ERROR_MESSAGES: {
      UPLOAD_FAILED: "上传失败，请重试",
      PTPIMG_UPLOAD_FAILED: "ptpimg上传失败",
      NO_API_KEY: "请到配置面板中填入ptpimg的api_key",
      NO_TRANSFER_NEEDED: "无需转存"
    },
    FILTER_IMGS_NAMES: [
      "poster.jpg",
      "2019/01/04/info.png",
      "MoreScreens",
      "PTer.png",
      "ms.png",
      "trans.gif",
      "PTerREMUX.png",
      "PTerWEB.png",
      "CS.png",
      "Ourbits_info",
      "GDJT",
      "douban",
      "logo",
      "2019/03/28/5c9cb8f8216d7.png",
      "_front",
      "info_01.png",
      "screens.png",
      "04/6b/Ggp5ReQb_o",
      "ce/e7/KCmGFMOB_o"
    ]
  };
  const en$1 = {
    "豆瓣链接获取失败": "Failed to retrieve Douban link",
    "豆瓣ID获取失败": "Failed to retrieve Douban ID",
    "获取豆瓣信息失败": "Failed to retrieve Douban information",
    "缺少IMDB信息": "IMDB information missing",
    "获取失败": "Retrieval failed",
    "获取成功": "Retrieved successfully",
    "请求失败": "Request failed",
    "上传失败，请重试": "Upload failed, please try again",
    "封面上传失败": "Poster upload failed",
    "ptpimg上传失败": "PtpImg upload failed",
    "请到配置面板中填入ptpimg的api_key": "Please enter your PtpImg API key in the settings panel",
    "数据加载中...": "Loading data...",
    "获取图片列表失败": "Failed to retrieve image list",
    "转换中...": "Converting...",
    "转换成功！": "Conversion successful!",
    "获取中...": "Retrieving...",
    "缺少豆瓣链接": "Douban link missing",
    "本种子可能禁止转载，确定要继续转载么？": "This torrent may be prohibited from transfer. Are you sure you want to continue?",
    "手动输入豆瓣链接": "Enter Douban link manually",
    "获取豆瓣简介": "Retrieve Douban info",
    "获取豆瓣读书简介": "Retrieve Douban Book info",
    "转缩略图": "Convert to thumbnails",
    "快速检索": "Quick search",
    "一键群转": "Batch transfer",
    "快捷操作": "Quick actions",
    "一键转种": "One-click transfer",
    "转种站点启用": "Enable sites for transfer",
    "批量转种启用": "Enable sites for batch transfer",
    "一键批量转发到以下选中的站点": "One-click batch transfer to selected sites below",
    "站点搜索启用": "Enable sites for search",
    "图床配置": "Image hosting settings",
    "如何获取？": "How to obtain?",
    "额外功能关闭": "Disable extra features",
    "关闭转缩略图功能": "Disable thumbnail conversion",
    "关闭站点图标显示": "Hide site icons",
    "关闭转存图片功能": "Disable image rehosting",
    "保存": "Save",
    "取消": "Cancel",
    "错误": "Error",
    "成功": "Success",
    "保存本地站点设置失败": "Failed to save local site settings",
    "请先设置群转列表": "Please configure batch transfer list first",
    "转种页面已打开，请前往对应页面操作": "Transfer pages opened. Please navigate to the corresponding pages to proceed",
    "提示": "Tip",
    "转存截图": "Rehost screenshots",
    "无需转存": "No upload needed",
    "上传中，请稍候...": "Uploading, please wait...",
    "不显示致谢内容": "Hide acknowledgments",
    "拷贝": "Copy",
    "已拷贝": "Copied",
    "不显示豆瓣按钮和豆瓣链接": "Hide Douban button and link field",
    "请填写正确链接": "Please enter a valid link",
    "批量检索": "Batch search",
    "同时打开多个搜索标签页": "Open multiple search tabs simultaneously",
    "豆瓣配置": "Douban configuration",
    "关闭快速检索": "Disable quick search",
    "种子文件下载失败": "Torrent file download failed",
    "请手动下载": "Please download manually",
    "获取页面配置": "Retrieve page configuration",
    "配置已复制到剪贴板,请黏贴到创建的Github Issue中": "Configuration copied to clipboard. Please paste it into a new GitHub issue"
  };
  const ko = {
    "豆瓣链接获取失败": "더우반 링크 얻기 실패",
    "豆瓣ID获取失败": "더우반 ID 아이디 얻기 실패",
    "获取豆瓣信息失败": "더우반 데이터 얻기 실패",
    "缺少IMDB信息": "누락된 IMDB 정보",
    "获取失败": "요청 실패",
    "获取成功": "데이터 요청 성공",
    "请求失败": "요청 실패",
    "上传失败，请重试": "업로드 실패, 다시 시도하세요.",
    "ptpimg上传失败": "PtpImg 업로드 실패",
    "请到配置面板中填入ptpimg的api_key": "설정 패널에 ptpimg의 API_KEY를 입력하세요.",
    "封面上传失败": "포스터 업로드 실패",
    "数据加载中...": "데이터 불러오기 중...",
    "获取图片列表失败": "이미지 목록 얻기 실패",
    "转换中...": "변환 중...",
    "转换成功！": "변환됨!",
    "获取中...": "요청 중...",
    "缺少豆瓣链接": "더우반 링크 누락",
    "本种子可能禁止转载，确定要继续转载么？": "이 토렌트의 전송이 금지될 수 있습니다, 계속하겠습니까?",
    "手动输入豆瓣链接": "더우반 링크 입력",
    "获取豆瓣简介": "더우반의 데이터 얻기",
    "获取豆瓣读书简介": "더우반 도서 데이터 얻기",
    "转缩略图": "썸네일로 변환",
    "快速检索": "빠른 검색",
    "一键群转": "일괄 전송",
    "快捷操作": "빠른 작업",
    "一键转种": "전송 대상",
    "转种站点启用": "전송 대상 섹션의 사이트 선택",
    "批量转种启用": "일괄 전송 버튼을 사용할 사이트 선택",
    "一键批量转发到以下选中的站点": "아래에서 선택한 사이트로 원클릭 일괄 전송하기",
    "站点搜索启用": "빠른 검색 섹션에서 사이트 선택",
    "图床配置": "이미지 호스트 설정",
    "如何获取？": "어떻게 얻나요?",
    "额外功能关闭": "추가 기능 끄기",
    "关闭转缩略图功能": "썸네일로 변환 버튼 제거하기",
    "关闭站点图标显示": "아이콘 제거하기",
    "关闭转存图片功能": "이미지 리호스팅 기능 끄기",
    "保存": "저장",
    "取消": "취소",
    "错误": "오류",
    "成功": "성공",
    "保存本地站点设置失败": "로컬 사이트 설정 저장 실패",
    "请先设置群转列表": "먼저 일괄 전송 목록 설정",
    "转种页面已打开，请前往对应页面操作": "전송 페이지가 열렸고, 해당 페이지로 이동하여 작업",
    "提示": "힌트",
    "转存截图": "다른 호스트에 스크린샷 업로드",
    "无需转存": "업로드할 필요 없음",
    "上传中，请稍候...": "업로드 중, 잠시만 기다려주세요.",
    "不显示致谢内容": "감사 내용을 포함하지 않음",
    "拷贝": "복사",
    "已拷贝": "복사됨",
    "不显示豆瓣按钮和豆瓣链接": "더우반 버튼 및 링크 필드 숨기기",
    "请填写正确链接": "올바른 링크를 입력하세요.",
    "批量检索": "일괄 검색",
    "同时打开多个搜索标签页": "여러 검색 탭 동시에 열기",
    "豆瓣配置": "더우반 구성",
    "关闭快速检索": "빠른검색 비활성화",
    "种子文件下载失败": "토렌트 파일 다운로드 실패",
    "请手动下载": "수동으로 다운로드해주세요",
    "配置已复制到剪贴板,请黏贴到创建的Github Issue中": "설정이 클립보드에 복사되었습니다. 생성한 Github Issue에 붙여넣으세요.",
    "获取页面配置": "페이지 설정 가져오기"
  };
  const i18nConfig = {
    en: en$1,
    ko
  };
  class HTMLToBBCodeConverter {
    constructor(siteInfo) {
      this.convertRgbToHex = (rgb) => {
        const rgbMatch = rgb == null ? void 0 : rgb.match(
          /^rgba?\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*/i
        );
        if (!rgbMatch || rgbMatch.length < 4) {
          return "";
        }
        const hexComponents = rgbMatch.slice(1, 4).map((component) => {
          return `0${parseInt(component, 10).toString(16)}`.slice(-2);
        });
        return `#${hexComponents.join("")}`;
      };
      this.siteInfo = siteInfo;
    }
    /**
     * Check if the site matches the given site match
     *
     * @private
     * @param {SiteMatch} siteMatch
     * @returns {boolean}
     */
    isMatchingSite(siteMatch) {
      const { siteName } = this.siteInfo;
      if (typeof siteMatch === "string") {
        return siteName === siteMatch;
      }
      return !!siteName.match(siteMatch);
    }
    /**
     * Check if the text is a special control text (should be ignored)
     *
     * @private
     * @param {string} text
     * @returns {boolean}
     */
    isSpecialControlText(text2) {
      return !!text2.trim().match(
        /^(引用|Quote|代码|代碼|Show|Hide|Hidden text|Hidden content|\[show\]|\[Show\])/
      );
    }
    /**
     * Normalize the color format
     *
     * @private
     * @param {string} color
     * @returns {string}
     */
    normalizeColorFormat(color) {
      return /rgba?/.test(color) ? this.convertRgbToHex(color) : color;
    }
    /**
     * Add BBCode tags to the accumulator
     *
     * @private
     * @param {BBCodeTagsAccumulator} accumulator
     * @param {string | null} openTag
     * @param {string | null
     * @returns {void}
     */
    addBBCodeTags(accumulator, openTag, closeTag = null) {
      if (openTag !== null) accumulator.openingTags.push(openTag);
      if (closeTag !== null) accumulator.closingTags.unshift(closeTag);
    }
    /**
     * Convert image element to BBCode
     *
     * @private
     * @param {HTMLImageElement} imgElement
     * @returns {string}
     */
    convertImageToBBCode(imgElement) {
      const { src, title } = imgElement;
      const dataSrc = imgElement.getAttribute("data-src") || imgElement.getAttribute("data-echo");
      if (title === ":m:") {
        return ":m:";
      }
      const imgUrl = this.determineImageUrl(src, dataSrc);
      if (!imgUrl) return "";
      return `[img]${imgUrl}[/img]`;
    }
    /**
     * Determine the image URL
     *
     * @private
     * @param {string} src
     * @param {string | null} dataSrc
     * @returns {string}
     */
    determineImageUrl(src, dataSrc) {
      if (dataSrc) {
        return dataSrc.match(/(http(s)?:)?\/\//) ? dataSrc : `${location.origin}/${dataSrc}`;
      }
      if (src && !src.match(/ico_\w+.gif|jinzhuan|thumbsup|kralimarko/)) {
        return src;
      }
      return "";
    }
    /**
     * Convert anchor element to BBCode
     *
     * @private
     * @param {HTMLAnchorElement} anchorElement
     * @returns {BBCodeConverterResult}
     */
    convertLinkToBBCode(anchorElement) {
      const { href, textContent } = anchorElement;
      if (!href || href.length === 0) {
        return {};
      }
      if (this.isMatchingSite("HDSpace")) {
        const div = anchorElement.querySelector("div");
        if (div && div.id) {
          const img = div.querySelector("img");
          if (img) {
            const imgUrl = img.getAttribute("src");
            return {
              content: `[url=${href}][img]${imgUrl}[/img][/url]`
            };
          }
        }
      }
      if (href.match(/javascript:void/) || textContent === "show" && this.isMatchingSite("HDT")) {
        return {};
      }
      return {
        openTag: `[url=${href}]`,
        closeTag: "[/url]"
      };
    }
    /**
     * handle special cases for div element
     *
     * @private
     * @param {HTMLElement} element
     * @param {BBCodeTagsAccumulator} accumulator
     * @returns {(string | null)}
     */
    handleSpecialDivElement(element, accumulator) {
      var _a2, _b;
      const { className, id } = element;
      const { siteType } = this.siteInfo;
      const addTags = this.addBBCodeTags.bind(this, accumulator);
      if (className === "codemain") {
        if (element.children.length > 0) {
          addTags("\n[quote]", "[/quote]");
          return null;
        }
        return "";
      }
      if (className === "hidden" && this.isMatchingSite("HDT")) {
        addTags("\n[quote]", "[/quote]");
        return null;
      }
      if (className.match("spoiler") && this.isMatchingSite("KG")) {
        if (className === "spoiler-content") {
          addTags("\n[quote]", "[/quote]");
        } else if (className === "spoiler-header") {
          return "";
        }
        return null;
      }
      if (this.isMatchingSite("BeyondHD")) {
        if (className === "spoilerChild") {
          const firstChildTag = (_b = (_a2 = element.children[0]) == null ? void 0 : _a2.tagName) == null ? void 0 : _b.toUpperCase();
          if (firstChildTag === "BLOCKQUOTE" || firstChildTag === "PRE") {
            addTags("\n", "");
          } else {
            addTags("\n[quote]", "[/quote]");
          }
        } else if (id === "screenMain") {
          return "\n";
        } else if (className === "spoilerHide") {
          return "";
        }
        return null;
      }
      if (siteType === "AvistaZ") {
        if (className === "spoiler-text") {
          addTags("\n[quote]", "[/quote]");
          return null;
        }
        if (className === "spoiler-toggle") {
          return "";
        }
      }
      if (className.match(/codetop|highlight/)) {
        return "";
      }
      addTags("\n", "\n");
      return null;
    }
    /**
     * handle special cases for TD element
     *
     * @private
     * @param {BBCodeTagsAccumulator} accumulator
     * @returns {(string | null)}
     */
    handleTDElement(accumulator) {
      const { siteType } = this.siteInfo;
      const addTags = this.addBBCodeTags.bind(this, accumulator);
      if (this.isMatchingSite(/^(TTG|HDBits|KG|HDSpace)/) || this.isMatchingSite("HDT") || siteType === "UNIT3D") {
        addTags("[quote]", "[/quote]");
      } else if (this.isMatchingSite("EMP")) {
        addTags("");
      } else if (this.isMatchingSite("PTer")) {
        addTags(null, null);
      } else {
        return "";
      }
      return null;
    }
    /**
     * handle BR element
     *
     * @private
     * @param {BBCodeTagsAccumulator} accumulator
     * @returns {void}
     */
    handleBRElement(accumulator) {
      const { siteType } = this.siteInfo;
      const siteName = this.siteInfo.siteName;
      const addTags = this.addBBCodeTags.bind(this, accumulator);
      if (siteType === "NexusPHP" && siteName !== "OurBits" || (siteName == null ? void 0 : siteName.match(/^(UHDBits|HDBits|BTN)/))) {
        addTags("");
      } else {
        addTags("\n");
      }
    }
    /**
     * handle inline styles
     *
     * @private
     * @param {HTMLElement} element
     * @param {BBCodeTagsAccumulator} accumulator
     * @returns {void}
     */
    handleInlineStyles(element, accumulator) {
      const { style } = element;
      const addTags = this.addBBCodeTags.bind(this, accumulator);
      if (style.textAlign) {
        const alignment = style.textAlign.toUpperCase();
        if (alignment === "LEFT") addTags("[left]", "[/left]");
        else if (alignment === "RIGHT") addTags("[right]", "[/right]");
        else if (alignment === "CENTER") addTags("[center]", "[/center]");
      }
      if (style.fontWeight === "bold" || parseInt(style.fontWeight, 10) >= 600) {
        addTags("[b]", "[/b]");
      }
      if (style.fontStyle === "italic") {
        addTags("[i]", "[/i]");
      }
      if (style.textDecoration === "underline" || style.textDecoration === "overline") {
        addTags("[u]", "[/u]");
      }
      if (style.textDecoration === "line-through") {
        addTags("[s]", "[/s]");
      }
      if (style.color && style.color.trim() !== "") {
        addTags(`[color=${this.normalizeColorFormat(style.color)}]`, "[/color]");
      }
    }
    /**
     * handle element by tag name
     *
     * @private
     * @param {string} tagName
     * @param {HTMLElement} element
     * @param {BBCodeTagsAccumulator} accumulator
     * @returns {(string | null)}
     */
    handleElementByTagName(tagName, element, accumulator) {
      var _a2, _b, _c;
      const addTags = this.addBBCodeTags.bind(this, accumulator);
      const { siteType } = this.siteInfo;
      switch (tagName) {
        case "SCRIPT":
          return "";
        case "UL":
          addTags(null, null);
          break;
        case "OL":
          addTags("[list=1]", "[/list]");
          break;
        case "LI": {
          const { className } = element;
          if (siteType === "UNIT3D" && className) {
            return `[quote]${(_a2 = element.textContent) == null ? void 0 : _a2.trim()}[/quote]`;
          }
          addTags("[*]", "\n");
          break;
        }
        case "B":
          addTags("[b]", "[/b]");
          break;
        case "U":
          addTags("[u]", "[/u]");
          break;
        case "I":
          addTags("[i]", "[/i]");
          break;
        case "DIV":
          return this.handleSpecialDivElement(element, accumulator);
        case "P":
          addTags("\n");
          break;
        case "BR":
          this.handleBRElement(accumulator);
          break;
        case "SPAN": {
          const { className } = element;
          if (className == null ? void 0 : className.match(/size/)) {
            const matchSize = (_c = (_b = className.match(/size(\d)/)) == null ? void 0 : _b[1]) != null ? _c : "";
            if (matchSize) {
              addTags(`[size=${matchSize}]`, "[/size]");
            }
          } else {
            addTags(null, null);
          }
          break;
        }
        case "BLOCKQUOTE":
        case "PRE":
        case "FIELDSET":
          addTags("[quote]", "[/quote]");
          break;
        case "CENTER":
          addTags("[center]", "[/center]");
          break;
        case "TD":
          return this.handleTDElement(accumulator);
        case "IMG":
          return this.convertImageToBBCode(element);
        case "FONT": {
          const fontElement = element;
          if (fontElement.color) {
            addTags(
              `[color=${this.normalizeColorFormat(fontElement.color)}]`,
              "[/color]"
            );
          }
          if (fontElement.size) {
            addTags(`[size=${fontElement.size}]`, "[/size]");
          }
          break;
        }
        case "A": {
          const result = this.convertLinkToBBCode(element);
          if (result.content) return result.content;
          if (result.openTag) addTags(result.openTag, result.closeTag);
          if (Object.keys(result).length < 1) return "";
          break;
        }
        case "H1":
          addTags('[b][size="7"]', "[/size][/b]\n");
          break;
        case "H2":
          addTags('[b][size="6"]', "[/size][/b]\n");
          break;
        case "H3":
          addTags('[b][size="5"]', "[/size][/b]\n");
          break;
        case "H4":
          addTags('[b][size="4"]', "[/size][/b]\n");
          break;
        case "STRONG":
          addTags("[b]", "[/b]");
          break;
        case "TABLE": {
          if (this.isMatchingSite("PTer") && element.className === "table") {
            return "";
          }
          addTags("");
          break;
        }
        case "TH":
          addTags("");
          break;
        default:
          addTags(null, null);
      }
      return null;
    }
    /**
     * Convert HTML node to BBCode
     *
     * @param {Element | ChildNode} node
     * @returns {string}
     */
    convert(node) {
      if (node.nodeType === 3) {
        const textContent = node.textContent;
        if (this.isSpecialControlText(textContent)) {
          return "";
        }
        return textContent;
      }
      if (node.nodeType !== 1) {
        return "";
      }
      const element = node;
      const tagName = element.tagName.toUpperCase();
      const accumulator = {
        openingTags: [],
        closingTags: []
      };
      const specialTagResult = this.handleElementByTagName(
        tagName,
        element,
        accumulator
      );
      if (specialTagResult !== null) {
        return specialTagResult;
      }
      this.handleInlineStyles(element, accumulator);
      const bbCodeParts = [];
      element.childNodes.forEach((childNode) => {
        const childCode = this.convert(childNode);
        if (childCode) {
          bbCodeParts.push(childCode);
        }
      });
      return accumulator.openingTags.concat(bbCodeParts).concat(accumulator.closingTags).join("");
    }
  }
  class NetworkError extends Error {
    constructor(message, status, statusText) {
      super(message);
      this.name = "NetworkError";
      this.status = status;
      this.statusText = statusText;
    }
  }
  class TimeoutError extends Error {
    constructor(message = "Request timed out") {
      super(message);
      this.name = "TimeoutError";
    }
  }
  const getLocationSearchValueByKey = (key) => {
    const reg = new RegExp(`(^|&)${key}=([^&]*)(&|$)`);
    const regArray = window.location.search.substring(1).match(reg);
    if (regArray) {
      return decodeURIComponent(regArray[2]);
    }
    return "";
  };
  const convertSizeStringToBytes = (size) => {
    if (!size) {
      return 0;
    }
    const sizeFloat = parseFloat(size);
    if (isNaN(sizeFloat)) {
      return 0;
    }
    if (size.match(/bytes/)) {
      return sizeFloat;
    } else if (size.match(/T/i)) {
      return sizeFloat * 1024 ** 4;
    } else if (size.match(/G/i)) {
      return sizeFloat * 1024 ** 3;
    } else if (size.match(/M/i)) {
      return sizeFloat * 1024 ** 2;
    } else if (size.match(/K/i)) {
      return sizeFloat * 1024;
    }
    return sizeFloat;
  };
  const $t$1 = (key) => {
    const languageKey = BROWSER_LANGUAGE;
    const translations = i18nConfig[languageKey];
    if (!translations) {
      return key;
    }
    return key in translations ? translations[key] : key;
  };
  const htmlToBBCode = (node) => {
    const converter = new HTMLToBBCodeConverter({
      siteType: CURRENT_SITE_INFO.siteType,
      siteName: CURRENT_SITE_NAME
    });
    return converter.convert(node);
  };
  const createFormData = (fields, files) => {
    const formData = new FormData();
    Object.entries(fields).forEach(([key, value]) => {
      if (value instanceof File) {
        throw new Error("Files should be passed as a separate argument");
      }
      formData.append(key, String(value));
    });
    if (files) {
      files.forEach(({ fieldName, file }) => {
        if (Array.isArray(file)) {
          file.forEach((f2, index) => {
            formData.append(`${fieldName}[${index}]`, f2);
          });
        } else {
          formData.append(fieldName, file);
        }
      });
    }
    return formData;
  };
  const GMFetch = (url, options2) => {
    return new Promise((resolve28, reject) => {
      const finalOptions = __spreadValues({
        method: "GET"
      }, options2);
      GM_xmlhttpRequest(__spreadProps(__spreadValues({
        url
      }, finalOptions), {
        onload: (res) => {
          const { statusText, status, response, responseText } = res;
          if (status >= 200 && status < 300) {
            if (finalOptions.responseType === "json" && typeof response === "undefined" && responseText) {
              try {
                resolve28(JSON.parse(responseText));
              } catch (e2) {
                reject(
                  new Error(
                    `Failed to parse JSON: ${e2 instanceof Error ? e2.message : String(e2)}`
                  )
                );
              }
            } else {
              resolve28(response);
            }
          } else {
            reject(
              new NetworkError(
                statusText || `Request failed with status ${status}`,
                status
              )
            );
          }
        },
        ontimeout: () => {
          reject(
            new TimeoutError(
              `Request to ${url} timed out after ${finalOptions.timeout}ms`
            )
          );
        },
        onprogress: finalOptions == null ? void 0 : finalOptions.onprogress,
        onerror: (error) => {
          const errorMessage = error.error || error.statusText || "Unknown network error";
          reject(new NetworkError(errorMessage, error.status, error.statusText));
        }
      }));
    });
  };
  const getOriginalImgUrl = async (urlBBcode) => {
    var _a2, _b, _c;
    if (!urlBBcode) {
      throw new Error("Invalid BBCode - No BBCode found");
    }
    const urlBBCodeMatch = urlBBcode.match(/\[url=(http(s)*:([^\]]+)?)/);
    const directUrlMatch = urlBBcode.match(/http(s)*:([^[])+/);
    if (urlBBCodeMatch) {
      const imgUrl = urlBBCodeMatch[1];
      for (const strategy of URLStrategies) {
        if (strategy.matches(imgUrl, urlBBcode)) {
          return await strategy.transform(imgUrl, urlBBcode);
        }
      }
      return imgUrl.trim();
    } else if (urlBBcode.match(/\[img\]/)) {
      return (_c = (_b = (_a2 = urlBBcode.match(/img\](([^[])+)/)) == null ? void 0 : _a2[1]) == null ? void 0 : _b.trim()) != null ? _c : "";
    } else if (directUrlMatch) {
      return directUrlMatch[0].trim();
    }
    throw new Error("Invalid BBCode - No valid image URL found");
  };
  const urlToFile = async (url) => {
    var _a2, _b;
    const filename = (_b = (_a2 = url.match(/\/([^/]+?)(\?|$)/)) == null ? void 0 : _a2[1]) != null ? _b : "filename";
    const data = await GMFetch(url, {
      responseType: "blob"
    });
    const file = new File([data], filename, { type: data.type });
    return file;
  };
  class ImageUploadError extends Error {
    constructor(message, originalError) {
      super(message);
      this.originalError = originalError;
      this.name = "ImageUploadError";
    }
  }
  const throwUploadError = (message, originalError) => {
    const errorMessage = message || $t$1(CONFIG$4.ERROR_MESSAGES.UPLOAD_FAILED);
    throw new ImageUploadError(errorMessage, originalError);
  };
  const urlFileCache = /* @__PURE__ */ new Map();
  const cachedUrlToFile = async (url) => {
    if (!url) {
      throw new Error("URL is required to convert to file");
    }
    if (!urlFileCache.has(url)) {
      urlFileCache.set(url, urlToFile(url));
    }
    return urlFileCache.get(url);
  };
  class HdBitsStrategy {
    matches(url) {
      return url.includes("img.hdbits.org");
    }
    async transform(url) {
      const data = await GMFetch(url);
      const doc = new DOMParser().parseFromString(data, "text/html");
      const imgElem = doc.querySelector("#viewimage");
      if (!imgElem) {
        throw new Error(
          "Couldn't find image element when retrieving from HDBits"
        );
      }
      const imgSrc = imgElem.getAttribute("src");
      if (!imgSrc) {
        throw new Error(
          "No valid image source found when retrieving from HDBits"
        );
      }
      return imgSrc;
    }
  }
  class PterClubStrategy {
    matches(url, bbCode) {
      return bbCode.includes("img.pterclub.com");
    }
    async transform(url, bbCode) {
      var _a2, _b;
      const imgUrl = (_b = (_a2 = bbCode.match(/img\](([^[])+)/)) == null ? void 0 : _a2[1]) != null ? _b : "";
      if (!imgUrl) {
        throw new Error("Invalid PterClub image URL");
      }
      return imgUrl.replace(/\.th/g, "");
    }
  }
  class ImageBoxStrategy {
    matches(url, bbCode) {
      return bbCode.includes("imgbox.com");
    }
    async transform(url, bbCode) {
      var _a2, _b;
      const imgUrl = (_b = (_a2 = bbCode.match(/img\](([^[])+)/)) == null ? void 0 : _a2[1]) != null ? _b : "";
      if (!imgUrl) {
        throw new Error("Invalid ImageBox image BBCode");
      }
      if (!imgUrl.match(/thumbs\d.+?_t\.(png|jpg)/)) {
        throw new Error("Invalid ImageBox image URL");
      }
      return imgUrl.replace(/thumbs(\d)/, "images$1").replace(/_t(\.(png|jpg))/, "_o.$2");
    }
  }
  class ImageBamStrategy {
    matches(url) {
      return url.includes("imagebam.com");
    }
    async transform(url) {
      const originalPage = await GMFetch(url);
      const doc = new DOMParser().parseFromString(originalPage, "text/html");
      const imgElem = doc.querySelector(".main-image");
      if (!imgElem) {
        throw new Error(
          "Couldn't find image element when retrieving from ImageBam"
        );
      }
      const imgSrc = imgElem.getAttribute("src");
      if (!imgSrc) {
        throw new Error(
          "No valid image source found when retrieving from ImageBam"
        );
      }
      return imgSrc;
    }
  }
  class BeyondHdStrategy {
    matches(url, bbCode) {
      return bbCode.includes("beyondhd.co");
    }
    async transform(url, bbCode) {
      var _a2, _b;
      const imgUrl = (_b = (_a2 = bbCode.match(/img\](([^[])+)/)) == null ? void 0 : _a2[1]) != null ? _b : "";
      if (!imgUrl) {
        throw new Error("Invalid BeyondHD image BBCode");
      }
      if (!imgUrl.match(/\.(th|md)\.(png|jpg|gif)/)) {
        throw new Error("Invalid BeyondHD image URL");
      }
      return imgUrl.replace(/\.(th|md)\.(png|jpg|gif)/, ".$2");
    }
  }
  class PixHostStrategy {
    matches(url, bbCode) {
      return bbCode.includes("pixhost.to");
    }
    async transform(url, bbCode) {
      var _a2;
      const hostNumber = (_a2 = bbCode.match(/img\]https:\/\/t(\d+)\./)) == null ? void 0 : _a2[1];
      if (!hostNumber || !url.includes("show")) {
        throw new Error("Invalid PixHost image BBCode");
      }
      return url.replace(/(pixhost\.to)\/show/, `img${hostNumber}.$1/images`);
    }
  }
  const URLStrategies = [
    new HdBitsStrategy(),
    new PterClubStrategy(),
    new ImageBoxStrategy(),
    new ImageBamStrategy(),
    new BeyondHdStrategy(),
    new PixHostStrategy()
  ];
  const withUploadErrorHandling = async (uploadFn, serviceName, options2 = {}) => {
    const { validateFirstArg = true, defaultResult = [] } = options2;
    return async (...args) => {
      try {
        if (validateFirstArg) {
          const firstArg = args[0];
          if (firstArg === void 0 || firstArg === null || Array.isArray(firstArg) && firstArg.length === 0) {
            return defaultResult;
          }
        }
        return await uploadFn(...args);
      } catch (error) {
        if (error instanceof ImageUploadError) {
          throw error;
        }
        const errorMessage = error instanceof Error ? `${error.name}: ${error.message}` : "Unknown error";
        throwUploadError(
          `${$t$1(
          CONFIG$4.ERROR_MESSAGES.UPLOAD_FAILED
        )} - ${serviceName}. ${errorMessage}`,
          error
        );
        return defaultResult;
      }
    };
  };
  const getImageBBCodeMatches = (bbcode) => {
    const matches = bbcode.match(
      /(\[url=(http(s)*:\/{2}.+?)\])?\[img\](http(s)?:.+?)\[\/img](\[\/url\])?/gi
    );
    if (!matches) {
      return [];
    }
    return Array.from(matches);
  };
  const getImgInfoFromBBCode = async (bbcode) => {
    var _a2, _b, _c;
    if (!bbcode) {
      throw new Error("Invalid BBCode - No BBCode found");
    }
    const originalUrl = await getOriginalImgUrl(bbcode);
    if (!originalUrl) {
      throw new Error("Invalid BBCode - No original URL found");
    }
    const thumbnailUrl = (_c = (_b = (_a2 = bbcode.match(/\[img\]((.|\s)*?)\[/)) == null ? void 0 : _a2[1]) == null ? void 0 : _b.trim()) != null ? _c : "";
    if (!thumbnailUrl) {
      throw new Error("Invalid BBCode - No thumbnail URL found");
    }
    return {
      original: originalUrl,
      thumbnail: thumbnailUrl
    };
  };
  const extractImgsFromBBCode = async (bbcode) => {
    if (!bbcode) {
      return [];
    }
    const imgBBCodeMatches = getImageBBCodeMatches(bbcode);
    const matchImgBBCodes = Array.from(imgBBCodeMatches);
    if (matchImgBBCodes.length < 1) {
      return [];
    }
    const extractOriginalUrlsOfScreenshotPromises = matchImgBBCodes.map(
      async (bbcode2) => {
        return await getOriginalImgUrl(bbcode2);
      }
    );
    const { FILTER_IMGS_NAMES } = CONFIG$4;
    const screenshotUrls = (await Promise.all(extractOriginalUrlsOfScreenshotPromises)).filter((url) => !FILTER_IMGS_NAMES.some((name) => url.includes(name)));
    return screenshotUrls;
  };
  const createHDBRequestConfig = async (imgUrls, galleryName) => {
    const imgFiles = await Promise.all(
      imgUrls.map((item) => cachedUrlToFile(item))
    );
    const formData = createFormData(
      {
        galleryoption: "1",
        galleryname: galleryName
      },
      [
        {
          fieldName: "images_files",
          file: imgFiles
        }
      ]
    );
    return {
      url: CONFIG$4.URLS.HDB_UPLOAD,
      options: {
        data: formData,
        method: "POST"
      }
    };
  };
  const parseHDBResponse = async (data) => {
    if (!data || data.includes("error")) {
      throwUploadError(`${$t$1(CONFIG$4.ERROR_MESSAGES.UPLOAD_FAILED)} - ${data}`);
    }
    const urls = data.split(" ").filter((url) => url.trim().length > 0);
    if (urls.length < 1) {
      throwUploadError(
        `${$t$1(CONFIG$4.ERROR_MESSAGES.UPLOAD_FAILED)} - Empty Result`
      );
    }
    const promiseResult = urls.map((urlBBcode) => {
      return getImgInfoFromBBCode(urlBBcode);
    });
    return Promise.all(promiseResult);
  };
  const getImgboxToken = async () => {
    var _a2, _b;
    const rawHtml = await GMFetch(CONFIG$4.URLS.IMGBOX);
    const authToken = (_b = (_a2 = rawHtml.match(/content="(.+)" name="csrf-token"/)) == null ? void 0 : _a2[1]) != null ? _b : "";
    if (!authToken) {
      throwUploadError(
        `${$t$1(CONFIG$4.ERROR_MESSAGES.UPLOAD_FAILED)} - Invalid AuthToken`
      );
    }
    const tokenSecret = await GMFetch(
      `${CONFIG$4.URLS.IMGBOX}/ajax/token/generate`,
      {
        responseType: "json",
        method: "POST",
        headers: {
          "X-CSRF-Token": authToken
        }
      }
    );
    if (!tokenSecret || !tokenSecret.token_id || !tokenSecret.token_secret) {
      throwUploadError(
        `${$t$1(CONFIG$4.ERROR_MESSAGES.UPLOAD_FAILED)} - Invalid Token`
      );
    }
    return {
      tokenSecret,
      authToken
    };
  };
  const createImgboxRequestConfig = (tokenSecret, authToken, file) => {
    const { token_id: tokenId, token_secret: secret } = tokenSecret;
    const formData = createFormData(
      {
        token_id: tokenId,
        token_secret: secret,
        content_type: "1",
        thumbnail_size: "350c",
        gallery_id: "null",
        gallery_secret: "null",
        comments_enabled: "0"
      },
      [{ fieldName: "files[]", file }]
    );
    const options2 = {
      method: "POST",
      responseType: "json",
      headers: {
        "X-CSRF-Token": authToken
      },
      data: formData
    };
    return options2;
  };
  const parseImgboxResponse = (data) => {
    const imgResultList = data.map((result) => {
      if (result && result.files && result.files.length) {
        return result.files[0];
      }
      throwUploadError(
        `${$t$1(CONFIG$4.ERROR_MESSAGES.UPLOAD_FAILED)} -  Empty Data to Parse`
      );
      return null;
    }).filter((item) => item !== null);
    return imgResultList.map((item) => {
      return {
        original: item.original_url,
        thumbnail: item.thumbnail_url
      };
    });
  };
  const createPixhostRequestConfig = (imgUrls) => {
    if (imgUrls.length < 1) {
      throwUploadError(`${$t$1(CONFIG$4.ERROR_MESSAGES.UPLOAD_FAILED)} - Empty URLs`);
    }
    const params = encodeURI(
      `imgs=${imgUrls.join("\n")}&content_type=1&max_th_size=300`
    );
    const options2 = {
      method: "POST",
      data: params,
      headers: {
        Accept: "application/json",
        "Content-Type": "application/x-www-form-urlencoded;charset=utf-8"
      }
    };
    return {
      url: CONFIG$4.URLS.PIXHOST_UPLOAD,
      options: options2
    };
  };
  const parsePixhostResponse = (data) => {
    const result = data.match(/(upload_results = )({.*})(;)/);
    if (!result || result.length < 3) {
      throwUploadError(
        `${$t$1(CONFIG$4.ERROR_MESSAGES.UPLOAD_FAILED)} - Empty Result`
      );
      return [];
    }
    const parsedData = JSON.parse(result[2]);
    const imgResultList = parsedData.images;
    if (!imgResultList || imgResultList.length < 1) {
      throwUploadError("No images found in the response");
      return [];
    }
    return imgResultList.map((item) => {
      return {
        thumbnail: item.th_url,
        original: item.show_url
      };
    });
  };
  const createPTPImgRequestConfig = (imgArray) => {
    const apiKey = GM_getValue("easy-upload.ptp-img-api-key", "");
    if (!apiKey) {
      throwUploadError(
        `${$t$1(CONFIG$4.ERROR_MESSAGES.PTPIMG_UPLOAD_FAILED)} ${$t$1(CONFIG$4.ERROR_MESSAGES.NO_API_KEY)}`
      );
    }
    const options2 = {
      method: "POST",
      responseType: "json"
    };
    const isFileUpload = imgArray.length > 0 && imgArray[0] instanceof File;
    if (isFileUpload) {
      const fileArray = imgArray.filter(
        (item) => item instanceof File
      );
      const formData = createFormData({ api_key: apiKey }, [
        { fieldName: "file-upload", file: fileArray }
      ]);
      options2.data = formData;
    } else {
      const linkArray = imgArray.filter(
        (item) => typeof item === "string"
      );
      options2.headers = {
        "Content-Type": "application/x-www-form-urlencoded;charset=utf-8"
      };
      options2.data = `link-upload=${linkArray.join("\n")}&api_key=${apiKey}`;
    }
    return {
      url: CONFIG$4.URLS.PTPIMG_UPLOAD,
      options: options2
    };
  };
  const parsePTPImgResponse = (data) => {
    if (!data || !Array.isArray(data) || data.length < 1) {
      throwUploadError();
      return [];
    }
    return data.map((img) => `${CONFIG$4.URLS.PTPIMG}/${img.code}.${img.ext}`);
  };
  const getCheveretoToken = async (imgHost) => {
    var _a2, _b;
    const rawHtml = await GMFetch(imgHost.replace("/json", ""));
    const authToken = (_b = (_a2 = rawHtml.match(/PF\.obj\.config\.auth_token\s*=\s*"(\w+)"/)) == null ? void 0 : _a2[1]) != null ? _b : "";
    if (!authToken) {
      throwUploadError(
        `${$t$1(CONFIG$4.ERROR_MESSAGES.UPLOAD_FAILED)} - Invalid AuthToken`
      );
    }
    return authToken;
  };
  const createCheveretoRequestConfig = async (imgUrl, imgHost, authToken) => {
    const isHdbHost = !!imgUrl.match(/i\.hdbits\.org/);
    let formData;
    const options2 = {
      action: "upload",
      timestamp: `${Date.now()}`,
      auth_token: authToken
    };
    if (isHdbHost || imgHost.includes("gifyu")) {
      const fileData = await cachedUrlToFile(imgUrl);
      formData = createFormData(
        __spreadValues({
          type: "file"
        }, options2),
        [{ fieldName: "source", file: fileData }]
      );
    } else {
      formData = createFormData(__spreadValues({
        type: "url",
        source: imgUrl
      }, options2));
    }
    return {
      method: "POST",
      data: formData,
      responseType: "json"
    };
  };
  const parseCheveretoResponse = (data) => {
    const imgResultList = data.map((res) => {
      if (res.status_txt !== "OK") {
        throwUploadError(
          `${$t$1(CONFIG$4.ERROR_MESSAGES.UPLOAD_FAILED)} ${res.status_txt}`
        );
        return null;
      }
      if (res.image) {
        return res.image;
      }
      throwUploadError();
      return null;
    }).filter((item) => item !== null);
    return imgResultList.map((item) => {
      return {
        original: item.url,
        thumbnail: item.thumb.url
      };
    });
  };
  const uploadToHDB = withUploadErrorHandling(
    async (imgUrls, galleryName) => {
      const { url, options: options2 } = await createHDBRequestConfig(imgUrls, galleryName);
      const data = await GMFetch(url, options2);
      return await parseHDBResponse(data);
    },
    "HDB"
  );
  const uploadToImgbox = withUploadErrorHandling(
    async (imgUrls) => {
      const { tokenSecret, authToken } = await getImgboxToken();
      const files = await Promise.all(
        imgUrls.map((item) => cachedUrlToFile(item))
      );
      const fileUploadPromises = files.map((file) => {
        const requestOptions = createImgboxRequestConfig(
          tokenSecret,
          authToken,
          file
        );
        return GMFetch(CONFIG$4.URLS.IMGBOX_UPLOAD, requestOptions);
      });
      const data = await Promise.all(fileUploadPromises);
      return parseImgboxResponse(data);
    },
    "Imgbox"
  );
  const uploadToPixhost = withUploadErrorHandling(
    async (imgUrls) => {
      const { url, options: options2 } = createPixhostRequestConfig(imgUrls);
      const data = await GMFetch(url, options2);
      return parsePixhostResponse(data);
    },
    "Pixhost",
    { validateFirstArg: true, defaultResult: [] }
  );
  const uploadToPtpImg = withUploadErrorHandling(
    async (imgArray) => {
      const { url, options: options2 } = createPTPImgRequestConfig(imgArray);
      const data = await GMFetch(url, options2);
      return parsePTPImgResponse(data);
    },
    "PTPImg"
  );
  const transferImgToCheveretoSite = withUploadErrorHandling(
    async (imgUrls, imgHost = CONFIG$4.URLS.IMGBB) => {
      const authToken = await getCheveretoToken(imgHost);
      const imgUploadPromises = imgUrls.map(async (imgUrl) => {
        const requestOptions = await createCheveretoRequestConfig(
          imgUrl,
          imgHost,
          authToken
        );
        return GMFetch(imgHost, requestOptions);
      });
      const data = await Promise.all(imgUploadPromises);
      return parseCheveretoResponse(data);
    },
    "Chevereto"
  );
  const transferImgsToPtpimg = async (imgArray) => {
    if (!imgArray || imgArray.length < 1) {
      return [];
    }
    const uploadFn = await uploadToPtpImg;
    const isHdbHost = !!imgArray[0].match(/i\.hdbits\.org/);
    const isPtpHost = !!imgArray[0].match(/ptpimg\.me/);
    if (isPtpHost) {
      throwUploadError($t$1(CONFIG$4.ERROR_MESSAGES.NO_TRANSFER_NEEDED));
    } else if (isHdbHost) {
      const fileArray = await Promise.all(
        imgArray.map((item) => cachedUrlToFile(item))
      );
      return await uploadFn(fileArray);
    }
    return await uploadFn(imgArray);
  };
  const CONFIG$3 = {
    CODEC_RULES: [
      { codec: "atmos", regex: /atmos/i },
      { codec: "dtshdma", regex: /dtshdma|DTSHD Master/i },
      { codec: "dtsx", regex: /dtsx/i },
      { codec: "dts", regex: /dts/i },
      { codec: "truehd", regex: /truehd/i },
      { codec: "lpcm", regex: /lpcm/i },
      { codec: "flac", regex: /flac/i },
      { codec: "aac", regex: /aac/i },
      { codec: "dd+", regex: /DD\+|DDP|DolbyDigitalPlus/i },
      { codec: "dd", regex: /DD|DolbyDigital/i },
      { codec: "ac3", regex: /ac3/i }
    ]
  };
  class MediaParser {
    constructor(source) {
      this.source = source;
      this.result = {
        fileName: "",
        fileSize: 0,
        duration: 0,
        format: "",
        audioTracks: [],
        subtitleTracks: [],
        videoTracks: []
      };
    }
    getHdrType(hdrFormat) {
      if (!hdrFormat) return "";
      if (/Dolby\s*Vision/i.test(hdrFormat)) return "DV";
      if (/HDR10\+/i.test(hdrFormat)) return "HDR10+";
      if (/HDR10/i.test(hdrFormat)) return "HDR10";
      if (/HLG/i.test(hdrFormat)) return "HLG";
      return "";
    }
  }
  class MediaInfoParser extends MediaParser {
    splitIntoSections() {
      const lines = this.source.split("\n");
      const sections = {};
      let currentSectionLines = {};
      let currentSectionType = "";
      for (const line of lines) {
        const trimmedLine = line.trim();
        const sectionHeaderMatch = trimmedLine.match(/^([a-zA-Z]+)(\s*#\d+)?$/);
        if (sectionHeaderMatch) {
          if (currentSectionType && Object.keys(currentSectionLines).length > 0) {
            if (sections[currentSectionType]) {
              sections[currentSectionType].push(currentSectionLines);
            } else {
              sections[currentSectionType] = [currentSectionLines];
            }
          }
          currentSectionType = sectionHeaderMatch[1];
          currentSectionLines = {};
          continue;
        }
        if (currentSectionType) {
          const [key, value] = trimmedLine.split(":").map((s2) => s2.trim());
          if (key && value) {
            currentSectionLines[key] = value;
          }
        }
      }
      if (currentSectionType && Object.keys(currentSectionLines).length > 0) {
        if (sections[currentSectionType]) {
          sections[currentSectionType].push(currentSectionLines);
        } else {
          sections[currentSectionType] = [currentSectionLines];
        }
      }
      return sections;
    }
    parseGeneralSection(general) {
      if (!general) return;
      this.result.fileSize = convertSizeStringToBytes(general["File size"]);
      this.result.duration = this.parseDuration(general.Duration);
      this.result.format = general.Format;
      this.result.fileName = general["Complete name"];
    }
    parseVideoSection(videos) {
      if (!videos || videos.length === 0) return [];
      const videoTracks = [];
      for (const video of videos) {
        videoTracks.push(this.parseVideo(video, this.result.format));
      }
      return videoTracks;
    }
    parseAudioSection(audios) {
      if (!audios || audios.length === 0) return [];
      const audioTracks = [];
      for (const audio of audios) {
        audioTracks.push(this.parseAudio(audio));
      }
      return audioTracks;
    }
    parseSubtitleSection(subtitles) {
      if (!subtitles || subtitles.length === 0) return [];
      const subtitleTracks = [];
      for (const subtitle of subtitles) {
        const {
          ID: id = "",
          Title: title = "",
          Language: language = "",
          Default: isDefault = "",
          Forced: isForced = ""
        } = subtitle;
        subtitleTracks.push({
          id,
          title,
          language,
          default: isDefault === "Yes",
          forced: isForced === "Yes"
        });
      }
      return subtitleTracks;
    }
    parseAudio(audio) {
      const {
        Format: audioFormat = "",
        "Format profile": formatProfile = "",
        "Commercial name": commercialName = "",
        "Channel(s)": audioChannels = "",
        ID: id = "",
        Default: isDefault = "",
        Forced: isForced = "",
        Language: language = ""
      } = audio;
      let channelName = "";
      const channelNumber = parseInt(audioChannels, 10);
      if (channelNumber && channelNumber >= 6) {
        channelName = `${channelNumber - 1}.1`;
      } else {
        channelName = `${channelNumber}.0`;
      }
      const codec = this.determineAudioCodec(
        audioFormat,
        commercialName,
        formatProfile
      );
      return {
        channelName,
        language,
        default: isDefault === "Yes",
        forced: isForced === "Yes",
        id,
        codec
      };
    }
    parseVideo(video, generalFormat) {
      const {
        Format: videoFormat = "",
        "Format version": videoFormatVersion = "",
        "Codec ID": videoCodeId = "",
        "HDR format": hdrFormat = "",
        "Encoding settings": encodingSettings,
        Default: isDefault = "",
        Forced: isForced = "",
        ID: id = "",
        Width = "",
        Height = "",
        "Scan type": scanType = ""
      } = video;
      const isEncoded = !!encodingSettings;
      const formatCodecMap = {
        "DVD Video": "mpeg2",
        "MPEG-4": "mpeg4"
      };
      let videoCodec = formatCodecMap[generalFormat] || "";
      if (!videoCodec) {
        if (videoFormat === "MPEG Video" && videoFormatVersion === "Version 2") {
          videoCodec = "mpeg2";
        } else if (/xvid/i.test(videoCodeId)) {
          videoCodec = "xvid";
        } else if (/HEVC/i.test(videoFormat)) {
          videoCodec = isEncoded ? "x265" : "hevc";
        } else if (/AVC/i.test(videoFormat)) {
          videoCodec = isEncoded ? "x264" : "h264";
        } else if (/VC-1/i.test(videoFormat)) {
          videoCodec = "vc1";
        } else if (/vvc/i.test(videoFormat)) {
          videoCodec = "vvc";
        }
      }
      const hdrType = this.getHdrType(hdrFormat);
      const videoWidth = parseInt(Width.replace(/\s/g, ""), 10);
      const videoHeight = parseInt(Height.replace(/\s/g, ""), 10);
      const resolution = this.parseResolution(videoWidth, videoHeight, scanType);
      return {
        hdrType,
        codec: videoCodec,
        isEncoded,
        default: isDefault === "Yes",
        forced: isForced === "Yes",
        id,
        resolution
      };
    }
    parseDuration(duration) {
      var _a2, _b, _c, _d, _e, _f;
      const hour = (_b = (_a2 = duration.match(/(\d+)\s*h/)) == null ? void 0 : _a2[1]) != null ? _b : "0";
      const minute = (_d = (_c = duration.match(/(\d+)\s*min/)) == null ? void 0 : _c[1]) != null ? _d : "0";
      const second = (_f = (_e = duration.match(/(\d+)\s*s/)) == null ? void 0 : _e[1]) != null ? _f : "0";
      return parseInt(hour, 10) * 3600 + parseInt(minute, 10) * 60 + parseInt(second, 10);
    }
    parseResolution(width, height, scanType = "") {
      if (!width || !height || isNaN(width) || isNaN(height)) {
        return "";
      }
      if (width === 7680 && height === 4320) return "4320p";
      if (width === 3840 && height === 2160) return "2160p";
      if (height >= 2160 || width >= 3840) {
        return "2160p";
      } else if (height >= 1080 || width >= 1920) {
        const isProgressive = scanType === "Progressive" || !scanType;
        return `1080${isProgressive ? "p" : "i"}`;
      } else if (height >= 720 || width >= 1280) {
        return "720p";
      } else if (height >= 576 || width >= 1024) {
        return "576p";
      } else if (width >= 840 || height === 480) {
        return "480p";
      } else if (height >= 360) {
        return "360p";
      } else if (height >= 240) {
        return "240p";
      }
      return `${width}x${height}`;
    }
    determineAudioCodec(format2, commercialName, formatProfile) {
      const codecRules = [
        {
          match: () => /MLP FBA/i.test(format2) && /Dolby Atmos/i.test(commercialName),
          codec: "atmos"
        },
        { match: () => /MLP FBA/i.test(format2), codec: "truehd" },
        {
          match: () => /AC-3/i.test(format2) && /Dolby Digital Plus/i.test(commercialName),
          codec: "dd+"
        },
        { match: () => /E-AC-3/i.test(format2), codec: "dd+" },
        {
          match: () => /AC-3/i.test(format2) && /Dolby Digital/i.test(commercialName),
          codec: "dd"
        },
        { match: () => /AC-3/i.test(format2), codec: "ac3" },
        { match: () => /DTS XLL X/i.test(format2), codec: "dtsx" },
        {
          match: () => /DTS/i.test(format2) && /DTS-HD Master Audio/i.test(commercialName),
          codec: "dtshdma"
        },
        {
          match: () => /DTS/i.test(format2) && /MA \/ Core/i.test(formatProfile),
          codec: "dtshdma"
        },
        {
          match: () => /DTS/i.test(format2) && /High Resolution/i.test(commercialName),
          codec: "dtshd"
        },
        { match: () => /DTS/i.test(format2), codec: "dts" },
        { match: () => /FLAC/i.test(format2), codec: "flac" },
        { match: () => /AAC/i.test(format2), codec: "aac" },
        { match: () => /LPCM/i.test(format2), codec: "lpcm" },
        { match: () => /MP3/i.test(format2), codec: "mp3" },
        { match: () => /Opus/i.test(format2), codec: "opus" },
        { match: () => /Vorbis/i.test(format2), codec: "vorbis" }
      ];
      const matchedRule = codecRules.find((rule) => rule.match());
      return matchedRule ? matchedRule.codec : "";
    }
    parse() {
      var _a2;
      const sections = this.splitIntoSections();
      this.parseGeneralSection((_a2 = sections == null ? void 0 : sections.General) == null ? void 0 : _a2[0]);
      const videoTracks = this.parseVideoSection(sections == null ? void 0 : sections.Video);
      const audioTracks = this.parseAudioSection(sections == null ? void 0 : sections.Audio);
      const subtitleTracks = this.parseSubtitleSection(sections == null ? void 0 : sections.Text);
      return __spreadProps(__spreadValues({}, this.result), {
        videoTracks,
        audioTracks,
        subtitleTracks
      });
    }
  }
  class BDInfoParser extends MediaParser {
    splitIntoSections() {
      const lines = this.source.split("\n");
      const sectionTypeConfig = [
        { match: /Disc Label|DISC INFO/i, typeName: "general" },
        { match: /\*?VIDEO:/i, typeName: "video" },
        { match: /\*?AUDIO:/i, typeName: "audio" },
        { match: /\*?SUBTITLE(S)?/i, typeName: "subtitle" }
      ];
      const sections = {};
      let currentSectionLines = {};
      let currentSectionType = "";
      let currentSectionLineIndex = 0;
      for (const line of lines) {
        const trimmedLine = line.trim();
        const sectionHeaderMatch = sectionTypeConfig.filter(
          (config) => trimmedLine.match(config.match)
        );
        if (sectionHeaderMatch.length > 0) {
          currentSectionLineIndex = 0;
          if (currentSectionType && Object.keys(currentSectionLines).length > 0) {
            if (sections[currentSectionType]) {
              sections[currentSectionType].push(currentSectionLines);
            } else {
              sections[currentSectionType] = [currentSectionLines];
            }
          }
          currentSectionType = sectionHeaderMatch[0].typeName;
          const [key, value, ...extra] = trimmedLine.split(":");
          if (key && value) {
            if (extra.length > 0) {
              currentSectionLines = {
                [key]: `${value}:${extra.join(":").trim()}`
              };
            } else {
              currentSectionLines = {
                [key]: value.trim()
              };
            }
          } else {
            currentSectionLines = {};
          }
          continue;
        }
        if (currentSectionType) {
          const [key, value, ...extra] = trimmedLine.split(":").map((s2) => s2.trim());
          if (key && value && !key.includes("/") && !value.includes("/")) {
            if (extra.length > 0) {
              currentSectionLines[key] = `${value}:${extra.join(":").trim()}`;
            } else {
              currentSectionLines[key] = value.trim();
            }
          } else if (key.trim()) {
            if (!key.includes("--") && !key.match(/Bitrate\s*Description|PLAYLIST REPORT/i)) {
              if (!sections[currentSectionType]) {
                sections[currentSectionType] = [];
              }
              sections[currentSectionType].push({
                [currentSectionLineIndex]: trimmedLine
              });
            }
          }
        }
      }
      if (currentSectionType && Object.keys(currentSectionLines).length > 0) {
        if (sections[currentSectionType]) {
          sections[currentSectionType].push(currentSectionLines);
        } else {
          sections[currentSectionType] = [currentSectionLines];
        }
      }
      return sections;
    }
    parseGeneralSection(general) {
      var _a2, _b;
      if (!general) {
        return;
      }
      this.result.fileSize = convertSizeStringToBytes(
        (_a2 = general == null ? void 0 : general["Disc Size"]) == null ? void 0 : _a2.replace(/,/g, "")
      );
      this.result.duration = this.parseDuration(
        (_b = general == null ? void 0 : general.Length) == null ? void 0 : _b.replace(/\s/g, "")
      );
      this.result.fileName = general == null ? void 0 : general["Disc Label"];
    }
    parseVideoSection(videos) {
      if (!videos || videos.length === 0) return [];
      const videoTracks = [];
      for (const video of videos) {
        videoTracks.push(this.parseVideo(Object.values(video)[0]));
      }
      return videoTracks;
    }
    parseVideo(video) {
      var _a2, _b, _c, _d;
      const videoCodec = (_b = (_a2 = video.match(/(\w|\s|-|\/)+?Video/i)) == null ? void 0 : _a2[0]) != null ? _b : "";
      const codec = /HEVC/i.test(videoCodec) ? "hevc" : "h264";
      const resolution = (_d = (_c = video.match(/(\d+)p/i)) == null ? void 0 : _c[0]) != null ? _d : "";
      const hdrType = this.getHdrType(video);
      return {
        hdrType,
        codec,
        resolution,
        default: false,
        forced: false,
        isEncoded: false
      };
    }
    parseAudioSection(audios) {
      if (!audios || audios.length === 0) return [];
      const audioTracks = [];
      for (const audio of audios) {
        audioTracks.push(this.parseAudio(Object.values(audio)[0]));
      }
      return audioTracks;
    }
    parseAudio(audio) {
      var _a2, _b, _c, _d, _e, _f;
      const audioCodec = (_b = (_a2 = audio.match(/(\w|\s|-|\/)+?Audio/i)) == null ? void 0 : _a2[0]) != null ? _b : "";
      const codec = getAudioCodecFromSource(audioCodec);
      const isQuickSummaryType = /Audio\s*\//.test(audio);
      let language;
      if (isQuickSummaryType) {
        language = audio.split("/")[0].trim();
      } else {
        language = (_d = (_c = audio.match(/Audio\s*(\w+)/i)) == null ? void 0 : _c[1]) != null ? _d : "";
      }
      const channelName = (_f = (_e = audio.match(/(\d+\.\d)/)) == null ? void 0 : _e[0]) != null ? _f : "";
      return {
        channelName,
        language,
        codec
      };
    }
    parseSubtitleSection(subtitles) {
      if (!subtitles || subtitles.length === 0) return [];
      const subtitleTracks = [];
      for (const subtitle of subtitles) {
        subtitleTracks.push(this.parseSubtitle(Object.values(subtitle)[0]));
      }
      return subtitleTracks;
    }
    parseSubtitle(subtitle) {
      var _a2, _b, _c;
      const subtitleSplits = subtitle.split("/");
      const firstAudioSplit = (_a2 = subtitleSplits == null ? void 0 : subtitleSplits[0]) == null ? void 0 : _a2.trim();
      let language = firstAudioSplit;
      if (subtitleSplits.length < 2) {
        language = (_c = (_b = subtitle.match(/Graphics\s*(\w+)/)) == null ? void 0 : _b[1]) != null ? _c : "";
      }
      return {
        language
      };
    }
    parseDuration(duration) {
      const [hour, minute, second] = duration.split(":");
      return parseFloat(hour) * 3600 + parseFloat(minute) * 60 + parseFloat(second);
    }
    parse() {
      var _a2, _b;
      const sections = this.splitIntoSections();
      this.parseGeneralSection(
        (_b = sections == null ? void 0 : sections.general) == null ? void 0 : _b[((_a2 = sections == null ? void 0 : sections.general) == null ? void 0 : _a2.length) > 1 ? 1 : 0]
      );
      const videoTracks = this.parseVideoSection(sections == null ? void 0 : sections.video);
      const audioTracks = this.parseAudioSection(sections == null ? void 0 : sections.audio);
      const subtitleTracks = this.parseSubtitleSection(sections == null ? void 0 : sections.subtitle);
      return __spreadProps(__spreadValues({}, this.result), {
        videoTracks,
        audioTracks,
        subtitleTracks
      });
    }
  }
  const getBDTypeBasedOnSize = (size) => {
    const GBSize = size / 1024 ** 3;
    const DISK_TYPES = [
      { maxSize: 5, type: "DVD5" },
      { maxSize: 9, type: "DVD9" },
      { maxSize: 25, type: "BD25" },
      { maxSize: 50, type: "BD50" },
      { maxSize: 66, type: "BD66" },
      { maxSize: 100, type: "BD100" }
    ];
    for (const { maxSize, type } of DISK_TYPES) {
      if (GBSize < maxSize) {
        return type;
      }
    }
    return "Unknown";
  };
  const getAudioCodecFromSource = (source) => {
    if (!source) {
      return "";
    }
    const formattedSource = source.replace(/:|-|\s|\./g, "");
    const { CODEC_RULES } = CONFIG$3;
    for (const { codec, regex } of CODEC_RULES) {
      if (regex.test(formattedSource)) {
        return codec;
      }
    }
    return "";
  };
  const parseMedia = (source, isBluray = false) => {
    if (!source) {
      return null;
    }
    const parser = isBluray ? new BDInfoParser(source) : new MediaInfoParser(source);
    return parser.parse();
  };
  const CONFIG$2 = {
    URLS: {
      TMDB_API: "https://api.themoviedb.org",
      DOUBAN_SEARCH_API: "https://omit.mkrobot.org/movie/infos",
      DOUBAN_SUGGEST_API: (query) => `https://www.douban.com/search?cat=1002&q=${query}`,
      DOUBAN_SUBJECT: (id) => `https://movie.douban.com/subject/${id}/`,
      IMDB_URL: (id) => `https://www.imdb.com/title/${id}/`,
      DOUBAN_MOBILE_API: "https://m.douban.com/rexxar/api/v2",
      PT_GEN_API: (url) => `https://media.pttool.workers.dev?url=${url}`,
      IMDB_RATING_API: (id) => `https://p.media-imdb.com/static-content/documents/v1/title/${id}/ratings%3Fjsonp=imdb.rating.run:imdb.api.title.ratings/data.json`,
      ROTTEN_TOMATOES_API: "https://79frdp12pn-1.algolianet.com/1/indexes/*/queries?x-algolia-agent=Algolia%20for%20JavaScript%20(4.24.0)%3B%20Browser%20(lite)&x-algolia-api-key=175588f6e5f8319b27702e4cc4013561&x-algolia-application-id=79FRDP12PN"
    },
    KEY: {
      TMDB_API_KEY: "4a06eb7286be2d481fdb30e0a6b4ad77"
    },
    REGION_PATTERNS: {
      US: /USA|US|Canada|CA|美国|加拿大|United States/i,
      EU: /欧|英|法|德|俄|意|苏联|西班牙|EU/i,
      JP: /Japan|日本|JP/i,
      KR: /Korea|韩国|KR/i,
      TW: /Taiwan|台湾|TW/i,
      HK: /Hong\s?Kong|香港|HK/i,
      IN: /India|印度|IN/i,
      AU: /Australia|澳大利亚|AU/i,
      CN: /CN|China|大陆|中|内地|Mainland/i
    },
    EUROPE_LIST: [
      "Albania",
      "Andorra",
      "Armenia",
      "Austria",
      "Azerbaijan",
      "Belarus",
      "Belgium",
      "Bosnia and Herzegovina",
      "Bulgaria",
      "Croatia",
      "Cyprus",
      "Czech Republic",
      "Denmark",
      "Estonia",
      "Finland",
      "France",
      "Georgia",
      "Germany",
      "Greece",
      "Hungary",
      "Iceland",
      "Ireland",
      "Italy",
      "Kazakhstan",
      "Latvia",
      "Liechtenstein",
      "Lithuania",
      "Luxembourg",
      "Malta",
      "Moldova",
      "Monaco",
      "Montenegro",
      "Netherlands",
      "North Macedonia",
      "Norway",
      "Poland",
      "Portugal",
      "Romania",
      "Russia",
      "San Marino",
      "Serbia",
      "Slovakia",
      "Slovenia",
      "Spain",
      "Sweden",
      "Switzerland",
      "Turkey",
      "Ukraine",
      "United Kingdom",
      "UK",
      "Vatican City"
    ]
  };
  const getIMDBData = async (imdbUrl) => {
    if (!imdbUrl) {
      throw new Error("No IMDB URL provided");
    }
    const data = await GMFetch(
      CONFIG$2.URLS.PT_GEN_API(imdbUrl),
      {
        responseType: "json"
      }
    );
    if (!data || !data.success) {
      throw new Error((data == null ? void 0 : data.error) || "Failed to get IMDB data");
    }
    return data;
  };
  const getIMDBRating = async (imdbId) => {
    var _a2, _b, _c, _d, _e;
    if (!imdbId) {
      throw new Error("No IMDB ID provided");
    }
    const url = CONFIG$2.URLS.IMDB_RATING_API(imdbId);
    const data = await GMFetch(url);
    const matchData = (_b = (_a2 = data == null ? void 0 : data.match(/[^(]+\((.+)\)/)) == null ? void 0 : _a2[1]) != null ? _b : "";
    if (!matchData) {
      throw new Error("No rating data found");
    }
    try {
      const ratingData = JSON.parse(matchData);
      return __spreadProps(__spreadValues({}, ratingData.resource), {
        id: (_e = (_d = (_c = ratingData.resource) == null ? void 0 : _c.id.match(/tt\d+/)) == null ? void 0 : _d[0]) != null ? _e : ""
      });
    } catch (e2) {
      throw new Error("Failed to parse rating data");
    }
  };
  const getIdByIMDbUrl = (imdbUrl) => {
    const imdbIdArray = /tt\d+/.exec(imdbUrl);
    if (imdbIdArray && imdbIdArray[0]) {
      return imdbIdArray[0];
    }
    return "";
  };
  const NBSP = " ";
  const CREDIT_INDENTATION = 24;
  const FORMAT_RULES = [
    {
      key: "poster",
      title: "",
      formatter: (url) => `[img]${url}[/img]
`
    },
    {
      key: "translatedTitle",
      title: "译名",
      formatter: (title) => title.join(" / ")
    },
    {
      key: "originalTitle",
      title: "片名"
    },
    {
      key: "year",
      title: "年代"
    },
    {
      key: "countries",
      title: "产地",
      formatter: (countries) => countries.join(" / ")
    },
    {
      key: "genres",
      title: "类别",
      formatter: (genres) => genres.join(" / ")
    },
    {
      key: "languages",
      title: "语言",
      formatter: (languages) => languages.join(" / ")
    },
    {
      key: "pubdate",
      title: "上映日期",
      formatter: (dates) => dates.join(" / ")
    },
    {
      key: "imdbRating",
      title: "IMDb评分"
    },
    {
      key: "imdbLink",
      title: "IMDb链接"
    },
    {
      key: "doubanRating",
      title: "豆瓣评分"
    },
    {
      key: "doubanLink",
      title: "豆瓣链接"
    },
    {
      key: "episodes_count",
      title: "集数"
    },
    {
      key: "durations",
      title: "片长",
      formatter: (durations) => durations.join(" / ")
    },
    {
      key: "tags",
      title: "标签",
      formatter: (tags2) => tags2.join(" | ")
    },
    {
      key: "creditsData",
      formatter: (creditsData) => `
${creditsData}`
    },
    {
      key: "intro",
      title: "简介",
      formatter: (intro) => `

  ${intro.replace(/\n/g, `
${NBSP.repeat(2)}`)}`
    },
    {
      key: "awards",
      title: "获奖情况",
      formatter: (awards) => `

  ${awards.replace(/\n/g, `
${NBSP.repeat(6)}`)}
`
    }
  ];
  class DoubanFormatter {
    constructor(id, type, imdbId = "") {
      this.doubanId = id;
      this.type = type;
      this.imdbId = imdbId;
    }
    async fetchAllData() {
      try {
        const [awards, credits, info, imdbData] = await Promise.all([
          getDoubanAwards(this.doubanId),
          getDoubanCreditsData(this.doubanId, this.type),
          getMobileDoubanInfo(this.doubanId, this.type),
          this.fetchIMDbData()
        ]);
        return { awards, credits, info, imdbData };
      } catch (e2) {
        throw new Error(
          `Failed to fetch data for Douban ID: ${this.doubanId} ${e2.message}`
        );
      }
    }
    async fetchIMDbData() {
      if (!this.imdbId) {
        this.imdbId = await getIMDbIDFromDouban(this.doubanId);
      }
      if (this.imdbId) {
        return await getIMDBRating(this.imdbId);
      }
      return null;
    }
    formatPosterUrl(poster) {
      if (poster.includes("img3")) {
        return poster.replace("img3", "img1").replace(/m(_ratio_poster)/, "l$1");
      }
      return poster;
    }
    formatTitles(data) {
      const { title, original_title: originalTitle, aka } = data;
      const translatedTitle = [...aka];
      if (originalTitle && originalTitle !== title) {
        translatedTitle.unshift(title);
      }
      return {
        translatedTitle: Array.from(new Set(translatedTitle)).filter(Boolean),
        originalTitle: originalTitle || title
      };
    }
    updateCredits(credits) {
      if (!credits || !credits.items || credits.items.length === 0) {
        return "";
      }
      const indentationMap = {
        2: 7,
        3: 2,
        4: 0,
        5: 0
      };
      const result = {};
      for (const item of credits.items) {
        if (!result[item.category]) {
          result[item.category] = [];
        }
        result[item.category].push(item);
      }
      const creditsData = [];
      for (const [category, items] of Object.entries(result)) {
        const celebrity = items.map((item) => {
          var _a2;
          return `${item.name}  ${(_a2 = item.latin_name) != null ? _a2 : ""}`;
        });
        const indentation = indentationMap[category.length] || 0;
        const celebrityKey = category.split("").join(NBSP.repeat(indentation));
        const celebrityValue = celebrity.join(`
${NBSP.repeat(CREDIT_INDENTATION)}`).trim();
        creditsData.push(`◎${celebrityKey}${NBSP.repeat(7)}${celebrityValue}`);
      }
      return creditsData.join("\n");
    }
    updateRating(data, imdbRating) {
      var _a2, _b;
      const { value, count } = data.rating;
      return {
        doubanRating: value ? `${value} (${count}人评分)` : "",
        imdbRating: `${(_a2 = imdbRating == null ? void 0 : imdbRating.rating) != null ? _a2 : 0}/10 from ${(_b = imdbRating == null ? void 0 : imdbRating.ratingCount) != null ? _b : 0} users`,
        doubanLink: CONFIG$2.URLS.DOUBAN_SUBJECT(this.doubanId),
        imdbLink: this.imdbId ? CONFIG$2.URLS.IMDB_URL(this.imdbId) : ""
      };
    }
    generateOutput(formatData) {
      const result = [];
      for (const rule of FORMAT_RULES) {
        const value = formatData[rule.key];
        if (value) {
          const formattedValue = rule.formatter ? rule.formatter(value) : value;
          const { title } = rule;
          if (!title) {
            result.push(formattedValue);
            continue;
          }
          let prefix = title + NBSP.repeat(7);
          if (title.length === 2) {
            prefix = title.split("").join(NBSP.repeat(7)) + NBSP.repeat(7);
          }
          result.push(`◎${prefix}${formattedValue}`);
        }
      }
      return result.join("\n").trim();
    }
    async format() {
      var _a2;
      const data = await this.fetchAllData();
      if (!(data == null ? void 0 : data.info)) {
        throw new Error("failed to fetch douban info");
      }
      const poster = this.formatPosterUrl((_a2 = data.info) == null ? void 0 : _a2.cover_url);
      const { translatedTitle, originalTitle } = this.formatTitles(data.info);
      const creditsData = this.updateCredits(data == null ? void 0 : data.credits);
      const { doubanRating, imdbRating, doubanLink, imdbLink } = this.updateRating(data.info, data == null ? void 0 : data.imdbData);
      const formatData = __spreadProps(__spreadValues({}, data.info), {
        awards: data.awards,
        poster,
        translatedTitle,
        originalTitle,
        creditsData,
        doubanRating,
        imdbRating,
        doubanLink,
        imdbLink,
        format: ""
      });
      return __spreadProps(__spreadValues({}, formatData), {
        format: this.generateOutput(formatData)
      });
    }
  }
  const getDoubanAwards = async (doubanId) => {
    const url = `${CONFIG$2.URLS.DOUBAN_SUBJECT(doubanId)}awards/`;
    const data = await GMFetch(url);
    const doc = new DOMParser().parseFromString(data, "text/html");
    const awardsDom = doc.querySelector("#content > div > div.article");
    if (!awardsDom) {
      return "";
    }
    return awardsDom == null ? void 0 : awardsDom.innerHTML.replace(/[ \n]/g, "").replace(/<\/li><li>/g, "</li> <li>").replace(/<\/a><span/g, "</a> <span").replace(/<(div|ul)[^>]*>/g, "\n").replace(/<[^>]+>/g, "").replace(/&nbsp;/g, " ").replace(/ +\n/g, "\n").trim();
  };
  const getIMDbIDFromDouban = async (doubanId) => {
    var _a2, _b, _c, _d;
    const doubanPage = await GMFetch(
      CONFIG$2.URLS.DOUBAN_SUBJECT(doubanId)
    );
    const dom = new DOMParser().parseFromString(doubanPage, "text/html");
    const spans = dom.querySelectorAll("#info > span.pl");
    const spansContainsIMDb = Array.from(spans).filter(
      (span) => {
        var _a3;
        return (_a3 = span.textContent) == null ? void 0 : _a3.includes("IMDb");
      }
    );
    const imdbId = (_d = (_c = (_b = (_a2 = spansContainsIMDb[0]) == null ? void 0 : _a2.nextSibling) == null ? void 0 : _b.nodeValue) == null ? void 0 : _c.trim()) != null ? _d : "";
    return imdbId;
  };
  const getMobileDoubanInfo = async (id, type) => {
    if (!id) {
      throw new Error("No Douban ID found");
    }
    const url = `${CONFIG$2.URLS.DOUBAN_MOBILE_API}/${type}/${id}`;
    const data = await GMFetch(`${url}?for_mobile=1&ck=`, {
      headers: {
        Referer: `https://m.douban.com/${type}/subject/${id}`
      },
      responseType: "json"
    });
    if (data && data.title === "未知电影") {
      throw new Error("Please login in Douban to and try again");
    }
    return data;
  };
  const getDoubanBasicDataByQuery = async (query) => {
    var _a2, _b, _c, _d;
    if (!query) {
      throw new Error("No query provided");
    }
    const imdbId = getIdByIMDbUrl(query);
    const searchParams = imdbId || query;
    const url = CONFIG$2.URLS.DOUBAN_SUGGEST_API(searchParams);
    const data = await GMFetch(url);
    const doc = new DOMParser().parseFromString(data, "text/html");
    const linkDom = doc.querySelector(".result-list .result h3 a");
    if (!linkDom) {
      throw new Error("No Douban Item was found");
    } else {
      const { href, textContent } = linkDom;
      const season = (_b = (_a2 = textContent == null ? void 0 : textContent.match(/第(.+?)季/)) == null ? void 0 : _a2[1]) != null ? _b : "";
      const doubanId = (_d = (_c = decodeURIComponent(href).match(/subject\/(\d+)/)) == null ? void 0 : _c[1]) != null ? _d : "";
      return {
        id: doubanId,
        season,
        isTV: !!season,
        title: textContent
      };
    }
  };
  const getDoubanTVItemData = async (doubanData, torrentTitle) => {
    var _a2, _b;
    const { title } = doubanData;
    const seasonNumber = (_b = (_a2 = torrentTitle == null ? void 0 : torrentTitle.match(/S(?!eason)?0?(\d+)\.?(EP?\d+)?/i)) == null ? void 0 : _a2[1]) != null ? _b : "1";
    if (parseInt(seasonNumber, 10) === 1) {
      return doubanData;
    }
    const query = title == null ? void 0 : title.replace(/第.+?季/, `第${seasonNumber}季`);
    const response = await getDoubanBasicDataByQuery(query);
    return response;
  };
  const getDoubanCreditsData = async (id, type) => {
    const url = `${CONFIG$2.URLS.DOUBAN_MOBILE_API}/${type}/${id}/credits?for_mobile=1&ck=`;
    const data = await GMFetch(url, {
      headers: {
        Referer: `https://m.douban.com/${type}/subject/${id}`
      },
      responseType: "json"
    });
    return data;
  };
  const getDoubanBookInfo = async (doubanUrl) => {
    const reqUrl = CONFIG$2.URLS.PT_GEN_API(doubanUrl);
    const data = await GMFetch(reqUrl, {
      responseType: "json"
    });
    return data;
  };
  const getDoubanInfoByIdOrDoubanUrl = async (query, type = "movie", imdbId) => {
    var _a2, _b;
    let doubanId = query;
    if (!/^\d/.test(query)) {
      doubanId = (_b = (_a2 = query == null ? void 0 : query.match(/douban\.com\/subject\/(\d+)/)) == null ? void 0 : _a2[1]) != null ? _b : "";
    }
    const parser = new DoubanFormatter(doubanId, type, imdbId);
    return await parser.format();
  };
  const getTMDBDataByIMDBId = async (imdbid) => {
    const url = `${CONFIG$2.URLS.TMDB_API}/3/find/${imdbid}?api_key=${CONFIG$2.KEY.TMDB_API_KEY}&language=en&external_source=imdb_id`;
    const data = await GMFetch(url, {
      responseType: "json"
    });
    const movieFound = data.movie_results && data.movie_results.length > 0;
    const tvFound = data.tv_results && data.tv_results.length > 0;
    if (!movieFound && !tvFound) {
      throw new Error("No movie or TV found");
    }
    const tmdbData = movieFound ? data.movie_results[0] : data.tv_results[0];
    return tmdbData;
  };
  const getTMDBVideosById = async (tmdbId) => {
    var _a2;
    const url = `${CONFIG$2.URLS.TMDB_API}/3/movie/${tmdbId}/videos?api_key=${CONFIG$2.KEY.TMDB_API_KEY}&language=en`;
    const data = await GMFetch(url, {
      responseType: "json"
    });
    if (!(data == null ? void 0 : data.results) || ((_a2 = data == null ? void 0 : data.results) == null ? void 0 : _a2.length) === 0) {
      throw new Error("No TMDB videos found");
    }
    return data.results;
  };
  const getAreaCode = (area) => {
    const europeList = CONFIG$2.EUROPE_LIST;
    if (!area) return "OT";
    if (europeList.includes(area)) return "EU";
    for (const [code2, pattern] of Object.entries(CONFIG$2.REGION_PATTERNS)) {
      if (pattern.test(area)) return code2;
    }
    return "OT";
  };
  const getRottenTomatoesDataByQuery = async (query) => {
    var _a2, _b, _c;
    const res = await GMFetch(
      CONFIG$2.URLS.ROTTEN_TOMATOES_API,
      {
        data: {
          requests: [
            {
              indexName: "content_rt",
              query
            }
          ]
        },
        responseType: "json"
      }
    );
    return (_c = (_b = (_a2 = res == null ? void 0 : res.results) == null ? void 0 : _a2[0]) == null ? void 0 : _b.hits) != null ? _c : [];
  };
  const getMatchRottenTomatoes = async (title, year, isTV) => {
    var _a2;
    try {
      const MAX_YEAR_DIFF = 2;
      const releaseYear = parseInt(year || "1800", 10);
      const searchResultHits = await getRottenTomatoesDataByQuery(title);
      const filteredHits = searchResultHits.filter(
        (hit) => hit.type === (isTV ? "tv" : "movie")
      );
      if (!filteredHits.length) return null;
      filteredHits.sort((a2, b) => {
        const diffA = Math.abs(a2.releaseYear - releaseYear);
        const diffB = Math.abs(b.releaseYear - releaseYear);
        return diffA !== diffB ? diffA - diffB : b.releaseYear - a2.releaseYear;
      });
      const normalizedTitle = title.toLowerCase();
      let bestMatch, closeMatch;
      for (const hit of filteredHits) {
        const itemTitle = ((_a2 = hit.title) == null ? void 0 : _a2.toLowerCase()) || "";
        if (itemTitle === normalizedTitle) {
          bestMatch = hit;
        } else if (itemTitle.startsWith(normalizedTitle)) {
          closeMatch = closeMatch || hit;
        }
        if (bestMatch) break;
      }
      const isYearCompatible = (rtYear) => Math.abs(rtYear - releaseYear) <= MAX_YEAR_DIFF;
      if (releaseYear && (!bestMatch || !isYearCompatible(bestMatch.releaseYear))) {
        if (closeMatch && isYearCompatible(closeMatch.releaseYear)) {
          bestMatch = closeMatch;
        } else if (filteredHits.length > 0 && isYearCompatible(filteredHits[0].releaseYear)) {
          bestMatch = filteredHits[0];
        }
      }
      bestMatch = bestMatch || closeMatch || searchResultHits[0];
      return bestMatch;
    } catch (error) {
      console.error("Error fetching data from Rotten Tomatoes:", error);
      return null;
    }
  };
  const getSubTitleFromDoubanInfo = (data, torrentInfo) => {
    var _a2, _b;
    const { originalTitle, translatedTitle, title: doubanDefaultTitle } = data;
    let title = "";
    if (doubanDefaultTitle.match(/[\u4e00-\u9fa5]+/)) {
      title += doubanDefaultTitle;
    }
    const moreTitle = [originalTitle, ...translatedTitle].filter(
      (item) => title !== item
    );
    const { title: torrentTitle, hardcodedSub } = torrentInfo;
    let seasonEpisode = (_b = (_a2 = torrentTitle.match(/S\d+EP?(\d+)?/i)) == null ? void 0 : _a2[1]) != null ? _b : "";
    seasonEpisode = seasonEpisode.replace(/^0/i, "");
    const episode = seasonEpisode ? ` 第${seasonEpisode}集` : "";
    const hardcodedSubStr = hardcodedSub ? "| 硬字幕" : "";
    return `${title}${moreTitle.length > 0 ? "/" : ""}${moreTitle.join("/")}${episode} ${hardcodedSubStr}`;
  };
  class FillerRegistry {
    constructor() {
      this.fillers = [];
    }
    register(filler) {
      this.fillers.push(filler);
      this.fillers.sort((a2, b) => b.priority - a2.priority);
    }
    getApplicableFiller(siteName, siteType) {
      return this.fillers.find((filler) => filler.canHandle(siteName, siteType)) || null;
    }
  }
  const registry$1 = new FillerRegistry();
  const base64ToBlob = (base64, contentType = "application/x-bittorrent", sliceSize = 512) => {
    const regStr = new RegExp(`data:${contentType};base64,`, "i");
    const byteCharacters = window.atob(base64.replace(regStr, ""));
    const byteArrays = [];
    for (let offset = 0; offset < byteCharacters.length; offset += sliceSize) {
      const slice = byteCharacters.slice(offset, offset + sliceSize);
      const byteNumbers = new Array(slice.length);
      for (let i = 0; i < slice.length; i++) {
        byteNumbers[i] = slice.charCodeAt(i);
      }
      const byteArray = new Uint8Array(byteNumbers);
      byteArrays.push(byteArray);
    }
    return new Blob(byteArrays, { type: contentType });
  };
  const filterEmptyTags = (description) => {
    const reg = new RegExp(
      "\\[(?!info)([a-zA-Z]+\\d?)(?:=(?:\\w|\\s)+)?\\]\\s*\\[\\/(\\w+)\\]",
      "g"
    );
    if (description.match(reg)) {
      description = description.replace(reg, (_match, p1, p2) => {
        if (p1 === p2) {
          return "";
        }
        return _match;
      });
      return filterEmptyTags(description);
    }
    return description;
  };
  const getTeamName = (title) => {
    var _a2, _b, _c;
    const teamMatch = title.match(/-([^-]+)$/);
    let teamName = (_c = (_b = (_a2 = teamMatch == null ? void 0 : teamMatch[1]) == null ? void 0 : _a2.replace(/-/g, "")) == null ? void 0 : _b.split("@")) != null ? _c : "";
    if (teamName) {
      teamName = teamName.length > 1 ? teamName[1] : teamName[0];
    } else {
      teamName = "other";
    }
    return teamName;
  };
  const fixTorrentTitle = (title, isWebSource) => {
    let fixedTitle = title.replace(" DoVi ", " DV ").replace(" DDP ", " DD+ ");
    if (isWebSource) fixedTitle = fixedTitle.replace(" HEVC", " H.265");
    return fixedTitle;
  };
  const extractChineseMovieName = (description, subtitle) => {
    var _a2, _b, _c, _d, _e, _f, _g, _h, _i;
    const originalName = (_b = (_a2 = description.match(/(片\s+名)\s+(.+)?/)) == null ? void 0 : _a2[2]) != null ? _b : "";
    const translateName = (_f = (_e = (_d = (_c = description.match(/(译\s+名)\s+(.+)/)) == null ? void 0 : _c[2]) == null ? void 0 : _d.split("/")) == null ? void 0 : _e[0]) != null ? _f : "";
    let chineseName = originalName;
    if (!originalName.match(/[\u4e00-\u9fa5]+/)) {
      chineseName = translateName.match(/[\u4e00-\u9fa5]+/) ? translateName : "";
    }
    if (chineseName === "" && subtitle !== "" && subtitle !== void 0) {
      chineseName = (_h = (_g = subtitle == null ? void 0 : subtitle.replace(/【|】.*/g, "").split("/")) == null ? void 0 : _g[0]) != null ? _h : "";
    }
    return (_i = chineseName == null ? void 0 : chineseName.trim()) != null ? _i : "";
  };
  const replaceAlignTagsToQuote = (description) => {
    description = description.replace(/\[(right|left|center)\]/gi, "[quote]").replace(/\[\/(right|left|center)\]/gi, "[/quote]");
    return description;
  };
  const filterNexusDescription = (description, screenshots) => {
    let filterDescription = "";
    const quoteList = description.match(/\[quote(=\w+)?\](.|\n)+?\[\/quote\]/g);
    if (quoteList && quoteList.length > 0) {
      quoteList.forEach((quote) => {
        const isMediaInfoOrBDInfo = quote.match(
          /Disc\s?Size|\.mpls|Unique\s?ID|唯一ID|Resolution/i
        );
        if (!quote.match(/[\u4e00-\u9fa5]+/i) || isMediaInfoOrBDInfo) {
          filterDescription += `${quote}
`;
        }
      });
    }
    if (screenshots.length > 0) {
      filterDescription += `
${screenshots.map((v2) => `[img]${v2}[/img]`).join("\n")}

`;
    }
    return filterDescription;
  };
  const buildPTPDescription = (info) => {
    let text2 = info.originalDescription || "";
    text2 = text2.replace(/http:\/\/ptpimg\.me/g, "https://ptpimg.me");
    for (const mediainfo of info.mediaInfos) {
      text2 = text2.replace(mediainfo, "");
    }
    text2 = text2.replace(
      /\[(mediainfo|bdinfo)\][\s\S]*?\[\/(mediainfo|bdinfo)\]/gi,
      ""
    );
    text2 = text2.replace(
      /^(?!\[img\])https:\/\/ptpimg.me.*?png(?!\[\/img\])$/gim,
      (imgUrl) => {
        return `[img]${imgUrl}[/img]`;
      }
    );
    text2 = text2.replace(
      /\[comparison.*\][\s\S]*\[\/comparison\]/gi,
      (comparisonText) => {
        return comparisonText.replace(/\[img\]/g, "").replace(/\[\/img\]/g, "").split("https://ptpimg.me").join("\nhttps://ptpimg.me").replace(/\s*\n\s*/g, "\n");
      }
    );
    text2 = text2.replace(
      /\[hide(.*)?\]\s*\[url=https:\/\/ptpimg.me.*?png\]\[img\][\s\S]*?\[\/hide\]/gi,
      (imgText) => {
        var _a2;
        const imgs = [];
        for (const urlMatch of imgText.matchAll(/\[url=(.*?)\]/gi)) {
          imgs.push(urlMatch[1]);
        }
        const rawTitle = ((_a2 = imgText.match(/^\[hide=(.*?)\]/)) == null ? void 0 : _a2[1]) || "";
        const comparisonTitles = rawTitle.trim().split(/\||\/|,|vs\.?| - /i).map((v2) => v2.trim());
        if (comparisonTitles.length >= 2) {
          return `[comparison=${comparisonTitles.join(", ")}]
${imgs.join("\n")}
[/comparison]
`;
        }
        const hideTitle = rawTitle ? `=${rawTitle}` : "";
        return `[hide${hideTitle}]
[img]${imgs.join("[/img]\n[img]")}[/img]
[/hide]
`;
      }
    );
    text2 = `${text2}

`;
    text2 = text2.replace(
      /\[url=https:\/\/ptpimg.me.*?png\]\[img\][\s\S]*?\n\n/gi,
      (imgText) => {
        const imgs = [];
        for (const urlMatch of imgText.matchAll(/\[url=(.*?)\]/gi)) {
          imgs.push(urlMatch[1]);
        }
        return `[hide]
[img]${imgs.join("[/img]\n[img]")}[/img]
[/hide]
`;
      }
    );
    text2 = text2.replace(/\[img=(.+)?\](\n\n)?/gi, "[img]$1[/img]");
    text2 = text2.replace(/\[(\/)?IMG\]/g, "[$1img]");
    text2 = text2.replace(/\n\s*\n/g, "\n\n");
    return text2.trim();
  };
  var SiteIMDbType = /* @__PURE__ */ ((SiteIMDbType2) => {
    SiteIMDbType2["Standard"] = "standard";
    SiteIMDbType2["StripTT"] = "strip_tt";
    SiteIMDbType2["UNIT3D"] = "unit3d";
    SiteIMDbType2["IMDbID"] = "imdb_id";
    return SiteIMDbType2;
  })(SiteIMDbType || {});
  const siteIMDbTypeMap = {
    HDRoute: "strip_tt",
    HDSpace: "strip_tt",
    BeyondHD: "imdb_id",
    Blutopia: "unit3d",
    fearnopeer: "unit3d",
    HDPOST: "unit3d",
    ACM: "unit3d",
    Aither: "unit3d",
    Concertos: "unit3d",
    MDU: "unit3d",
    LST: "unit3d",
    HUNO: "unit3d"
    /* UNIT3D */
  };
  class BaseFiller {
    constructor() {
      this.priority = 5;
      this.info = null;
      this.siteInfo = CURRENT_SITE_INFO;
      this.imdbId = "";
      this.isCustomSite = false;
      this.isChineseTacker = (siteType) => {
        return siteType.match(/NexusPHP|TTG|TNode|MTeam/);
      };
      this.mapAndFilterSelectValues = (key, selectArray) => {
        var _a2;
        const { siteInfo } = this;
        if (!siteInfo[key] || !this.info[key]) {
          return selectArray || [];
        }
        const mappedValue = (_a2 = siteInfo[key].map) == null ? void 0 : _a2[this.info[key]];
        if (!mappedValue) {
          return selectArray || [];
        }
        if (Array.isArray(mappedValue)) {
          if (siteInfo[key].selector) {
            const valuesCopy = [...mappedValue];
            const firstValue = valuesCopy.shift();
            this.setSelectValue(siteInfo[key].selector, firstValue || "");
          }
          if (Array.isArray(selectArray) && selectArray.length > 1) {
            return selectArray.filter((item) => mappedValue.includes(item));
          }
          return selectArray || [];
        } else if (siteInfo[key].selector) {
          this.setSelectValue(siteInfo[key].selector, mappedValue);
          return selectArray || [];
        }
        return selectArray || [];
      };
    }
    fill(info) {
      this.info = info;
      this.prepareToFillInfo();
      this.fillTorrentTitle();
      this.disableTorrentChange();
      this.fillIMDb();
      this.fillDescription();
      this.fillBasicAttributes();
      this.fillCategory();
      this.fillRemainingInfo();
      this.fillTorrentFile();
      this.postProcess();
    }
    disableTorrentChange() {
      var _a2, _b;
      const nameSelector = (_b = (_a2 = this.siteInfo.name) == null ? void 0 : _a2.selector) != null ? _b : "";
      if (nameSelector.match(/^#\w+/)) {
        const nameDom = $$2(nameSelector).clone().attr("name", "").hide();
        $$2(nameSelector).attr("id", "").after(nameDom);
      }
    }
    fillTorrentFile() {
      const { torrentData, title } = this.info;
      const { torrent } = this.siteInfo;
      if (!torrent) {
        return;
      }
      const fileInput = $$2(torrent.selector);
      if (torrentData && fileInput.length > 0) {
        const blob = base64ToBlob(torrentData);
        const torrentFileName = title == null ? void 0 : title.replace(/\s/g, ".");
        const file = new File([blob], `${torrentFileName}.torrent`, {
          type: "application/x-bittorrent"
        });
        const dataTransfer = new DataTransfer();
        dataTransfer.items.add(file);
        const uploadInput = fileInput[0];
        if (CURRENT_SITE_NAME === "MTeam") {
          setTimeout(() => {
            const lastValue = uploadInput.files;
            uploadInput.files = dataTransfer.files;
            const tracker = uploadInput._valueTracker;
            if (tracker) {
              tracker.setValue(lastValue);
            }
            const event = new Event("change", { bubbles: true });
            uploadInput.dispatchEvent(event);
          }, 100);
        } else {
          uploadInput.files = dataTransfer.files;
        }
      }
    }
    prepareToFillInfo() {
    }
    processTorrentTitle() {
      const { title } = this.info;
      const fixedTitle = title.replace("H 265", "H.265").replace("H 264", "H.264");
      this.info.title = fixedTitle;
    }
    fillTorrentTitle() {
      this.processTorrentTitle();
      const { name } = this.siteInfo;
      if (name) {
        $$2(name.selector).val(this.info.title);
      }
    }
    async fillIMDb() {
      var _a2, _b;
      const { imdbUrl = "" } = this.info;
      const { imdb: imdbConfig, tmdb: tmdbConfig } = this.siteInfo;
      this.imdbId = getIdByIMDbUrl(imdbUrl);
      if (!(imdbConfig == null ? void 0 : imdbConfig.selector)) {
        return;
      }
      const stripTTIMBb = (_b = (_a2 = this.imdbId) == null ? void 0 : _a2.replace("tt", "")) != null ? _b : "";
      if (siteIMDbTypeMap[CURRENT_SITE_NAME] === SiteIMDbType.StripTT) {
        $$2(imdbConfig.selector).val(stripTTIMBb);
      } else if (siteIMDbTypeMap[CURRENT_SITE_NAME] === SiteIMDbType.UNIT3D) {
        $$2(imdbConfig.selector).val(stripTTIMBb);
        const { id: tmdbId } = await getTMDBDataByIMDBId(this.imdbId);
        $$2(tmdbConfig.selector).val(tmdbId);
        $$2("#torrent").on("change", () => {
          $$2(imdbConfig).val(stripTTIMBb);
          $$2(tmdbConfig.selector).val(tmdbId);
          $$2("#automal").val(0);
        });
      } else if (siteIMDbTypeMap[CURRENT_SITE_NAME] === SiteIMDbType.IMDbID) {
        $$2(imdbConfig.selector).val(this.imdbId);
      } else {
        $$2(imdbConfig.selector).val(imdbUrl);
      }
    }
    processDescription() {
      const { description, sourceSite } = this.info;
      let fixedDescription = description.replace(/^(\s+)/g, "");
      fixedDescription = filterEmptyTags(fixedDescription);
      fixedDescription = this.addOrFilterDescription(fixedDescription);
      fixedDescription = this.fillMediaInfo(fixedDescription);
      fixedDescription = this.fillScreenshots(fixedDescription);
      fixedDescription = this.fillPoster(fixedDescription);
      const thanksQuoteClosed = GM_getValue("easy-upload.thanks-quote-closed") || "";
      if (!thanksQuoteClosed && sourceSite) {
        fixedDescription = this.getThanksQuote() + fixedDescription.trim();
      }
      this.info.description = fixedDescription;
    }
    addOrFilterDescription(description) {
      const { doubanInfo, sourceSiteType, screenshots } = this.info;
      const IfAddDoubanInfo = this.isChineseTacker(this.siteInfo.siteType) && CURRENT_SITE_NAME !== "SSD";
      const ifFilterNexusDescription = this.isChineseTacker(sourceSiteType) && CURRENT_SITE_NAME !== "Bib";
      if (IfAddDoubanInfo) {
        if (doubanInfo) {
          description = `${doubanInfo}
${description}`;
        }
      } else if (ifFilterNexusDescription) {
        description = filterNexusDescription(description, screenshots);
      }
      return description;
    }
    fillMediaInfo(description) {
      const { mediaInfo } = this.siteInfo;
      if (!mediaInfo) {
        return description;
      }
      const { mediaInfos, videoType } = this.info;
      if (!mediaInfos || mediaInfos.length === 0) {
        return description;
      }
      const isBluray = /bluray/i.test(videoType);
      if (this.siteInfo.siteType === "UNIT3D") {
        const selector = isBluray ? 'textarea[name="bdinfo"]' : this.siteInfo.mediaInfo.selector;
        $$2(selector).val(mediaInfos[0]);
        description = description.replace(mediaInfos[0].trim(), "");
      } else if (isBluray && CURRENT_SITE_NAME.match(/^(SpeedApp)/)) {
        $$2(this.siteInfo.bdinfo.selector).val(mediaInfos[0]);
        this.info.mediaInfos = [];
      } else if (!(isBluray && CURRENT_SITE_NAME.match(/^(HDBits)/))) {
        $$2(this.siteInfo.mediaInfo.selector).val(mediaInfos[0]);
        description = description.replace(mediaInfos[0].trim(), "");
      }
      return description;
    }
    fillScreenshots(description) {
      const { screenshots } = this.info;
      if (this.siteInfo.screenshots) {
        screenshots.forEach((img) => {
          if (description.includes(img)) {
            description = description.replace(img, "");
            if (!img.match(/\[url=.+?\[url]/)) {
              description = description.replace(/\[img\]\[\/img\]\n*/g, "");
            }
          }
        });
      }
      return description;
    }
    fillPoster(description) {
      var _a2, _b;
      let { doubanInfo, poster } = this.info;
      if (this.siteInfo.poster) {
        if (!poster) {
          const doubanPosterImage = (description + doubanInfo).match(
            /\[img\](http[^[]+?(poster|(img\d\.doubanio))[^[]+?)\[\/img\]/
          );
          if (doubanPosterImage && doubanPosterImage[1]) {
            poster = doubanPosterImage[1];
          } else {
            poster = (_b = (_a2 = description.match(/\[img\](.+?)\[\/img\]/)) == null ? void 0 : _a2[1]) != null ? _b : "";
          }
        }
        if (poster) {
          $$2(this.siteInfo.poster).val(poster);
          if (CURRENT_SITE_NAME === "HDRoute") {
            $$2('input[name="poster"]').val(poster);
            description = description.replace(poster, "");
          }
        }
      }
      return description;
    }
    fillDescription() {
      var _a2;
      this.processDescription();
      $$2((_a2 = this.siteInfo.description) == null ? void 0 : _a2.selector).val(this.info.description);
    }
    getThanksQuote() {
      const { sourceSite } = this.info;
      const isChineseSite = this.isChineseTacker(this.siteInfo.siteType) || CURRENT_SITE_NAME.match(/HDPOST|GPW/);
      let thanksQuote = `转自[b]${sourceSite}[/b]，感谢原发布者！`;
      if (!isChineseSite) {
        thanksQuote = `Torrent from [b]${sourceSite}[/b].
All thanks to the original uploader!`;
      }
      return `[quote]${thanksQuote}[/quote]

`;
    }
    fillBasicAttributes() {
      const commonInfoKeys = [
        "subtitle",
        "douban",
        "area",
        "audioCodec"
      ];
      const { doubanUrl } = this.info;
      commonInfoKeys.forEach((key) => {
        const siteInfo = this.siteInfo[key];
        if (siteInfo && siteInfo.selector) {
          let value = this.info[key];
          if (key === "douban") {
            value = doubanUrl;
          } else if (key === "area" || key === "audioCodec") {
            value = siteInfo.map[value];
          }
          $$2(siteInfo.selector).val(value || "");
        }
      });
    }
    setSelectValue(selector, value) {
      const selectElement = $$2(selector);
      if (selectElement.length > 0) {
        selectElement.val(value).trigger("change");
      }
    }
    fillCategory() {
      const categoryConfig = this.siteInfo.category;
      const { category: categoryKey } = this.info;
      if (!categoryConfig || !categoryKey) {
        return;
      }
      const categoryMapValue = categoryConfig.map[categoryKey];
      const keyArray = [
        "videoCodec",
        "videoType",
        "resolution",
        "source",
        "area"
      ];
      let finalSelectArray = [];
      if (Array.isArray(categoryMapValue)) {
        finalSelectArray = [...categoryMapValue];
        keyArray.forEach((key) => {
          finalSelectArray = this.mapAndFilterSelectValues(
            key,
            finalSelectArray
          );
          if (finalSelectArray.length === 1) {
            this.setSelectValue(categoryConfig.selector, finalSelectArray[0]);
          }
        });
      } else {
        [...keyArray, "category"].forEach((key) => {
          this.mapAndFilterSelectValues(key, finalSelectArray);
        });
      }
    }
    fillRemainingInfo() {
      const {
        format: formatConfig,
        image: imageConfig,
        anonymous: anonymousConfig,
        tags: tagsConfig
      } = this.siteInfo;
      const { format: format2, image, tags: tags2 } = this.info;
      if (formatConfig) {
        $$2(formatConfig.selector).val(formatConfig.map[format2]);
      }
      if (imageConfig) {
        $$2(imageConfig.selector).val(image || "");
      }
      if (anonymousConfig) {
        const { selector, value = "" } = anonymousConfig;
        if (value) {
          $$2(selector).val(value);
        } else {
          $$2(selector).attr("checked", "true");
        }
      }
      if (tagsConfig) {
        Object.keys(tags2).forEach((key) => {
          if (tags2[key] && tagsConfig[key]) {
            $$2(tagsConfig[key]).attr("checked", "true");
          }
        });
      }
      this.fillTeamName();
    }
    fillTeamName() {
      const teamConfig = this.siteInfo.team;
      const { title } = this.info;
      if (!teamConfig || !title) {
        return;
      }
      const teamName = getTeamName(title);
      if (!teamName) {
        return;
      }
      if (teamName && teamConfig) {
        const formateTeamName = teamConfig.map[teamName.toLowerCase()];
        const matchValue = formateTeamName || teamConfig.map.other;
        if (matchValue) {
          $$2(teamConfig.selector).val(matchValue.toLowerCase());
        }
      }
    }
    postProcess() {
    }
  }
  class Filler52pt extends BaseFiller {
    constructor() {
      super(...arguments);
      this.priority = 10;
    }
    canHandle(siteName) {
      return siteName === "52pt";
    }
    postProcess() {
      const { tags: tags2, videoType, resolution } = this.info;
      let videoTypeValue = videoType;
      if (videoType.match(/bluray/)) {
        if (tags2.chinese_audio || tags2.cantonese_audio || tags2.chinese_subtitle) {
          videoTypeValue = videoType === "bluray" ? "14" : "15";
        }
      } else if (videoType === "remux" && resolution === "2160p") {
        videoTypeValue = "5";
      }
      $$2(this.siteInfo.videoType.selector).val(videoTypeValue);
    }
  }
  registry$1.register(new Filler52pt());
  class Bib extends BaseFiller {
    constructor() {
      super(...arguments);
      this.priority = 10;
    }
    canHandle(siteName) {
      return siteName === "Bib";
    }
    fill(info) {
      var _a2;
      this.info = info;
      if (!this.info || !this.info.doubanBookInfo) return;
      const {
        year,
        pager,
        translator,
        author,
        publisher,
        ISBN,
        book_intro: intro,
        poster
      } = this.info.doubanBookInfo;
      $$2("#AuthorsField").val(author.join(","));
      $$2("#PublishersField").val(publisher);
      $$2("#IsbnField").val(ISBN);
      $$2("#YearField").val(year);
      $$2("#PagesField").val(pager);
      $$2("#LanguageField").val("17");
      $$2("#inputFileID").replaceWith(
        '<textarea name="DescriptionField" id="DescriptionField" rows="15" cols="90"></textarea>'
      );
      $$2("#TranslatorsField").val(translator.join(","));
      $$2("#DescriptionField").val(intro);
      $$2("#ImageField").val(poster);
      const event = new Event("change");
      (_a2 = document.getElementById("DescriptionField")) == null ? void 0 : _a2.dispatchEvent(event);
      this.fillTorrentFile();
    }
  }
  registry$1.register(new Bib());
  const CONFIG$1 = {
    HDB_TEAM: [
      "Chotab",
      "CRiSC",
      "CtrlHD",
      "DON",
      "EA",
      "EbP",
      "Geek",
      "LolHD",
      "NTb",
      "RightSiZE",
      "SA89",
      "SbR",
      "TayTo",
      "VietHD"
    ]
  };
  class BTSCHOOL extends BaseFiller {
    constructor() {
      super(...arguments);
      this.priority = 10;
    }
    canHandle(siteName) {
      return siteName === "BTSCHOOL";
    }
    postProcess() {
      var _a2, _b;
      const { doubanUrl } = this.info;
      $$2(this.siteInfo.imdb.selector).val(this.imdbId);
      if (doubanUrl) {
        const doubanId = (_b = (_a2 = doubanUrl.match(/\/(\d+)/)) == null ? void 0 : _a2[1]) != null ? _b : "";
        $$2(this.siteInfo.douban.selector).val(doubanId);
      }
    }
    fillTeamName() {
      const { title } = this.info;
      const teamConfig = this.siteInfo.team;
      const teamName = getTeamName(title);
      if (CONFIG$1.HDB_TEAM.includes(teamName)) {
        $$2(teamConfig.selector).val(teamConfig.map.hdbint);
      }
    }
  }
  registry$1.register(new BTSCHOOL());
  class Concertos extends BaseFiller {
    constructor() {
      super(...arguments);
      this.priority = 10;
    }
    canHandle(siteName) {
      return siteName === "Concertos";
    }
    processTorrentTitle() {
      let { description, mediaInfos } = this.info;
      $$2("#add").trigger("click");
      $$2(".sceditor-button.sceditor-button-source.has-icon")[0].click();
      mediaInfos.forEach((mediaInfo) => {
        description = description.replace(mediaInfo.trim(), "");
      });
      this.info.description = description;
    }
    processDescription() {
      let { description, mediaInfos } = this.info;
      $$2("#add").trigger("click");
      $$2(".sceditor-button.sceditor-button-source.has-icon")[0].click();
      mediaInfos.forEach((mediaInfo) => {
        description = description.replace(mediaInfo.trim(), "");
      });
      this.info.description = description;
      super.processDescription();
    }
  }
  registry$1.register(new Concertos());
  class HDBits extends BaseFiller {
    constructor() {
      super(...arguments);
      this.priority = 10;
    }
    canHandle(siteName) {
      return siteName === "HDBits";
    }
    processTorrentTitle() {
      super.processTorrentTitle();
      const { title, videoType, movieName, movieAkaName } = this.info;
      let mediaTitle = title.replace(
        /([^\d]+)\s+([12][90]\d{2})/,
        (_2, p1, p2) => {
          return `${movieName || movieAkaName} ${p2}`;
        }
      );
      if (videoType === "remux") {
        mediaTitle = mediaTitle.replace(/\s+(bluray|blu-ray)/gi, "");
      }
      this.info.title = mediaTitle;
    }
  }
  registry$1.register(new HDBits());
  class HDFans extends BaseFiller {
    constructor() {
      super(...arguments);
      this.priority = 10;
    }
    canHandle(siteName) {
      return siteName === "HDFans";
    }
    postProcess() {
      const { videoType, resolution, tags: tags2 } = this.info;
      if (videoType === "remux") {
        $$2(this.siteInfo.videoType.selector).val(
          resolution === "2160p" ? "10" : "8"
        );
      } else if (videoType === "encode") {
        const map2 = {
          "2160p": "9",
          "1080p": "5",
          "1080i": "5",
          "720p": "11"
        };
        $$2(this.siteInfo.videoType.selector).val(
          map2[resolution] || "16"
        );
      }
      if (tags2.diy) {
        $$2(this.siteInfo.videoType.selector).val(
          resolution === "2160p" ? "2" : "4"
        );
      }
    }
  }
  registry$1.register(new HDFans());
  class HDRoute extends BaseFiller {
    constructor() {
      super(...arguments);
      this.priority = 10;
    }
    canHandle(siteName) {
      return siteName === "HDRoute";
    }
    postProcess() {
      var _a2, _b, _c, _d, _e, _f;
      const { description, doubanInfo, subtitle = "" } = this.info;
      const fullDescription = description + doubanInfo;
      const imdbRank = (_b = (_a2 = fullDescription.match(/IMDb评分\s+(\d(\.\d)?)/i)) == null ? void 0 : _a2[1]) != null ? _b : "";
      const chineseName = extractChineseMovieName(description, subtitle);
      const summary = (_f = (_e = (_d = (_c = fullDescription.match(/(简\s+介)\s+([^[◎]+)/)) == null ? void 0 : _c[2]) == null ? void 0 : _d.split("/")) == null ? void 0 : _e[0]) != null ? _f : "";
      $$2("#upload-imdb").val(imdbRank);
      $$2("#title_chs").val(chineseName);
      $$2("#upload_introduction").val(summary);
    }
  }
  registry$1.register(new HDRoute());
  class HDT extends BaseFiller {
    constructor() {
      super(...arguments);
      this.priority = 10;
    }
    canHandle(siteName) {
      return siteName === "HDT";
    }
    processDescription() {
      let { description } = this.info;
      description = description.replace(/(\[\/img\])(\[img\])/g, "$1 $2").replace(/(\[\/url\])(\[url)/g, "$1 $2");
      this.info.description = description;
      super.processDescription();
    }
    postProcess() {
      let { category, imdbUrl = "" } = this.info;
      if (category !== "tvPack") {
        $$2('select[name="season"').val("true");
      }
      if (!/.+\/$/.test(imdbUrl) && /tt\d+/.test(imdbUrl)) {
        imdbUrl += "/";
      }
      $$2(this.siteInfo.imdb.selector).val(imdbUrl);
    }
  }
  registry$1.register(new HDT());
  class HDTime extends BaseFiller {
    constructor() {
      super(...arguments);
      this.priority = 10;
    }
    canHandle(siteName) {
      return siteName === "HDTime";
    }
    postProcess() {
      if (this.info.videoType.match(/bluray/i)) {
        $$2(this.siteInfo.category.selector).val("424");
      }
    }
  }
  registry$1.register(new HDTime());
  class HDU extends BaseFiller {
    constructor() {
      super(...arguments);
      this.priority = 10;
    }
    canHandle(siteName) {
      return siteName === "HDU";
    }
    postProcess() {
      let videoTypeValue = "";
      const { resolution, videoType, category } = this.info;
      const isTV = category.match(/tv/);
      if (videoType === "remux") {
        if (resolution === "2160p") {
          videoTypeValue = isTV ? "16" : "15";
        } else {
          videoTypeValue = isTV ? "12" : "3";
        }
      }
      if (isTV) {
        if (videoType === "encode") {
          videoTypeValue = "14";
        } else if (videoType === "web") {
          videoTypeValue = "13";
        }
      }
      if (videoTypeValue) {
        $$2(this.siteInfo.videoType.selector).val(videoTypeValue);
      }
    }
  }
  registry$1.register(new HDU());
  class KEEPFRDS extends BaseFiller {
    constructor() {
      super(...arguments);
      this.priority = 10;
    }
    canHandle(siteName) {
      return siteName === "KEEPFRDS";
    }
    processTorrentTitle() {
      const { category, title, subtitle } = this.info;
      if (category === "music") {
        const subtitle2 = title;
        if (subtitle2 !== void 0) {
          this.info.title = subtitle2;
          this.info.subtitle = subtitle2;
        }
      } else if (subtitle === "") {
        this.info.subtitle = title;
      }
    }
    processDescription() {
      var _a2;
      let {
        description,
        sourceSite,
        mediaInfos,
        originalDescription,
        screenshots,
        category,
        title,
        subtitle
      } = this.info;
      description = description.replace(/\[\/?(center|code)\]/g, "");
      if (sourceSite === "PTP") {
        description = (_a2 = originalDescription == null ? void 0 : originalDescription.replace(/^(\s+)/g, "")) != null ? _a2 : "";
        description = filterEmptyTags(description);
        description = description.replace(/http:\/\/ptpimg/g, "https://ptpimg");
        screenshots.forEach((screenshot) => {
          const regStr = new RegExp(`\\[img${screenshot}\\[\\/img\\]`, "i");
          if (!description.match(regStr)) {
            const regOldFormat = new RegExp(`\\[img=${screenshot}\\]`, "i");
            if (description.match(regOldFormat)) {
              description = description.replace(
                regOldFormat,
                `[img]${screenshot}[/img]`
              );
            } else {
              description = description.replace(
                new RegExp(`(?<!\\[img\\])${screenshot}`, "gi"),
                `[img]${screenshot}[/img]`
              );
            }
          }
        });
      } else if (sourceSite === "RED") {
        description = description.replace(/\[#\]/g, "[*]");
      }
      $("#torrent").on("change", () => {
        if (category !== "music") {
          $(this.siteInfo.name.selector).val(title);
          if (subtitle) $(this.siteInfo.subtitle.selector).val(subtitle);
        } else {
          $(this.siteInfo.name.selector).val(subtitle || "");
          if (subtitle) $(this.siteInfo.subtitle.selector).val(title);
        }
      });
      mediaInfos == null ? void 0 : mediaInfos.forEach((mediaInfo) => {
        if (!/\[mediainfo\]/.test(description)) {
          description = description.replace(
            `[quote]${mediaInfo}[/quote]`,
            `[mediainfo]${mediaInfo}[/mediainfo]`
          );
        }
      });
      this.info.description = description;
      super.processDescription();
    }
  }
  registry$1.register(new KEEPFRDS());
  class NYPT extends BaseFiller {
    constructor() {
      super(...arguments);
      this.priority = 10;
    }
    canHandle(siteName) {
      return siteName === "NYPT";
    }
    postProcess() {
      const { category, title } = this.info;
      $$2("#browsecat").trigger("change");
      const domTimeout = setTimeout(() => {
        const catMap = {
          movie: "#movie_enname",
          tv: "#series_enname",
          tvPack: "#series_enname",
          documentary: "#doc_enname",
          variety: "#show_enname",
          cartoon: "#anime_enname"
        };
        const selector = catMap[category];
        if (selector) {
          $$2(selector).val(title);
        }
        clearTimeout(domTimeout);
      }, 2e3);
    }
  }
  registry$1.register(new NYPT());
  class PTN extends BaseFiller {
    constructor() {
      super(...arguments);
      this.priority = 10;
    }
    canHandle(siteName) {
      return siteName === "PTN";
    }
    processDescription() {
      let { description, imdbUrl } = this.info;
      description = `${imdbUrl}

${description}`;
      this.info.description = description;
      super.processDescription();
    }
    postProcess() {
      const { resolution, videoType, source } = this.info;
      let format2 = "";
      const formatMap2 = {
        remux: "Remux",
        web: "WebRip",
        dvd: "DVDR",
        dvdrip: "DVDRip",
        "720p": "720P",
        "1080p": "1080P",
        "2160p": "2160P"
      };
      if (videoType.match(/bluray/)) {
        format2 = "BluRay";
      } else if (videoType === "encode" && source === "bluray") {
        format2 = formatMap2[resolution];
      } else {
        format2 = formatMap2[videoType] || "";
      }
      $$2("#format").val(format2);
    }
  }
  registry$1.register(new PTN());
  class PTSBAO extends BaseFiller {
    constructor() {
      super(...arguments);
      this.priority = 10;
    }
    canHandle(siteName) {
      return siteName === "PTSBAO";
    }
    prepareToFillInfo() {
      if (localStorage.getItem("autosave")) {
        localStorage.removeItem("autosave");
      }
    }
    postProcess() {
      $$2('a[data-sceditor-command="source"]')[0].click();
      $$2(this.siteInfo.description.selector).val(this.info.description);
    }
  }
  registry$1.register(new PTSBAO());
  class SpeedApp extends BaseFiller {
    constructor() {
      super(...arguments);
      this.priority = 10;
    }
    canHandle(siteName) {
      return siteName === "SpeedApp";
    }
    processDescription() {
      let { description } = this.info;
      description = description.replace(/\[url.*\[\/url\]/g, "").replace(/\[img.*\[\/img\]/g, "").replace(/\[\/?(i|b|center|quote|size|color)\]/g, "").replace(/\[(size|color)=#?[a-zA-Z0-9]*\]/g, "").replace(/\n\n*/g, "\n");
      this.info.description = description;
      super.processDescription();
    }
    postProcess() {
      let { imdbUrl = "" } = this.info;
      if (!/.+\/$/.test(imdbUrl) && /tt\d+/.test(imdbUrl)) {
        imdbUrl += "/";
      }
      $$2(this.siteInfo.imdb.selector).val(imdbUrl);
    }
  }
  registry$1.register(new SpeedApp());
  class SSD extends BaseFiller {
    constructor() {
      super(...arguments);
      this.priority = 10;
    }
    canHandle(siteName) {
      return siteName === "SSD";
    }
    processTorrentTitle() {
      super.processTorrentTitle();
      const { title } = this.info;
      this.info.title = title.replace(/\s/gi, ".");
    }
    postProcess() {
      const { category, title, doubanUrl, imdbUrl, screenshots, subtitle } = this.info;
      if (category === "tvPack" || title.match(/Trilogy|Collection/i) || subtitle && subtitle.match(/合集/)) {
        $$2('input[name="pack"]').attr("checked", "true");
      }
      $$2(this.siteInfo.imdb.selector).val(doubanUrl || imdbUrl);
      $$2(this.siteInfo.screenshots.selector).val(screenshots.join("\n"));
    }
  }
  registry$1.register(new SSD());
  class TTG extends BaseFiller {
    constructor() {
      super(...arguments);
      this.priority = 10;
    }
    canHandle(siteName) {
      return siteName === "TTG";
    }
    processDescription() {
      super.processDescription();
      const { description } = this.info;
      this.info.description = replaceAlignTagsToQuote(description);
    }
    postProcess() {
      var _a2, _b;
      const { doubanUrl } = this.info;
      if (doubanUrl) {
        const doubanId = (_b = (_a2 = doubanUrl.match(/\/(\d+)/)) == null ? void 0 : _a2[1]) != null ? _b : "";
        $$2(this.siteInfo.douban.selector).val(doubanId);
      }
    }
  }
  registry$1.register(new TTG());
  class UHDBits extends BaseFiller {
    constructor() {
      super(...arguments);
      this.priority = 10;
    }
    canHandle(siteName) {
      return siteName === "UHDBits";
    }
    postProcess() {
      const { title } = this.info;
      $$2(this.siteInfo.imdb.selector).val(this.imdbId);
      if (title.match(/web-?rip/i)) {
        $$2(this.siteInfo.videoType.selector).val("WEBRip");
      }
      const teamName = getTeamName(title);
      $$2("#team").val(teamName === "other" ? "Unknown" : teamName);
      $$2("#imdb_button").trigger("click");
    }
  }
  registry$1.register(new UHDBits());
  class UNIT3D extends BaseFiller {
    constructor() {
      super(...arguments);
      this.priority = 5;
    }
    canHandle(siteName, siteType) {
      return siteType.includes("UNIT3D");
    }
    processDescription() {
      super.processDescription();
      let { description, sourceSite, screenshots } = this.info;
      if (sourceSite === "PTP") {
        description = buildPTPDescription(this.info);
      }
      if (screenshots.length > 0) {
        screenshots.forEach((img) => {
          const regStr = new RegExp(`\\[img\\](${img})\\[\\/img\\](
*)?`);
          if (description.match(regStr)) {
            description = description.replace(regStr, (p1, p2) => {
              return `[url=${p2}][img=350x350]${p2}[/img][/url]`;
            });
          }
        });
      }
      if (description.match(/mobile\.webp\[\/img/gi)) {
        description = description.replace(/\[img\]/g, "[img=350x350]");
      }
      description = description.replace(
        /\[align(=(.+?))\]((.|\n)+?)\[\/align\]/g,
        "[$2]$3[/$2]"
      );
      description = description.replace(
        /\[(\/)?hide(?:=(.+?))?\]/g,
        (_2, p1, p2) => {
          const slash = p1 || "";
          return p2 ? `${p2}: [${slash}spoiler]` : `[${slash}spoiler]`;
        }
      );
      this.info.description = description;
    }
    processTorrentTitle() {
      super.processTorrentTitle();
      const { title, source } = this.info;
      const isWebSource = !!source.match(/web/gi);
      const fixedTitle = fixTorrentTitle(title, isWebSource);
      this.info.title = fixedTitle;
    }
  }
  registry$1.register(new UNIT3D());
  class NexusPHP extends BaseFiller {
    constructor() {
      super(...arguments);
      this.priority = 5;
    }
    canHandle(siteName, siteType) {
      return siteType === "NexusPHP";
    }
    processDescription() {
      super.processDescription();
      const { description } = this.info;
      this.info.description = replaceAlignTagsToQuote(description);
    }
    processTorrentTitle() {
      super.processTorrentTitle();
      const { title, source } = this.info;
      const isWebSource = !!source.match(/web/gi);
      const fixedTitle = fixTorrentTitle(title, isWebSource);
      this.info.title = fixedTitle;
    }
  }
  registry$1.register(new NexusPHP());
  class BeyondHD extends BaseFiller {
    constructor() {
      super(...arguments);
      this.priority = 10;
      this.bhdSiteInfo = PT_SITE.BeyondHD;
    }
    canHandle(siteName) {
      return siteName === "BeyondHD";
    }
    processTorrentTitle() {
      let title = this.info.title;
      if (this.info.videoType === "dvd") {
        title = this.buildDVDTitle(this.info);
      }
      this.info.title = title;
    }
    fillCategory() {
      const { category, videoType, size } = this.info;
      const isBluray = videoType.match(/bluray/i);
      this.info.category = videoType;
      this.info.videoType = category;
      if (isBluray || videoType === "dvd") {
        let bdType = getBDTypeBasedOnSize(size);
        if (videoType === "uhdbluray" && bdType === "BD50") {
          bdType = "UHD50";
        }
        this.info.category = bdType || "";
      }
      super.fillCategory();
    }
    processDescription() {
      let { description, sourceSite, originalDescription, screenshots } = this.info;
      if (sourceSite === "PTP") {
        description = buildPTPDescription(this.info);
      } else if (sourceSite.match(/BeyondHD|UHDBits/)) {
        description = originalDescription || "";
      } else {
        description = this.buildDescription();
      }
      if (screenshots.length > 0) {
        screenshots.forEach((img) => {
          const regStr = new RegExp(`\\[img\\](${img})\\[\\/img\\](
*)?`);
          if (description.match(regStr)) {
            description = description.replace(regStr, (_2, p2) => {
              return `[url=${p2}][img=350x350]${p2}[/img][/url]
`;
            });
          }
        });
      }
      this.info.description = description;
    }
    buildDescription() {
      var _a2;
      let { sourceSiteType, description, mediaInfos, comparisons, screenshots } = this.info;
      if (this.isChineseTacker(sourceSiteType)) {
        description = filterNexusDescription(description, screenshots);
      }
      description = description.replace(`[quote]${(_a2 = mediaInfos == null ? void 0 : mediaInfos[0]) != null ? _a2 : ""}[/quote]`, "").replace(/\[url.*\[\/url\]/g, "").replace(/\[img.*\[\/img\]/g, "");
      if (comparisons && comparisons.length > 0) {
        for (const comparison of comparisons) {
          description += `
${comparison.reason}[comparison=${comparison.title}]
${comparison.imgs.join("\n")}
[/comparison]

`;
        }
      }
      if (screenshots.length > 0) {
        description += `${screenshots.map((v2) => `[img]${v2}[/img]`).join("\n")}

`;
      }
      return description.trim();
    }
    fill(info) {
      this.info = info;
      this.fillTorrentTitle();
      this.disableTorrentChange();
      this.fillIMDb();
      this.fillTMDBId();
      this.selectTag();
      this.fillDescription();
      this.fillMediaInfo(info.description);
      this.fillCategory();
      this.fillRemainingInfo();
      this.fillTorrentFile();
    }
    buildDVDTitle(info) {
      var _a2, _b;
      const { movieName, movieAkaName, year, mediaInfos, size, audioCodec } = info;
      const mediaInfo = (_a2 = mediaInfos == null ? void 0 : mediaInfos[0]) != null ? _a2 : "";
      const scanType = mediaInfo.includes("NTSC") ? "NTSC" : "PAL";
      const dvdType = getBDTypeBasedOnSize(size);
      const audioChannelNumber = ((_b = mediaInfo.match(/Channel\(s\)\s+:\s+(\d)/)) == null ? void 0 : _b[1]) || "2";
      const audio = audioCodec === "ac3" ? "dd" : audioCodec;
      const audioName = `${audio == null ? void 0 : audio.toUpperCase()}${audioChannelNumber === "6" ? "5.1" : `${audioChannelNumber}.0`}`;
      const akaName = movieAkaName ? ` AKA ${movieAkaName} ` : " ";
      return `${movieName}${akaName}${year} ${scanType} ${dvdType} ${audioName}`;
    }
    fillTMDBId() {
      const imdbId = getIdByIMDbUrl(this.info.imdbUrl || "");
      getTMDBDataByIMDBId(imdbId).then((data) => {
        $$2(this.siteInfo.tmdb.selector).val(data.id);
      });
    }
    selectTag() {
      const editionTags = Object.keys(this.info.tags).map(
        (tag) => this.info.tags[tag] && this.bhdSiteInfo.targetInfo.editionTags[tag]
      ).filter(Boolean);
      const editionOption = Array.from($$2('select[name="edition"] option')).map(
        (opt) => $$2(opt).attr("value")
      );
      if (editionTags.length > 0) {
        for (const tag of editionTags) {
          setTimeout(() => {
            var _a2, _b;
            (_b = (_a2 = $$2(`.bhd-tag #${tag}`)) == null ? void 0 : _a2[0]) == null ? void 0 : _b.dispatchEvent(new Event("click"));
          }, 0);
          if (tag && editionOption.includes(tag)) {
            $$2('select[name="edition"]').val(tag);
          }
        }
      }
    }
  }
  registry$1.register(new BeyondHD());
  class SC extends BaseFiller {
    constructor() {
      super(...arguments);
      this.priority = 10;
    }
    canHandle(siteName) {
      return siteName === "SC";
    }
    async fill(info) {
      this.info = info;
      const { imdbUrl = "" } = this.info;
      const imdbId = getIdByIMDbUrl(imdbUrl);
      $$2("#catalogue_number").val(imdbId);
      $$2("#imdb_autofill").trigger("click");
      this.fillMedia();
      $$2(".modesw").trigger("click");
      $$2("#release_desc").val(this.buildDescription());
      await this.fillIMDbInfo(imdbUrl);
      this.fillTorrentFile();
    }
    buildDescription() {
      const { screenshots, mediaInfos } = this.info;
      const parts = [];
      if (screenshots.length > 0) {
        const screenshotSection = screenshots.slice(0, 3).map((img) => `[img]${img}[/img]`).join("");
        parts.push(screenshotSection);
      }
      if (mediaInfos.length > 0) {
        const mediaInfoSection = mediaInfos.map((mediaInfo) => `[hide=MediaInfo]${mediaInfo}[/hide]`).join("\n\n");
        parts.push(mediaInfoSection);
      }
      return parts.join("\n\n");
    }
    fillMedia() {
      const { videoType, resolution } = this.info;
      let mediaValue;
      if (videoType.match(/bluray/i)) {
        mediaValue = "BDMV";
      } else if (videoType === "DVD") {
        mediaValue = "DVD-R";
      } else if (parseInt(resolution, 10) < 720) {
        mediaValue = "SD";
      } else {
        mediaValue = resolution;
      }
      $$2("#media").val(mediaValue);
    }
    async fillIMDbInfo(imdbUrl) {
      var _a2, _b, _c;
      if (imdbUrl) {
        try {
          const imdbData = await getIMDBData(imdbUrl);
          if (!imdbData) {
            return;
          }
          if ((_a2 = imdbData == null ? void 0 : imdbData.details) == null ? void 0 : _a2.country) {
            $$2("#country").val(imdbData.details.country);
          }
          const akaName = imdbData && ((_b = imdbData == null ? void 0 : imdbData.details) == null ? void 0 : _b["Also known as"]);
          const originalName = (_c = imdbData == null ? void 0 : imdbData.name) != null ? _c : "";
          if (akaName && akaName !== originalName) {
            $$2("#alternate_title").val(imdbData.details["Also known as"]);
            $$2("#title").val(originalName);
          }
          await this.uploadPoster(imdbData.poster);
        } catch (error) {
          console.error("Error filling IMDB data:", error);
        }
      }
    }
    async uploadPoster(posterUrl) {
      var _a2;
      if (!posterUrl) return;
      try {
        let uploadedUrl;
        const ptpImgApiKey = GM_getValue("easy-upload.ptp-img-api-key");
        if (ptpImgApiKey) {
          const uploadResult = await (await uploadToPtpImg)([posterUrl]);
          uploadedUrl = Array.isArray(uploadResult) && uploadResult.length > 0 ? uploadResult[0] : void 0;
        } else {
          const data = await (await transferImgToCheveretoSite)([posterUrl], "https://gifyu.com/json");
          uploadedUrl = (_a2 = data[0]) == null ? void 0 : _a2.original;
        }
        if (uploadedUrl) {
          $$2("#image").val(uploadedUrl);
        }
      } catch (error) {
        console.error("Failed to upload poster:", error);
      }
    }
  }
  registry$1.register(new SC());
  class TJUPT extends BaseFiller {
    constructor() {
      super(...arguments);
      this.priority = 10;
      this.isCustomSite = true;
    }
    canHandle(siteName) {
      return siteName === "TJUPT";
    }
    fill(info) {
      this.info = info;
      this.fillBasicAttributes();
      this.fillCategory();
      this.fillIMDb();
      this.processDescription();
      this.fillDescription();
      this.fillTorrentFile();
      const observer = new MutationObserver(() => {
        if ($$2("#ename")[0] && $$2("#cname")[0]) {
          this.fillSiteSpecificInfo();
          observer.disconnect();
        }
      });
      const config = { childList: true, subtree: true };
      observer.observe(document.body, config);
    }
    fillSiteSpecificInfo() {
      var _a2, _b;
      if (!this.info) return;
      const { title, description, doubanInfo, category, tags: tags2 } = this.info;
      $$2("#ename").val(title);
      const fullDescription = description + doubanInfo;
      let area = this.extractPattern(
        fullDescription,
        /(产\s+地|国\s+家)\s+(.+)/,
        2
      );
      area = area.replace(/\[\/?.+?\]/g, "");
      const originalName = this.extractPattern(
        fullDescription,
        /(片\s+名)\s+(.+)?/,
        2
      );
      const translateName = ((_b = (_a2 = this.extractPattern(fullDescription, /(译\s+名)\s+(.+)/, 2)) == null ? void 0 : _a2.split(
        "/"
      )) == null ? void 0 : _b[0]) || "";
      const language = this.extractPattern(
        fullDescription,
        /(语\s+言)\s+(.+)/,
        2
      );
      this.fillAreaInfo(area, category);
      this.fillLanguageInfo(language);
      let chineseName = originalName;
      if (!originalName.match(/[\u4e00-\u9fa5]+/)) {
        chineseName = translateName.match(/[\u4e00-\u9fa5]+/) ? translateName : "";
      }
      $$2("#cname").val(chineseName);
      if (tags2.chinese_subtitle && !tags2.chinese_audio) {
        $$2('input[name="chinese"]').attr("checked", "true");
      }
    }
    extractPattern(text2, pattern, groupIndex) {
      var _a2;
      return ((_a2 = text2.match(pattern)) == null ? void 0 : _a2[groupIndex]) || "";
    }
    /**
     * 填充区域信息
     * @param area 区域信息
     * @param category 种子类别
     */
    fillAreaInfo(area, category) {
      if (!area || !this.info) return;
      const areaString = area.replace(/,/g, "/").replace(/\s|中国/g, "");
      if (category === "movie") {
        $$2("#district").val(areaString);
      } else if (category == null ? void 0 : category.match(/tv/)) {
        const areaToSelectorMap = {
          大陆: "#specificcat1",
          "台|港": "#specificcat2",
          美国: "#specificcat3",
          日本: "#specificcat4",
          韩国: "#specificcat5",
          英国: "#specificcat6",
          泰剧: "#specificcat7"
        };
        let selector = "";
        for (const [key, value] of Object.entries(areaToSelectorMap)) {
          if (area.match(new RegExp(key))) {
            selector = value;
            break;
          }
        }
        if (selector) {
          $$2(selector).attr("checked", "true");
          this.callGetcheckboxvalue("specificcat");
        } else {
          $$2("#specificcat").val(areaString);
        }
      } else if (category == null ? void 0 : category.match(/variety/)) {
        const districtMap = {
          CN: "#district1",
          HK: "#district2",
          TW: "#district2",
          JP: "#district4",
          KR: "#district4",
          US: "#district3",
          EU: "#district3",
          OT: "#district5"
        };
        const areaKey = this.info.area;
        if (districtMap[areaKey]) {
          $$2(districtMap[areaKey]).attr("checked", "true");
          this.callGetcheckboxvalue("district");
        }
      }
    }
    fillLanguageInfo(language) {
      if (!$$2("#language").length || !language) return;
      let selector = "";
      if (language.match(/汉语/)) {
        selector = "#language1";
      } else if (language.match(/粤/)) {
        selector = "#language2";
      } else if (language.match(/英语/)) {
        selector = "#language3";
      } else if (language.match(/日语/)) {
        selector = "#language4";
      } else if (language.match(/韩语/)) {
        selector = "#language5";
      }
      if (selector) {
        $$2(selector).attr("checked", "true");
        this.callGetcheckboxvalue("language");
      }
    }
    callGetcheckboxvalue(name) {
      if (typeof window.getcheckboxvalue === "function") {
        window.getcheckboxvalue(name);
      }
    }
    processDescription() {
      let { description, mediaInfos } = this.info;
      mediaInfos.forEach((info) => {
        description = description.replace(
          `[quote]${info}[/quote]`,
          `[mediainfo]${info}[/mediainfo]`
        );
      });
      return description;
    }
  }
  registry$1.register(new TJUPT());
  class RED extends BaseFiller {
    constructor() {
      super(...arguments);
      this.priority = 10;
      this.isCustomSite = true;
    }
    canHandle(siteName) {
      return siteName === "RED";
    }
    async fill(info) {
      this.info = info;
      await this.fillMusicInfo();
    }
    async fillMusicInfo() {
      if (!this.info || !this.info.musicJson) {
        return;
      }
      if (document.forms.upload_table) {
        document.forms.upload_table.reset = () => {
        };
      }
      const { musicJson } = this.info;
      const {
        name,
        year,
        musicInfo,
        bbBody,
        tags: tags2,
        releaseType,
        categoryId,
        wikiImage
      } = musicJson.group;
      const groupId = getLocationSearchValueByKey("groupid");
      if (!groupId) {
        await this.searchAndRedirectToGroup(name, year);
        $$2("#categories").val(categoryId - 1);
        $$2("#title").val(name);
        $$2("#year").val(year);
        $$2("#releasetype").val(releaseType);
        $$2("#tags").val(tags2.join(", "));
        $$2("#album_desc").val(bbBody);
        $$2("#image").val(wikiImage);
        this.fillArtistsForm(musicInfo);
      }
      this.fillReleaseInfo(musicJson.torrent);
      this.fillTorrentFile();
    }
    async searchAndRedirectToGroup(name, year) {
      var _a2;
      const url = `/ajax.php?action=browse&searchstr=${encodeURIComponent(name)} ${year}`;
      try {
        const searchResult = await GMFetch(url, {
          responseType: "json"
        });
        if (searchResult.status === "success" && searchResult.response.results.length > 0) {
          const groupId = searchResult.response.results[0].groupId;
          const timestampMatchArray = location.hash && location.hash.match(/(^|#)timestamp=([^#]*)(#|$)/);
          const timestamp2 = (_a2 = timestampMatchArray == null ? void 0 : timestampMatchArray[2]) != null ? _a2 : "";
          location.href = `${CURRENT_SITE_INFO.url}${CURRENT_SITE_INFO.uploadPath}?groupid=${groupId}#timestamp=${timestamp2}`;
          return true;
        }
      } catch (error) {
        console.error("Error searching for group:", error);
      }
      return false;
    }
    fillArtistsForm(musicInfo) {
      const artistTypeMap = {
        artists: "1",
        with: "2",
        composers: "4",
        conductor: "5",
        dj: "6",
        producer: "7",
        remixedBy: "3"
      };
      const artists = [];
      Object.keys(musicInfo).forEach((key) => {
        const typeKey = key;
        const values = musicInfo[typeKey].map((value) => __spreadProps(__spreadValues({}, value), {
          type: artistTypeMap[typeKey]
        }));
        artists.push(...values);
      });
      for (let i = 1; i < artists.length; i++) {
        window.AddArtistField();
      }
      artists.forEach((artist, index) => {
        const selector = index > 0 ? `#artist_${index}` : "#artist";
        $$2(selector).val(artist.name).next().val(artist.type || "");
      });
    }
    fillReleaseInfo(info) {
      var _a2;
      const {
        remasterYear,
        remasterRecordLabel,
        remasterCatalogueNumber,
        format: format2,
        encoding,
        media,
        description,
        scene,
        remasterTitle
      } = info;
      $$2("#remaster_record_label").val(remasterRecordLabel);
      $$2("#remaster_catalogue_number").val(remasterCatalogueNumber);
      $$2("#format").val(format2);
      $$2("#bitrate").val(encoding);
      $$2("#media").val(media);
      if (media === "CD" && format2 === "FLAC") {
        (_a2 = document.querySelector("#format")) == null ? void 0 : _a2.dispatchEvent(new Event("change"));
      }
      $$2("#remaster_year").val(remasterYear);
      $$2("#release_desc").val(description);
      if (scene) {
        $$2("#scene").attr("checked", "true");
      }
      if (remasterTitle) {
        $$2("#remaster_title").val(remasterTitle);
      }
    }
  }
  registry$1.register(new RED());
  class KG extends BaseFiller {
    constructor() {
      super(...arguments);
      this.priority = 10;
    }
    canHandle(siteName) {
      return siteName === "KG";
    }
    async fill(info) {
      this.info = info;
      await this.processUpload();
    }
    async processUpload() {
      var _a2;
      if (!this.info) return;
      const { imdbUrl, mediaInfos, resolution, source, videoType } = this.info;
      const mediaInfo = (_a2 = mediaInfos == null ? void 0 : mediaInfos[0]) != null ? _a2 : "";
      if (!imdbUrl) return;
      $$2('input[type="submit"][value="next >>"]').hide().after("<p>loading...</p>");
      $$2('input[name="title"]').val(imdbUrl);
      await this.fetchAndFillIMDbData(imdbUrl);
      this.fillSourceAndResolution(source, resolution, videoType);
      this.fillSubtitleInfo(mediaInfo, videoType);
      if (videoType === "dvd") {
        $$2('input[name="dvdr"]').attr("checked", "true");
        const dvdSpecs = this.buildDvdSpecs();
        $$2("#ripspecs").val(dvdSpecs);
      } else {
        $$2("#ripspecs").val(mediaInfo);
      }
    }
    async fetchAndFillIMDbData(imdbUrl) {
      try {
        const formData = new FormData();
        formData.append("upstep", "2");
        formData.append("type", "1");
        formData.append("title", imdbUrl);
        const doc = await GMFetch(`${PT_SITE.KG.url}/upload.php`, {
          method: "POST",
          data: formData
        });
        const uploadPage = new DOMParser().parseFromString(doc, "text/html");
        $$2("#upside+div").html($$2("#upside+div", uploadPage).html());
        await this.fillIMDbDetails(imdbUrl);
      } catch (error) {
        console.error("Error fetching IMDB data:", error);
      }
    }
    async fillIMDbDetails(imdbUrl) {
      if (!this.info) return;
      const imdbData = await getIMDBData(imdbUrl);
      if (!imdbData) return;
      const siteInfo = PT_SITE.KG;
      const { screenshots, poster: infoPoster } = this.info;
      const { country, Languages: languages } = imdbData.details;
      $$2('input[name="lang"]').val(languages);
      let { description, genre, poster = "" } = imdbData;
      const genreMap = siteInfo.genres.map;
      const countryMap = siteInfo.country.map;
      let countryValue = "";
      if (country) {
        countryValue = country.split(",")[0];
        if (countryValue === "United States") {
          countryValue = "USA";
        } else if (countryValue === "United Kingdom") {
          countryValue = "UK";
        }
      }
      if (!poster) {
        poster = infoPoster || "";
      }
      $$2('select[name="country_id"]').val(
        countryMap[countryValue]
      );
      const descriptionBBCode = `[img]${poster}[/img]
    
Synopsis:
[quote]${description}[/quote]
    

${screenshots.map((img) => `[img]${encodeURI(img)}[/img]`).join("")}`;
      $$2("#bbcodetextarea").html(descriptionBBCode);
      const [mainGenre, otherGenre = ""] = genre;
      $$2('select[name="genre_main_id"]').val(
        genreMap[mainGenre]
      );
      $$2('select[name="subgenre"]').val(
        genreMap[otherGenre]
      );
    }
    fillSourceAndResolution(source, resolution, videoType) {
      if (!source || !resolution || !videoType) return;
      const siteInfo = PT_SITE.KG;
      $$2(siteInfo.source.selector).val(
        siteInfo.source.map[source]
      );
      if (!videoType.match("bluray")) {
        $$2(siteInfo.resolution.selector).val(
          siteInfo.resolution.map[resolution]
        );
      } else {
        $$2(siteInfo.resolution.selector).val("3");
      }
    }
    fillSubtitleInfo(mediaInfo, videoType) {
      if (!mediaInfo || !videoType) return;
      const isBluray = videoType.match(/bluray/i);
      const parsedMedia = parseMedia(mediaInfo, !!isBluray);
      if (!parsedMedia) return;
      const { subtitleTracks = [] } = parsedMedia;
      if (subtitleTracks.length) {
        const subtitleNames = subtitleTracks.map((track) => track.language);
        $$2('input[name="subs"]').val(subtitleNames.join(","));
      }
    }
    buildDvdSpecs() {
      var _a2, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k;
      if (!this.info) return "";
      const { mediaInfos, size, audioCodec } = this.info;
      const mediaInfo = (_a2 = mediaInfos == null ? void 0 : mediaInfos[0]) != null ? _a2 : "";
      const scanType = mediaInfo.includes("NTSC") ? "NTSC" : "PAL";
      const dvdType = getBDTypeBasedOnSize(size);
      const audioChannelNumber = ((_b = mediaInfo.match(/Channel\(s\)\s+:\s+(\d)/)) == null ? void 0 : _b[1]) || "2";
      const audioName = `${audioCodec == null ? void 0 : audioCodec.toUpperCase()} ${audioChannelNumber === "6" ? "5.1" : `${audioChannelNumber}.0`}`;
      const IFOMediaInfo = (_d = (_c = this.info.mediaInfos) == null ? void 0 : _c.find((info) => info.includes(".IFO"))) != null ? _d : "";
      const runtime = (_g = (_f = (_e = IFOMediaInfo.match(/Duration\s*?:([^\n]+)/)) == null ? void 0 : _e[1]) == null ? void 0 : _f.replace(/\s/g, "")) != null ? _g : "";
      const hour = (_i = (_h = runtime.match(/(\d)+h/)) == null ? void 0 : _h[1]) != null ? _i : "00";
      const minute = (_k = (_j = runtime.match(/(\d+)(mn|min)/)) == null ? void 0 : _j[1]) != null ? _k : "";
      return `DVD Label:
DVD Format: ${dvdType} ${scanType}
DVD Audio: ${audioName}
Program(s): Unknown
Menus: Untouched
Video: Untouched
Audio: Untouched
DVD extras: Untouched
Extras contain: 
DVD runtime(s): ${+hour < 10 ? `0${hour}` : hour}:${minute}`;
    }
  }
  registry$1.register(new KG());
  class PTP extends BaseFiller {
    constructor() {
      super(...arguments);
      this.priority = 10;
    }
    canHandle(siteName) {
      return siteName === "PTP";
    }
    fill(info) {
      this.info = info;
      if (!this.info) return;
      const groupId = getLocationSearchValueByKey("groupid");
      if (!groupId) {
        this.fillIMDbAndTriggerAutoFill();
      }
      this.updateResolutionAndCodec();
      this.fillBasicInfo();
      this.fillDescription();
      this.handleEditionInfo();
      this.fillSubtitleInfo();
      this.fillTorrentFile();
    }
    fillIMDbAndTriggerAutoFill() {
      if (!this.info) return;
      const { imdbUrl } = this.info;
      const currentSiteInfo = PT_SITE.PTP;
      $$2(currentSiteInfo.imdb.selector).val(imdbUrl || 0);
      AutoFill();
    }
    updateResolutionAndCodec() {
      if (!this.info) return;
      const { title, videoType, resolution, videoCodec, size } = this.info;
      this.info.resolution = this.getResolution(resolution, videoType, title);
      this.info.videoCodec = this.getVideoCodec(
        videoCodec || "",
        videoType,
        size
      );
    }
    fillBasicInfo() {
      if (!this.info) return;
      const currentSiteInfo = PT_SITE.PTP;
      const keyArray = [
        "category",
        "source",
        "videoCodec",
        "resolution"
      ];
      keyArray.forEach((key) => {
        const { selector = "", map: map2 } = currentSiteInfo[key];
        if (map2) {
          const mapValue = map2[this.info[key]];
          $$2(selector).val(mapValue);
        } else {
          $$2(selector).val(this.info[key]);
        }
      });
    }
    fillDescription() {
      if (!this.info) return;
      const currentSiteInfo = PT_SITE.PTP;
      const { sourceSite, originalDescription } = this.info;
      if (sourceSite.match(/PTP/i)) {
        $$2(currentSiteInfo.description.selector).val(originalDescription || "");
      } else {
        const description = this.getDescription();
        $$2(currentSiteInfo.description.selector).val(description);
      }
    }
    handleEditionInfo() {
      if (!this.info) return;
      const { videoType, tags: tags2 } = this.info;
      const editionInfo = this.getEditionInfo(videoType, tags2);
      if (editionInfo.length > 0) {
        $$2("#remaster").attr("checked", "true");
        window.Remaster();
        editionInfo.forEach((edition) => {
          const selector = $$2("#remaster_tags a").filter(function() {
            return new RegExp(edition).test($$2(this).text());
          });
          if (selector.length > 0) {
            const event = new Event("click");
            selector[0].dispatchEvent(event);
          }
        });
      }
    }
    fillSubtitleInfo() {
      if (!this.info || !this.info.mediaInfos || this.info.mediaInfos.length === 0)
        return;
      const parsedMedia = parseMedia(this.info.mediaInfos[0]);
      if (!parsedMedia) return;
      const { subtitleTracks = [] } = parsedMedia;
      if (subtitleTracks && subtitleTracks.length > 0) {
        subtitleTracks.forEach((subtitle) => {
          const subtitleSelector = $$2(".languageselector li").filter(function() {
            return new RegExp(subtitle.language).test($$2(this).text());
          });
          if (subtitle.language !== "English" && subtitleSelector.length > 0) {
            subtitleSelector.find("input").attr("checked", "true");
          }
        });
      }
    }
    getEditionInfo(videoType, tags2) {
      const editionInfo = [];
      if (videoType === "remux") {
        editionInfo.push("Remux");
      }
      Object.keys(tags2).forEach((tag) => {
        if (tags2[tag]) {
          const tagName = PT_SITE.PTP.targetInfo.editionTags[tag];
          if (tagName) {
            editionInfo.push(tagName);
          }
        }
      });
      return editionInfo;
    }
    getVideoCodec(videoCodec, videoType, size) {
      if (!videoType || !size) return videoCodec;
      if (videoType === "bluray") {
        return getBDTypeBasedOnSize(size);
      } else if (videoType === "dvd") {
        const GBSize = size / 1e9;
        return GBSize < 5 ? "DVD5" : "DVD9";
      }
      return videoCodec;
    }
    getResolution(resolution, videoType, title) {
      if (!videoType || !title) return resolution;
      if (videoType === "DVD" && title.match(/NTSC/i)) {
        return "NTSC";
      } else if (videoType === "DVD" && title.match(/PAL/i)) {
        return "PAL";
      }
      return resolution;
    }
    getDescription() {
      if (!this.info) return "";
      const { mediaInfos, comparisons, screenshots } = this.info;
      let filterDescription = "";
      if (mediaInfos.length > 0) {
        mediaInfos.forEach((mediaInfo) => {
          mediaInfo = mediaInfo.replace(
            /[\u00A0\u1680​\u180e\u2000-\u2009\u200a​\u200b​\u202f\u205f​\u3000]/g,
            ""
          );
          filterDescription += `[mediainfo]${mediaInfo}[/mediainfo]
`;
        });
      }
      if (comparisons && comparisons.length > 0) {
        for (const comparison of comparisons) {
          filterDescription += `
${comparison.reason}[comparison=${comparison.title}]
${comparison.imgs.join("\n")}
[/comparison]

`;
        }
      }
      const screenshotsSection = screenshots.map((item) => `[img]${item}[/img]`).join("\n");
      return `${filterDescription}
${screenshotsSection}`;
    }
  }
  registry$1.register(new PTP());
  class MTeam extends BaseFiller {
    constructor() {
      super(...arguments);
      this.priority = 10;
    }
    canHandle(siteName) {
      return siteName === "MTeam";
    }
    fill(info) {
      this.info = info;
      this.setupMutationObserver();
    }
    setupMutationObserver() {
      const targetNode = document.getElementById("root");
      if (!targetNode) return;
      const config = { childList: true, subtree: true };
      const observer = new MutationObserver((mutationsList, observer2) => {
        for (const mutation of mutationsList) {
          if (mutation.type === "childList") {
            const targetElement = document.querySelector("#name");
            const editor = document.querySelector(".editor-input");
            if (targetElement && editor) {
              observer2.disconnect();
              this.fillMTeamInfo();
              break;
            }
          }
        }
      });
      observer.observe(targetNode, config);
    }
    fillMTeamInfo() {
      var _a2;
      if (!this.info) return;
      const currentSiteInfo = PT_SITE.MTeam;
      const {
        title,
        subtitle,
        audioCodec,
        doubanUrl,
        imdbUrl,
        mediaInfos,
        tags: tags2,
        source
      } = this.info;
      const mediaInfo = (_a2 = mediaInfos == null ? void 0 : mediaInfos[0]) != null ? _a2 : "";
      this.setInputValue(currentSiteInfo.name.selector, title);
      this.setInputValue(currentSiteInfo.subtitle.selector, subtitle || "");
      this.setInputValue(currentSiteInfo.douban.selector, doubanUrl || "");
      this.setInputValue(currentSiteInfo.imdb.selector, imdbUrl || "");
      this.setInputValue(currentSiteInfo.mediainfo.selector, mediaInfo);
      this.setSelectValue(currentSiteInfo.source.selector, source || "");
      this.setSelectValue(
        currentSiteInfo.audioCodec.selector,
        currentSiteInfo.audioCodec.map[audioCodec]
      );
      this.info.description = this.info.description.replace(mediaInfo.trim(), "");
      this.processDescription();
      this.fillMTDescription(this.info.description);
      this.fillCategory();
      this.fillTags(tags2, currentSiteInfo.tags);
      this.fillTorrentFile();
    }
    fillTags(tags2, siteTagsMap) {
      let timeout = 0;
      Object.keys(tags2).forEach((key) => {
        const siteTagSelector = siteTagsMap[key];
        if (tags2[key] && siteTagSelector) {
          setTimeout(() => {
            this.setInputValue(siteTagSelector, "", true);
          }, timeout);
          timeout += 100;
        }
      });
    }
    setSelectValue(selector, value) {
      const select = document.querySelector(selector);
      if (select) {
        const lastValue = select.value;
        select.value = value;
        const tracker = select._valueTracker;
        if (tracker) {
          tracker.setValue(lastValue);
        }
        const event = new Event("change", { bubbles: true });
        select.dispatchEvent(event);
        setTimeout(() => {
          Array.from(
            document.querySelectorAll(
              ".ant-select-item-option-active .ant-select-item-option-content"
            )
          ).forEach((el) => {
            el.dispatchEvent(new Event("click", { bubbles: true }));
          });
        }, 1e3);
      }
    }
    setInputValue(selector, value, isCheckbox = false) {
      const input = document.querySelector(selector);
      if (input) {
        const lastValue = input.value;
        input.value = value;
        const tracker = input._valueTracker;
        if (tracker) {
          tracker.setValue(lastValue);
        }
        const event = new Event(isCheckbox ? "click" : "input", {
          bubbles: true
        });
        input.dispatchEvent(event);
      }
    }
    fillMTDescription(description) {
      var _a2;
      const editor = (_a2 = document.querySelector(".editor-input")) == null ? void 0 : _a2.__lexicalEditor;
      if (!editor) return;
      const descriptionArray = description.split("\n").map((line) => ({
        type: "paragraph",
        children: [{ type: "text", text: line }]
      }));
      const content = JSON.stringify({
        root: {
          children: descriptionArray,
          type: "root"
        }
      });
      const editorState = editor.parseEditorState(content);
      editor.update(() => {
        editor.setEditorState(editorState);
      });
    }
  }
  registry$1.register(new MTeam());
  var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
  function getDefaultExportFromCjs(x2) {
    return x2 && x2.__esModule && Object.prototype.hasOwnProperty.call(x2, "default") ? x2["default"] : x2;
  }
  function getAugmentedNamespace(n) {
    if (n.__esModule) return n;
    var f2 = n.default;
    if (typeof f2 == "function") {
      var a2 = function a3() {
        if (this instanceof a3) {
          return Reflect.construct(f2, arguments, this.constructor);
        }
        return f2.apply(this, arguments);
      };
      a2.prototype = f2.prototype;
    } else a2 = {};
    Object.defineProperty(a2, "__esModule", { value: true });
    Object.keys(n).forEach(function(k2) {
      var d2 = Object.getOwnPropertyDescriptor(n, k2);
      Object.defineProperty(a2, k2, d2.get ? d2 : {
        enumerable: true,
        get: function() {
          return n[k2];
        }
      });
    });
    return a2;
  }
  var buffer = {};
  var base64Js = {};
  base64Js.byteLength = byteLength;
  base64Js.toByteArray = toByteArray;
  base64Js.fromByteArray = fromByteArray;
  var lookup$1 = [];
  var revLookup = [];
  var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
  var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  for (var i$2 = 0, len = code.length; i$2 < len; ++i$2) {
    lookup$1[i$2] = code[i$2];
    revLookup[code.charCodeAt(i$2)] = i$2;
  }
  revLookup["-".charCodeAt(0)] = 62;
  revLookup["_".charCodeAt(0)] = 63;
  function getLens(b64) {
    var len = b64.length;
    if (len % 4 > 0) {
      throw new Error("Invalid string. Length must be a multiple of 4");
    }
    var validLen = b64.indexOf("=");
    if (validLen === -1) validLen = len;
    var placeHoldersLen = validLen === len ? 0 : 4 - validLen % 4;
    return [validLen, placeHoldersLen];
  }
  function byteLength(b64) {
    var lens = getLens(b64);
    var validLen = lens[0];
    var placeHoldersLen = lens[1];
    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
  }
  function _byteLength(b64, validLen, placeHoldersLen) {
    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
  }
  function toByteArray(b64) {
    var tmp;
    var lens = getLens(b64);
    var validLen = lens[0];
    var placeHoldersLen = lens[1];
    var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
    var curByte = 0;
    var len = placeHoldersLen > 0 ? validLen - 4 : validLen;
    var i;
    for (i = 0; i < len; i += 4) {
      tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];
      arr[curByte++] = tmp >> 16 & 255;
      arr[curByte++] = tmp >> 8 & 255;
      arr[curByte++] = tmp & 255;
    }
    if (placeHoldersLen === 2) {
      tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;
      arr[curByte++] = tmp & 255;
    }
    if (placeHoldersLen === 1) {
      tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;
      arr[curByte++] = tmp >> 8 & 255;
      arr[curByte++] = tmp & 255;
    }
    return arr;
  }
  function tripletToBase64(num) {
    return lookup$1[num >> 18 & 63] + lookup$1[num >> 12 & 63] + lookup$1[num >> 6 & 63] + lookup$1[num & 63];
  }
  function encodeChunk(uint8, start, end) {
    var tmp;
    var output = [];
    for (var i = start; i < end; i += 3) {
      tmp = (uint8[i] << 16 & 16711680) + (uint8[i + 1] << 8 & 65280) + (uint8[i + 2] & 255);
      output.push(tripletToBase64(tmp));
    }
    return output.join("");
  }
  function fromByteArray(uint8) {
    var tmp;
    var len = uint8.length;
    var extraBytes = len % 3;
    var parts = [];
    var maxChunkLength = 16383;
    for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
      parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
    }
    if (extraBytes === 1) {
      tmp = uint8[len - 1];
      parts.push(
        lookup$1[tmp >> 2] + lookup$1[tmp << 4 & 63] + "=="
      );
    } else if (extraBytes === 2) {
      tmp = (uint8[len - 2] << 8) + uint8[len - 1];
      parts.push(
        lookup$1[tmp >> 10] + lookup$1[tmp >> 4 & 63] + lookup$1[tmp << 2 & 63] + "="
      );
    }
    return parts.join("");
  }
  var ieee754 = {};
  /*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
  ieee754.read = function(buffer2, offset, isLE, mLen, nBytes) {
    var e2, m2;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var nBits = -7;
    var i = isLE ? nBytes - 1 : 0;
    var d2 = isLE ? -1 : 1;
    var s2 = buffer2[offset + i];
    i += d2;
    e2 = s2 & (1 << -nBits) - 1;
    s2 >>= -nBits;
    nBits += eLen;
    for (; nBits > 0; e2 = e2 * 256 + buffer2[offset + i], i += d2, nBits -= 8) {
    }
    m2 = e2 & (1 << -nBits) - 1;
    e2 >>= -nBits;
    nBits += mLen;
    for (; nBits > 0; m2 = m2 * 256 + buffer2[offset + i], i += d2, nBits -= 8) {
    }
    if (e2 === 0) {
      e2 = 1 - eBias;
    } else if (e2 === eMax) {
      return m2 ? NaN : (s2 ? -1 : 1) * Infinity;
    } else {
      m2 = m2 + Math.pow(2, mLen);
      e2 = e2 - eBias;
    }
    return (s2 ? -1 : 1) * m2 * Math.pow(2, e2 - mLen);
  };
  ieee754.write = function(buffer2, value, offset, isLE, mLen, nBytes) {
    var e2, m2, c2;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
    var i = isLE ? 0 : nBytes - 1;
    var d2 = isLE ? 1 : -1;
    var s2 = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
    value = Math.abs(value);
    if (isNaN(value) || value === Infinity) {
      m2 = isNaN(value) ? 1 : 0;
      e2 = eMax;
    } else {
      e2 = Math.floor(Math.log(value) / Math.LN2);
      if (value * (c2 = Math.pow(2, -e2)) < 1) {
        e2--;
        c2 *= 2;
      }
      if (e2 + eBias >= 1) {
        value += rt / c2;
      } else {
        value += rt * Math.pow(2, 1 - eBias);
      }
      if (value * c2 >= 2) {
        e2++;
        c2 /= 2;
      }
      if (e2 + eBias >= eMax) {
        m2 = 0;
        e2 = eMax;
      } else if (e2 + eBias >= 1) {
        m2 = (value * c2 - 1) * Math.pow(2, mLen);
        e2 = e2 + eBias;
      } else {
        m2 = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
        e2 = 0;
      }
    }
    for (; mLen >= 8; buffer2[offset + i] = m2 & 255, i += d2, m2 /= 256, mLen -= 8) {
    }
    e2 = e2 << mLen | m2;
    eLen += mLen;
    for (; eLen > 0; buffer2[offset + i] = e2 & 255, i += d2, e2 /= 256, eLen -= 8) {
    }
    buffer2[offset + i - d2] |= s2 * 128;
  };
  /*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   */
  (function(exports) {
    var base64 = base64Js;
    var ieee754$1 = ieee754;
    var customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
    exports.Buffer = Buffer2;
    exports.SlowBuffer = SlowBuffer;
    exports.INSPECT_MAX_BYTES = 50;
    var K_MAX_LENGTH = 2147483647;
    exports.kMaxLength = K_MAX_LENGTH;
    Buffer2.TYPED_ARRAY_SUPPORT = typedArraySupport();
    if (!Buffer2.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
      console.error(
        "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
      );
    }
    function typedArraySupport() {
      try {
        var arr = new Uint8Array(1);
        var proto = { foo: function() {
          return 42;
        } };
        Object.setPrototypeOf(proto, Uint8Array.prototype);
        Object.setPrototypeOf(arr, proto);
        return arr.foo() === 42;
      } catch (e2) {
        return false;
      }
    }
    Object.defineProperty(Buffer2.prototype, "parent", {
      enumerable: true,
      get: function() {
        if (!Buffer2.isBuffer(this)) return void 0;
        return this.buffer;
      }
    });
    Object.defineProperty(Buffer2.prototype, "offset", {
      enumerable: true,
      get: function() {
        if (!Buffer2.isBuffer(this)) return void 0;
        return this.byteOffset;
      }
    });
    function createBuffer(length) {
      if (length > K_MAX_LENGTH) {
        throw new RangeError('The value "' + length + '" is invalid for option "size"');
      }
      var buf = new Uint8Array(length);
      Object.setPrototypeOf(buf, Buffer2.prototype);
      return buf;
    }
    function Buffer2(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        if (typeof encodingOrOffset === "string") {
          throw new TypeError(
            'The "string" argument must be of type string. Received type number'
          );
        }
        return allocUnsafe(arg);
      }
      return from(arg, encodingOrOffset, length);
    }
    Buffer2.poolSize = 8192;
    function from(value, encodingOrOffset, length) {
      if (typeof value === "string") {
        return fromString(value, encodingOrOffset);
      }
      if (ArrayBuffer.isView(value)) {
        return fromArrayView(value);
      }
      if (value == null) {
        throw new TypeError(
          "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
        );
      }
      if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
        return fromArrayBuffer(value, encodingOrOffset, length);
      }
      if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {
        return fromArrayBuffer(value, encodingOrOffset, length);
      }
      if (typeof value === "number") {
        throw new TypeError(
          'The "value" argument must not be of type number. Received type number'
        );
      }
      var valueOf = value.valueOf && value.valueOf();
      if (valueOf != null && valueOf !== value) {
        return Buffer2.from(valueOf, encodingOrOffset, length);
      }
      var b = fromObject(value);
      if (b) return b;
      if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
        return Buffer2.from(
          value[Symbol.toPrimitive]("string"),
          encodingOrOffset,
          length
        );
      }
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
      );
    }
    Buffer2.from = function(value, encodingOrOffset, length) {
      return from(value, encodingOrOffset, length);
    };
    Object.setPrototypeOf(Buffer2.prototype, Uint8Array.prototype);
    Object.setPrototypeOf(Buffer2, Uint8Array);
    function assertSize(size) {
      if (typeof size !== "number") {
        throw new TypeError('"size" argument must be of type number');
      } else if (size < 0) {
        throw new RangeError('The value "' + size + '" is invalid for option "size"');
      }
    }
    function alloc(size, fill, encoding) {
      assertSize(size);
      if (size <= 0) {
        return createBuffer(size);
      }
      if (fill !== void 0) {
        return typeof encoding === "string" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
      }
      return createBuffer(size);
    }
    Buffer2.alloc = function(size, fill, encoding) {
      return alloc(size, fill, encoding);
    };
    function allocUnsafe(size) {
      assertSize(size);
      return createBuffer(size < 0 ? 0 : checked(size) | 0);
    }
    Buffer2.allocUnsafe = function(size) {
      return allocUnsafe(size);
    };
    Buffer2.allocUnsafeSlow = function(size) {
      return allocUnsafe(size);
    };
    function fromString(string2, encoding) {
      if (typeof encoding !== "string" || encoding === "") {
        encoding = "utf8";
      }
      if (!Buffer2.isEncoding(encoding)) {
        throw new TypeError("Unknown encoding: " + encoding);
      }
      var length = byteLength2(string2, encoding) | 0;
      var buf = createBuffer(length);
      var actual = buf.write(string2, encoding);
      if (actual !== length) {
        buf = buf.slice(0, actual);
      }
      return buf;
    }
    function fromArrayLike(array) {
      var length = array.length < 0 ? 0 : checked(array.length) | 0;
      var buf = createBuffer(length);
      for (var i = 0; i < length; i += 1) {
        buf[i] = array[i] & 255;
      }
      return buf;
    }
    function fromArrayView(arrayView) {
      if (isInstance(arrayView, Uint8Array)) {
        var copy = new Uint8Array(arrayView);
        return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
      }
      return fromArrayLike(arrayView);
    }
    function fromArrayBuffer(array, byteOffset, length) {
      if (byteOffset < 0 || array.byteLength < byteOffset) {
        throw new RangeError('"offset" is outside of buffer bounds');
      }
      if (array.byteLength < byteOffset + (length || 0)) {
        throw new RangeError('"length" is outside of buffer bounds');
      }
      var buf;
      if (byteOffset === void 0 && length === void 0) {
        buf = new Uint8Array(array);
      } else if (length === void 0) {
        buf = new Uint8Array(array, byteOffset);
      } else {
        buf = new Uint8Array(array, byteOffset, length);
      }
      Object.setPrototypeOf(buf, Buffer2.prototype);
      return buf;
    }
    function fromObject(obj) {
      if (Buffer2.isBuffer(obj)) {
        var len = checked(obj.length) | 0;
        var buf = createBuffer(len);
        if (buf.length === 0) {
          return buf;
        }
        obj.copy(buf, 0, 0, len);
        return buf;
      }
      if (obj.length !== void 0) {
        if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
          return createBuffer(0);
        }
        return fromArrayLike(obj);
      }
      if (obj.type === "Buffer" && Array.isArray(obj.data)) {
        return fromArrayLike(obj.data);
      }
    }
    function checked(length) {
      if (length >= K_MAX_LENGTH) {
        throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
      }
      return length | 0;
    }
    function SlowBuffer(length) {
      if (+length != length) {
        length = 0;
      }
      return Buffer2.alloc(+length);
    }
    Buffer2.isBuffer = function isBuffer(b) {
      return b != null && b._isBuffer === true && b !== Buffer2.prototype;
    };
    Buffer2.compare = function compare(a2, b) {
      if (isInstance(a2, Uint8Array)) a2 = Buffer2.from(a2, a2.offset, a2.byteLength);
      if (isInstance(b, Uint8Array)) b = Buffer2.from(b, b.offset, b.byteLength);
      if (!Buffer2.isBuffer(a2) || !Buffer2.isBuffer(b)) {
        throw new TypeError(
          'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
        );
      }
      if (a2 === b) return 0;
      var x2 = a2.length;
      var y2 = b.length;
      for (var i = 0, len = Math.min(x2, y2); i < len; ++i) {
        if (a2[i] !== b[i]) {
          x2 = a2[i];
          y2 = b[i];
          break;
        }
      }
      if (x2 < y2) return -1;
      if (y2 < x2) return 1;
      return 0;
    };
    Buffer2.isEncoding = function isEncoding(encoding) {
      switch (String(encoding).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return true;
        default:
          return false;
      }
    };
    Buffer2.concat = function concat2(list, length) {
      if (!Array.isArray(list)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      }
      if (list.length === 0) {
        return Buffer2.alloc(0);
      }
      var i;
      if (length === void 0) {
        length = 0;
        for (i = 0; i < list.length; ++i) {
          length += list[i].length;
        }
      }
      var buffer2 = Buffer2.allocUnsafe(length);
      var pos = 0;
      for (i = 0; i < list.length; ++i) {
        var buf = list[i];
        if (isInstance(buf, Uint8Array)) {
          if (pos + buf.length > buffer2.length) {
            Buffer2.from(buf).copy(buffer2, pos);
          } else {
            Uint8Array.prototype.set.call(
              buffer2,
              buf,
              pos
            );
          }
        } else if (!Buffer2.isBuffer(buf)) {
          throw new TypeError('"list" argument must be an Array of Buffers');
        } else {
          buf.copy(buffer2, pos);
        }
        pos += buf.length;
      }
      return buffer2;
    };
    function byteLength2(string2, encoding) {
      if (Buffer2.isBuffer(string2)) {
        return string2.length;
      }
      if (ArrayBuffer.isView(string2) || isInstance(string2, ArrayBuffer)) {
        return string2.byteLength;
      }
      if (typeof string2 !== "string") {
        throw new TypeError(
          'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string2
        );
      }
      var len = string2.length;
      var mustMatch = arguments.length > 2 && arguments[2] === true;
      if (!mustMatch && len === 0) return 0;
      var loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "ascii":
          case "latin1":
          case "binary":
            return len;
          case "utf8":
          case "utf-8":
            return utf8ToBytes(string2).length;
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return len * 2;
          case "hex":
            return len >>> 1;
          case "base64":
            return base64ToBytes(string2).length;
          default:
            if (loweredCase) {
              return mustMatch ? -1 : utf8ToBytes(string2).length;
            }
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer2.byteLength = byteLength2;
    function slowToString(encoding, start, end) {
      var loweredCase = false;
      if (start === void 0 || start < 0) {
        start = 0;
      }
      if (start > this.length) {
        return "";
      }
      if (end === void 0 || end > this.length) {
        end = this.length;
      }
      if (end <= 0) {
        return "";
      }
      end >>>= 0;
      start >>>= 0;
      if (end <= start) {
        return "";
      }
      if (!encoding) encoding = "utf8";
      while (true) {
        switch (encoding) {
          case "hex":
            return hexSlice(this, start, end);
          case "utf8":
          case "utf-8":
            return utf8Slice(this, start, end);
          case "ascii":
            return asciiSlice(this, start, end);
          case "latin1":
          case "binary":
            return latin1Slice(this, start, end);
          case "base64":
            return base64Slice(this, start, end);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return utf16leSlice(this, start, end);
          default:
            if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
            encoding = (encoding + "").toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer2.prototype._isBuffer = true;
    function swap(b, n, m2) {
      var i = b[n];
      b[n] = b[m2];
      b[m2] = i;
    }
    Buffer2.prototype.swap16 = function swap16() {
      var len = this.length;
      if (len % 2 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 16-bits");
      }
      for (var i = 0; i < len; i += 2) {
        swap(this, i, i + 1);
      }
      return this;
    };
    Buffer2.prototype.swap32 = function swap32() {
      var len = this.length;
      if (len % 4 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 32-bits");
      }
      for (var i = 0; i < len; i += 4) {
        swap(this, i, i + 3);
        swap(this, i + 1, i + 2);
      }
      return this;
    };
    Buffer2.prototype.swap64 = function swap64() {
      var len = this.length;
      if (len % 8 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 64-bits");
      }
      for (var i = 0; i < len; i += 8) {
        swap(this, i, i + 7);
        swap(this, i + 1, i + 6);
        swap(this, i + 2, i + 5);
        swap(this, i + 3, i + 4);
      }
      return this;
    };
    Buffer2.prototype.toString = function toString() {
      var length = this.length;
      if (length === 0) return "";
      if (arguments.length === 0) return utf8Slice(this, 0, length);
      return slowToString.apply(this, arguments);
    };
    Buffer2.prototype.toLocaleString = Buffer2.prototype.toString;
    Buffer2.prototype.equals = function equals(b) {
      if (!Buffer2.isBuffer(b)) throw new TypeError("Argument must be a Buffer");
      if (this === b) return true;
      return Buffer2.compare(this, b) === 0;
    };
    Buffer2.prototype.inspect = function inspect() {
      var str = "";
      var max = exports.INSPECT_MAX_BYTES;
      str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
      if (this.length > max) str += " ... ";
      return "<Buffer " + str + ">";
    };
    if (customInspectSymbol) {
      Buffer2.prototype[customInspectSymbol] = Buffer2.prototype.inspect;
    }
    Buffer2.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
      if (isInstance(target, Uint8Array)) {
        target = Buffer2.from(target, target.offset, target.byteLength);
      }
      if (!Buffer2.isBuffer(target)) {
        throw new TypeError(
          'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target
        );
      }
      if (start === void 0) {
        start = 0;
      }
      if (end === void 0) {
        end = target ? target.length : 0;
      }
      if (thisStart === void 0) {
        thisStart = 0;
      }
      if (thisEnd === void 0) {
        thisEnd = this.length;
      }
      if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
        throw new RangeError("out of range index");
      }
      if (thisStart >= thisEnd && start >= end) {
        return 0;
      }
      if (thisStart >= thisEnd) {
        return -1;
      }
      if (start >= end) {
        return 1;
      }
      start >>>= 0;
      end >>>= 0;
      thisStart >>>= 0;
      thisEnd >>>= 0;
      if (this === target) return 0;
      var x2 = thisEnd - thisStart;
      var y2 = end - start;
      var len = Math.min(x2, y2);
      var thisCopy = this.slice(thisStart, thisEnd);
      var targetCopy = target.slice(start, end);
      for (var i = 0; i < len; ++i) {
        if (thisCopy[i] !== targetCopy[i]) {
          x2 = thisCopy[i];
          y2 = targetCopy[i];
          break;
        }
      }
      if (x2 < y2) return -1;
      if (y2 < x2) return 1;
      return 0;
    };
    function bidirectionalIndexOf(buffer2, val, byteOffset, encoding, dir) {
      if (buffer2.length === 0) return -1;
      if (typeof byteOffset === "string") {
        encoding = byteOffset;
        byteOffset = 0;
      } else if (byteOffset > 2147483647) {
        byteOffset = 2147483647;
      } else if (byteOffset < -2147483648) {
        byteOffset = -2147483648;
      }
      byteOffset = +byteOffset;
      if (numberIsNaN(byteOffset)) {
        byteOffset = dir ? 0 : buffer2.length - 1;
      }
      if (byteOffset < 0) byteOffset = buffer2.length + byteOffset;
      if (byteOffset >= buffer2.length) {
        if (dir) return -1;
        else byteOffset = buffer2.length - 1;
      } else if (byteOffset < 0) {
        if (dir) byteOffset = 0;
        else return -1;
      }
      if (typeof val === "string") {
        val = Buffer2.from(val, encoding);
      }
      if (Buffer2.isBuffer(val)) {
        if (val.length === 0) {
          return -1;
        }
        return arrayIndexOf(buffer2, val, byteOffset, encoding, dir);
      } else if (typeof val === "number") {
        val = val & 255;
        if (typeof Uint8Array.prototype.indexOf === "function") {
          if (dir) {
            return Uint8Array.prototype.indexOf.call(buffer2, val, byteOffset);
          } else {
            return Uint8Array.prototype.lastIndexOf.call(buffer2, val, byteOffset);
          }
        }
        return arrayIndexOf(buffer2, [val], byteOffset, encoding, dir);
      }
      throw new TypeError("val must be string, number or Buffer");
    }
    function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
      var indexSize = 1;
      var arrLength = arr.length;
      var valLength = val.length;
      if (encoding !== void 0) {
        encoding = String(encoding).toLowerCase();
        if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
          if (arr.length < 2 || val.length < 2) {
            return -1;
          }
          indexSize = 2;
          arrLength /= 2;
          valLength /= 2;
          byteOffset /= 2;
        }
      }
      function read(buf, i2) {
        if (indexSize === 1) {
          return buf[i2];
        } else {
          return buf.readUInt16BE(i2 * indexSize);
        }
      }
      var i;
      if (dir) {
        var foundIndex = -1;
        for (i = byteOffset; i < arrLength; i++) {
          if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
            if (foundIndex === -1) foundIndex = i;
            if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;
          } else {
            if (foundIndex !== -1) i -= i - foundIndex;
            foundIndex = -1;
          }
        }
      } else {
        if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
        for (i = byteOffset; i >= 0; i--) {
          var found = true;
          for (var j2 = 0; j2 < valLength; j2++) {
            if (read(arr, i + j2) !== read(val, j2)) {
              found = false;
              break;
            }
          }
          if (found) return i;
        }
      }
      return -1;
    }
    Buffer2.prototype.includes = function includes(val, byteOffset, encoding) {
      return this.indexOf(val, byteOffset, encoding) !== -1;
    };
    Buffer2.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
    };
    Buffer2.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
    };
    function hexWrite(buf, string2, offset, length) {
      offset = Number(offset) || 0;
      var remaining = buf.length - offset;
      if (!length) {
        length = remaining;
      } else {
        length = Number(length);
        if (length > remaining) {
          length = remaining;
        }
      }
      var strLen = string2.length;
      if (length > strLen / 2) {
        length = strLen / 2;
      }
      for (var i = 0; i < length; ++i) {
        var parsed = parseInt(string2.substr(i * 2, 2), 16);
        if (numberIsNaN(parsed)) return i;
        buf[offset + i] = parsed;
      }
      return i;
    }
    function utf8Write(buf, string2, offset, length) {
      return blitBuffer(utf8ToBytes(string2, buf.length - offset), buf, offset, length);
    }
    function asciiWrite(buf, string2, offset, length) {
      return blitBuffer(asciiToBytes(string2), buf, offset, length);
    }
    function base64Write(buf, string2, offset, length) {
      return blitBuffer(base64ToBytes(string2), buf, offset, length);
    }
    function ucs2Write(buf, string2, offset, length) {
      return blitBuffer(utf16leToBytes(string2, buf.length - offset), buf, offset, length);
    }
    Buffer2.prototype.write = function write(string2, offset, length, encoding) {
      if (offset === void 0) {
        encoding = "utf8";
        length = this.length;
        offset = 0;
      } else if (length === void 0 && typeof offset === "string") {
        encoding = offset;
        length = this.length;
        offset = 0;
      } else if (isFinite(offset)) {
        offset = offset >>> 0;
        if (isFinite(length)) {
          length = length >>> 0;
          if (encoding === void 0) encoding = "utf8";
        } else {
          encoding = length;
          length = void 0;
        }
      } else {
        throw new Error(
          "Buffer.write(string, encoding, offset[, length]) is no longer supported"
        );
      }
      var remaining = this.length - offset;
      if (length === void 0 || length > remaining) length = remaining;
      if (string2.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
        throw new RangeError("Attempt to write outside buffer bounds");
      }
      if (!encoding) encoding = "utf8";
      var loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "hex":
            return hexWrite(this, string2, offset, length);
          case "utf8":
          case "utf-8":
            return utf8Write(this, string2, offset, length);
          case "ascii":
          case "latin1":
          case "binary":
            return asciiWrite(this, string2, offset, length);
          case "base64":
            return base64Write(this, string2, offset, length);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return ucs2Write(this, string2, offset, length);
          default:
            if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    };
    Buffer2.prototype.toJSON = function toJSON2() {
      return {
        type: "Buffer",
        data: Array.prototype.slice.call(this._arr || this, 0)
      };
    };
    function base64Slice(buf, start, end) {
      if (start === 0 && end === buf.length) {
        return base64.fromByteArray(buf);
      } else {
        return base64.fromByteArray(buf.slice(start, end));
      }
    }
    function utf8Slice(buf, start, end) {
      end = Math.min(buf.length, end);
      var res = [];
      var i = start;
      while (i < end) {
        var firstByte = buf[i];
        var codePoint = null;
        var bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
        if (i + bytesPerSequence <= end) {
          var secondByte, thirdByte, fourthByte, tempCodePoint;
          switch (bytesPerSequence) {
            case 1:
              if (firstByte < 128) {
                codePoint = firstByte;
              }
              break;
            case 2:
              secondByte = buf[i + 1];
              if ((secondByte & 192) === 128) {
                tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                if (tempCodePoint > 127) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 3:
              secondByte = buf[i + 1];
              thirdByte = buf[i + 2];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 4:
              secondByte = buf[i + 1];
              thirdByte = buf[i + 2];
              fourthByte = buf[i + 3];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                  codePoint = tempCodePoint;
                }
              }
          }
        }
        if (codePoint === null) {
          codePoint = 65533;
          bytesPerSequence = 1;
        } else if (codePoint > 65535) {
          codePoint -= 65536;
          res.push(codePoint >>> 10 & 1023 | 55296);
          codePoint = 56320 | codePoint & 1023;
        }
        res.push(codePoint);
        i += bytesPerSequence;
      }
      return decodeCodePointsArray(res);
    }
    var MAX_ARGUMENTS_LENGTH = 4096;
    function decodeCodePointsArray(codePoints) {
      var len = codePoints.length;
      if (len <= MAX_ARGUMENTS_LENGTH) {
        return String.fromCharCode.apply(String, codePoints);
      }
      var res = "";
      var i = 0;
      while (i < len) {
        res += String.fromCharCode.apply(
          String,
          codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
        );
      }
      return res;
    }
    function asciiSlice(buf, start, end) {
      var ret = "";
      end = Math.min(buf.length, end);
      for (var i = start; i < end; ++i) {
        ret += String.fromCharCode(buf[i] & 127);
      }
      return ret;
    }
    function latin1Slice(buf, start, end) {
      var ret = "";
      end = Math.min(buf.length, end);
      for (var i = start; i < end; ++i) {
        ret += String.fromCharCode(buf[i]);
      }
      return ret;
    }
    function hexSlice(buf, start, end) {
      var len = buf.length;
      if (!start || start < 0) start = 0;
      if (!end || end < 0 || end > len) end = len;
      var out = "";
      for (var i = start; i < end; ++i) {
        out += hexSliceLookupTable[buf[i]];
      }
      return out;
    }
    function utf16leSlice(buf, start, end) {
      var bytes = buf.slice(start, end);
      var res = "";
      for (var i = 0; i < bytes.length - 1; i += 2) {
        res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
      }
      return res;
    }
    Buffer2.prototype.slice = function slice(start, end) {
      var len = this.length;
      start = ~~start;
      end = end === void 0 ? len : ~~end;
      if (start < 0) {
        start += len;
        if (start < 0) start = 0;
      } else if (start > len) {
        start = len;
      }
      if (end < 0) {
        end += len;
        if (end < 0) end = 0;
      } else if (end > len) {
        end = len;
      }
      if (end < start) end = start;
      var newBuf = this.subarray(start, end);
      Object.setPrototypeOf(newBuf, Buffer2.prototype);
      return newBuf;
    };
    function checkOffset(offset, ext, length) {
      if (offset % 1 !== 0 || offset < 0) throw new RangeError("offset is not uint");
      if (offset + ext > length) throw new RangeError("Trying to access beyond buffer length");
    }
    Buffer2.prototype.readUintLE = Buffer2.prototype.readUIntLE = function readUIntLE(offset, byteLength3, noAssert) {
      offset = offset >>> 0;
      byteLength3 = byteLength3 >>> 0;
      if (!noAssert) checkOffset(offset, byteLength3, this.length);
      var val = this[offset];
      var mul = 1;
      var i = 0;
      while (++i < byteLength3 && (mul *= 256)) {
        val += this[offset + i] * mul;
      }
      return val;
    };
    Buffer2.prototype.readUintBE = Buffer2.prototype.readUIntBE = function readUIntBE(offset, byteLength3, noAssert) {
      offset = offset >>> 0;
      byteLength3 = byteLength3 >>> 0;
      if (!noAssert) {
        checkOffset(offset, byteLength3, this.length);
      }
      var val = this[offset + --byteLength3];
      var mul = 1;
      while (byteLength3 > 0 && (mul *= 256)) {
        val += this[offset + --byteLength3] * mul;
      }
      return val;
    };
    Buffer2.prototype.readUint8 = Buffer2.prototype.readUInt8 = function readUInt8(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 1, this.length);
      return this[offset];
    };
    Buffer2.prototype.readUint16LE = Buffer2.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 2, this.length);
      return this[offset] | this[offset + 1] << 8;
    };
    Buffer2.prototype.readUint16BE = Buffer2.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 2, this.length);
      return this[offset] << 8 | this[offset + 1];
    };
    Buffer2.prototype.readUint32LE = Buffer2.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
    };
    Buffer2.prototype.readUint32BE = Buffer2.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
    };
    Buffer2.prototype.readIntLE = function readIntLE(offset, byteLength3, noAssert) {
      offset = offset >>> 0;
      byteLength3 = byteLength3 >>> 0;
      if (!noAssert) checkOffset(offset, byteLength3, this.length);
      var val = this[offset];
      var mul = 1;
      var i = 0;
      while (++i < byteLength3 && (mul *= 256)) {
        val += this[offset + i] * mul;
      }
      mul *= 128;
      if (val >= mul) val -= Math.pow(2, 8 * byteLength3);
      return val;
    };
    Buffer2.prototype.readIntBE = function readIntBE(offset, byteLength3, noAssert) {
      offset = offset >>> 0;
      byteLength3 = byteLength3 >>> 0;
      if (!noAssert) checkOffset(offset, byteLength3, this.length);
      var i = byteLength3;
      var mul = 1;
      var val = this[offset + --i];
      while (i > 0 && (mul *= 256)) {
        val += this[offset + --i] * mul;
      }
      mul *= 128;
      if (val >= mul) val -= Math.pow(2, 8 * byteLength3);
      return val;
    };
    Buffer2.prototype.readInt8 = function readInt8(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 1, this.length);
      if (!(this[offset] & 128)) return this[offset];
      return (255 - this[offset] + 1) * -1;
    };
    Buffer2.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 2, this.length);
      var val = this[offset] | this[offset + 1] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer2.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 2, this.length);
      var val = this[offset + 1] | this[offset] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer2.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
    };
    Buffer2.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
    };
    Buffer2.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return ieee754$1.read(this, offset, true, 23, 4);
    };
    Buffer2.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return ieee754$1.read(this, offset, false, 23, 4);
    };
    Buffer2.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 8, this.length);
      return ieee754$1.read(this, offset, true, 52, 8);
    };
    Buffer2.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 8, this.length);
      return ieee754$1.read(this, offset, false, 52, 8);
    };
    function checkInt(buf, value, offset, ext, max, min) {
      if (!Buffer2.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
      if (value > max || value < min) throw new RangeError('"value" argument is out of bounds');
      if (offset + ext > buf.length) throw new RangeError("Index out of range");
    }
    Buffer2.prototype.writeUintLE = Buffer2.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength3, noAssert) {
      value = +value;
      offset = offset >>> 0;
      byteLength3 = byteLength3 >>> 0;
      if (!noAssert) {
        var maxBytes = Math.pow(2, 8 * byteLength3) - 1;
        checkInt(this, value, offset, byteLength3, maxBytes, 0);
      }
      var mul = 1;
      var i = 0;
      this[offset] = value & 255;
      while (++i < byteLength3 && (mul *= 256)) {
        this[offset + i] = value / mul & 255;
      }
      return offset + byteLength3;
    };
    Buffer2.prototype.writeUintBE = Buffer2.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength3, noAssert) {
      value = +value;
      offset = offset >>> 0;
      byteLength3 = byteLength3 >>> 0;
      if (!noAssert) {
        var maxBytes = Math.pow(2, 8 * byteLength3) - 1;
        checkInt(this, value, offset, byteLength3, maxBytes, 0);
      }
      var i = byteLength3 - 1;
      var mul = 1;
      this[offset + i] = value & 255;
      while (--i >= 0 && (mul *= 256)) {
        this[offset + i] = value / mul & 255;
      }
      return offset + byteLength3;
    };
    Buffer2.prototype.writeUint8 = Buffer2.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 1, 255, 0);
      this[offset] = value & 255;
      return offset + 1;
    };
    Buffer2.prototype.writeUint16LE = Buffer2.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 2, 65535, 0);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      return offset + 2;
    };
    Buffer2.prototype.writeUint16BE = Buffer2.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 2, 65535, 0);
      this[offset] = value >>> 8;
      this[offset + 1] = value & 255;
      return offset + 2;
    };
    Buffer2.prototype.writeUint32LE = Buffer2.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0);
      this[offset + 3] = value >>> 24;
      this[offset + 2] = value >>> 16;
      this[offset + 1] = value >>> 8;
      this[offset] = value & 255;
      return offset + 4;
    };
    Buffer2.prototype.writeUint32BE = Buffer2.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0);
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 255;
      return offset + 4;
    };
    Buffer2.prototype.writeIntLE = function writeIntLE(value, offset, byteLength3, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        var limit = Math.pow(2, 8 * byteLength3 - 1);
        checkInt(this, value, offset, byteLength3, limit - 1, -limit);
      }
      var i = 0;
      var mul = 1;
      var sub = 0;
      this[offset] = value & 255;
      while (++i < byteLength3 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
          sub = 1;
        }
        this[offset + i] = (value / mul >> 0) - sub & 255;
      }
      return offset + byteLength3;
    };
    Buffer2.prototype.writeIntBE = function writeIntBE(value, offset, byteLength3, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        var limit = Math.pow(2, 8 * byteLength3 - 1);
        checkInt(this, value, offset, byteLength3, limit - 1, -limit);
      }
      var i = byteLength3 - 1;
      var mul = 1;
      var sub = 0;
      this[offset + i] = value & 255;
      while (--i >= 0 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
          sub = 1;
        }
        this[offset + i] = (value / mul >> 0) - sub & 255;
      }
      return offset + byteLength3;
    };
    Buffer2.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 1, 127, -128);
      if (value < 0) value = 255 + value + 1;
      this[offset] = value & 255;
      return offset + 1;
    };
    Buffer2.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      return offset + 2;
    };
    Buffer2.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768);
      this[offset] = value >>> 8;
      this[offset + 1] = value & 255;
      return offset + 2;
    };
    Buffer2.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 4, 2147483647, -2147483648);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      this[offset + 2] = value >>> 16;
      this[offset + 3] = value >>> 24;
      return offset + 4;
    };
    Buffer2.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 4, 2147483647, -2147483648);
      if (value < 0) value = 4294967295 + value + 1;
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 255;
      return offset + 4;
    };
    function checkIEEE754(buf, value, offset, ext, max, min) {
      if (offset + ext > buf.length) throw new RangeError("Index out of range");
      if (offset < 0) throw new RangeError("Index out of range");
    }
    function writeFloat(buf, value, offset, littleEndian, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        checkIEEE754(buf, value, offset, 4);
      }
      ieee754$1.write(buf, value, offset, littleEndian, 23, 4);
      return offset + 4;
    }
    Buffer2.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
      return writeFloat(this, value, offset, true, noAssert);
    };
    Buffer2.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
      return writeFloat(this, value, offset, false, noAssert);
    };
    function writeDouble(buf, value, offset, littleEndian, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        checkIEEE754(buf, value, offset, 8);
      }
      ieee754$1.write(buf, value, offset, littleEndian, 52, 8);
      return offset + 8;
    }
    Buffer2.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
      return writeDouble(this, value, offset, true, noAssert);
    };
    Buffer2.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
      return writeDouble(this, value, offset, false, noAssert);
    };
    Buffer2.prototype.copy = function copy(target, targetStart, start, end) {
      if (!Buffer2.isBuffer(target)) throw new TypeError("argument should be a Buffer");
      if (!start) start = 0;
      if (!end && end !== 0) end = this.length;
      if (targetStart >= target.length) targetStart = target.length;
      if (!targetStart) targetStart = 0;
      if (end > 0 && end < start) end = start;
      if (end === start) return 0;
      if (target.length === 0 || this.length === 0) return 0;
      if (targetStart < 0) {
        throw new RangeError("targetStart out of bounds");
      }
      if (start < 0 || start >= this.length) throw new RangeError("Index out of range");
      if (end < 0) throw new RangeError("sourceEnd out of bounds");
      if (end > this.length) end = this.length;
      if (target.length - targetStart < end - start) {
        end = target.length - targetStart + start;
      }
      var len = end - start;
      if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
        this.copyWithin(targetStart, start, end);
      } else {
        Uint8Array.prototype.set.call(
          target,
          this.subarray(start, end),
          targetStart
        );
      }
      return len;
    };
    Buffer2.prototype.fill = function fill(val, start, end, encoding) {
      if (typeof val === "string") {
        if (typeof start === "string") {
          encoding = start;
          start = 0;
          end = this.length;
        } else if (typeof end === "string") {
          encoding = end;
          end = this.length;
        }
        if (encoding !== void 0 && typeof encoding !== "string") {
          throw new TypeError("encoding must be a string");
        }
        if (typeof encoding === "string" && !Buffer2.isEncoding(encoding)) {
          throw new TypeError("Unknown encoding: " + encoding);
        }
        if (val.length === 1) {
          var code2 = val.charCodeAt(0);
          if (encoding === "utf8" && code2 < 128 || encoding === "latin1") {
            val = code2;
          }
        }
      } else if (typeof val === "number") {
        val = val & 255;
      } else if (typeof val === "boolean") {
        val = Number(val);
      }
      if (start < 0 || this.length < start || this.length < end) {
        throw new RangeError("Out of range index");
      }
      if (end <= start) {
        return this;
      }
      start = start >>> 0;
      end = end === void 0 ? this.length : end >>> 0;
      if (!val) val = 0;
      var i;
      if (typeof val === "number") {
        for (i = start; i < end; ++i) {
          this[i] = val;
        }
      } else {
        var bytes = Buffer2.isBuffer(val) ? val : Buffer2.from(val, encoding);
        var len = bytes.length;
        if (len === 0) {
          throw new TypeError('The value "' + val + '" is invalid for argument "value"');
        }
        for (i = 0; i < end - start; ++i) {
          this[i + start] = bytes[i % len];
        }
      }
      return this;
    };
    var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
    function base64clean(str) {
      str = str.split("=")[0];
      str = str.trim().replace(INVALID_BASE64_RE, "");
      if (str.length < 2) return "";
      while (str.length % 4 !== 0) {
        str = str + "=";
      }
      return str;
    }
    function utf8ToBytes(string2, units) {
      units = units || Infinity;
      var codePoint;
      var length = string2.length;
      var leadSurrogate = null;
      var bytes = [];
      for (var i = 0; i < length; ++i) {
        codePoint = string2.charCodeAt(i);
        if (codePoint > 55295 && codePoint < 57344) {
          if (!leadSurrogate) {
            if (codePoint > 56319) {
              if ((units -= 3) > -1) bytes.push(239, 191, 189);
              continue;
            } else if (i + 1 === length) {
              if ((units -= 3) > -1) bytes.push(239, 191, 189);
              continue;
            }
            leadSurrogate = codePoint;
            continue;
          }
          if (codePoint < 56320) {
            if ((units -= 3) > -1) bytes.push(239, 191, 189);
            leadSurrogate = codePoint;
            continue;
          }
          codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
        } else if (leadSurrogate) {
          if ((units -= 3) > -1) bytes.push(239, 191, 189);
        }
        leadSurrogate = null;
        if (codePoint < 128) {
          if ((units -= 1) < 0) break;
          bytes.push(codePoint);
        } else if (codePoint < 2048) {
          if ((units -= 2) < 0) break;
          bytes.push(
            codePoint >> 6 | 192,
            codePoint & 63 | 128
          );
        } else if (codePoint < 65536) {
          if ((units -= 3) < 0) break;
          bytes.push(
            codePoint >> 12 | 224,
            codePoint >> 6 & 63 | 128,
            codePoint & 63 | 128
          );
        } else if (codePoint < 1114112) {
          if ((units -= 4) < 0) break;
          bytes.push(
            codePoint >> 18 | 240,
            codePoint >> 12 & 63 | 128,
            codePoint >> 6 & 63 | 128,
            codePoint & 63 | 128
          );
        } else {
          throw new Error("Invalid code point");
        }
      }
      return bytes;
    }
    function asciiToBytes(str) {
      var byteArray = [];
      for (var i = 0; i < str.length; ++i) {
        byteArray.push(str.charCodeAt(i) & 255);
      }
      return byteArray;
    }
    function utf16leToBytes(str, units) {
      var c2, hi, lo;
      var byteArray = [];
      for (var i = 0; i < str.length; ++i) {
        if ((units -= 2) < 0) break;
        c2 = str.charCodeAt(i);
        hi = c2 >> 8;
        lo = c2 % 256;
        byteArray.push(lo);
        byteArray.push(hi);
      }
      return byteArray;
    }
    function base64ToBytes(str) {
      return base64.toByteArray(base64clean(str));
    }
    function blitBuffer(src, dst, offset, length) {
      for (var i = 0; i < length; ++i) {
        if (i + offset >= dst.length || i >= src.length) break;
        dst[i + offset] = src[i];
      }
      return i;
    }
    function isInstance(obj, type) {
      return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
    }
    function numberIsNaN(obj) {
      return obj !== obj;
    }
    var hexSliceLookupTable = function() {
      var alphabet2 = "0123456789abcdef";
      var table = new Array(256);
      for (var i = 0; i < 16; ++i) {
        var i16 = i * 16;
        for (var j2 = 0; j2 < 16; ++j2) {
          table[i16 + j2] = alphabet2[i] + alphabet2[j2];
        }
      }
      return table;
    }();
  })(buffer);
  class GazelleMusic extends BaseFiller {
    constructor() {
      super(...arguments);
      this.priority = 10;
      this.isCustomSite = true;
    }
    canHandle(siteName) {
      return siteName.match(/(DicMusic|Orpheus)/) !== null;
    }
    async fill(info) {
      this.info = info;
      const { musicJson } = info;
      if (!musicJson) {
        return;
      }
      const { name, year } = musicJson.group;
      const groupId = getLocationSearchValueByKey("groupid");
      if (!groupId) {
        await this.searchAndRedirectToGroup(name, year);
      }
      await this.processSiteSpecificLogic(musicJson);
      this.fillJsonToUploadTable(musicJson, name);
      this.fillTorrentFile();
    }
    async searchAndRedirectToGroup(name, year) {
      var _a2;
      try {
        const searchResult = await GMFetch(
          `/ajax.php?action=browse&searchstr=${encodeURIComponent(name)} ${year}`,
          {
            responseType: "json"
          }
        );
        if (searchResult.status === "success" && searchResult.response.results.length > 0) {
          const groupId = searchResult.response.results[0].groupId;
          const timestampMatchArray = location.hash && location.hash.match(/(^|#)timestamp=([^#]*)(#|$)/);
          const timestamp2 = (_a2 = timestampMatchArray == null ? void 0 : timestampMatchArray[2]) != null ? _a2 : "";
          location.href = `${CURRENT_SITE_INFO.url}${CURRENT_SITE_INFO.uploadPath}?groupid=${groupId}#timestamp=${timestamp2}`;
          return true;
        }
      } catch (error) {
        console.error("Error searching for group:", error);
      }
      return false;
    }
    async processSiteSpecificLogic(musicJson) {
      if (CURRENT_SITE_NAME === "Orpheus") {
        const { remasterTitle, remasterCatalogueNumber, remasterRecordLabel } = musicJson.torrent;
        const { recordLabel, catalogueNumber } = musicJson.group;
        if (!remasterCatalogueNumber && !remasterRecordLabel && !remasterTitle && !recordLabel && !catalogueNumber) {
          musicJson.torrent.remastered = false;
        }
      } else if (CURRENT_SITE_NAME === "DicMusic") {
        musicJson.group.wikiBody = this.toUnicodeEntities(
          musicJson.group.wikiBody
        );
      }
    }
    fillJsonToUploadTable(musicJson, name) {
      const buf = buffer.Buffer.from(
        JSON.stringify({
          status: "success",
          response: musicJson
        })
      );
      this.attachFile({
        data: buf,
        selector: "#torrent-json-file",
        contentType: "application/json",
        fileName: name,
        format: "json"
      });
    }
    attachFile(options2) {
      const {
        data,
        selector,
        contentType,
        fileName,
        format: format2,
        charset = "UTF-8"
      } = options2;
      const buf = buffer.Buffer.isBuffer(data) ? data : buffer.Buffer.from(data, charset);
      const base64Data = buf.toString("base64");
      const fileInput = $$2(selector);
      if (base64Data && fileInput.length > 0) {
        const blob = base64ToBlob(base64Data, contentType);
        const file = new File([blob], `${fileName}.${format2}`, {
          type: contentType
        });
        const dataTransfer = new DataTransfer();
        dataTransfer.items.add(file);
        const uploadInput = fileInput[0];
        uploadInput.files = dataTransfer.files;
        uploadInput.dispatchEvent(new Event("change", { bubbles: true }));
      }
    }
    toUnicodeEntities(str) {
      const excludedChars = ["<", ">", "&", ";", "/"];
      return str.split("").map((char) => {
        const code2 = char.charCodeAt(0);
        if (code2 > 127 && !excludedChars.includes(char)) {
          const hexCode = code2.toString(16);
          return `&#${parseInt(hexCode, 16)};`;
        }
        return char;
      }).join("");
    }
  }
  registry$1.register(new GazelleMusic());
  class GPW extends BaseFiller {
    constructor() {
      super(...arguments);
      this.priority = 10;
      this.currentSiteInfo = PT_SITE.GPW;
    }
    canHandle(siteName) {
      return siteName === "GPW";
    }
    fill(info) {
      this.info = info;
      const isUploadSuccess = !$$2("#mediainfo")[0];
      if (isUploadSuccess) {
        return;
      }
      this.transformInfo();
      const isAddFormat = getLocationSearchValueByKey("groupid");
      if (!isAddFormat) {
        this.fillIMDbAndTriggerAutoFill();
      }
      this.fillCategory();
      this.fillEditionInfo();
      this.fillMediaInfos();
      setTimeout(() => {
        this.handleNoAutoCheck();
      }, 0);
      this.fillScene();
      this.fillProcessing();
      this.fillDescription();
      this.fillTorrentFile();
      $$2(".u-bbcodePreview-button").trigger("click");
    }
    fillIMDbAndTriggerAutoFill() {
      if (!this.info) return;
      $$2(this.currentSiteInfo.imdb.selector).val(this.info.imdbUrl || 0);
      $$2("#imdb_button").trigger("click");
      $$2("#upload .collapse").show();
    }
    fillCategory() {
      if (!this.info) return;
      $$2(this.currentSiteInfo.category.selector).val(
        this.currentSiteInfo.category.map[this.info.category]
      );
    }
    fillEditionInfo() {
      if (!this.info) return;
      const editionTags = Object.keys(this.info.tags).map(
        (tag) => this.info.tags[tag] && this.currentSiteInfo.targetInfo.editionTags[tag]
      ).filter(Boolean);
      let otherTag;
      if (this.info.otherTags && Object.keys(this.info.otherTags).length > 0) {
        otherTag = Object.keys(this.info.otherTags).join(", ");
      }
      if (editionTags.length > 0 || otherTag) {
        $$2("#movie_edition_information").trigger("click");
      }
      if (editionTags.length > 0) {
        for (const tag of editionTags) {
          $$2(`#movie_remaster_tags a[onclick*="'${tag}'"]`).trigger("click");
        }
      }
      if (otherTag) {
        $$2("#other-button").trigger("click");
        $$2("[name=remaster_custom_title]").val(otherTag);
      }
    }
    fillMediaInfos() {
      if (!this.info || !this.info.mediaInfos) {
        return;
      }
      for (let i = 1; i < this.info.mediaInfos.length; i++) {
        $$2("#add-mediainfo")[0].click();
      }
      const textareas = Array.from($$2('[name="mediainfo[]"]'));
      for (const [index, textarea] of textareas.entries()) {
        textarea.value = this.info.mediaInfos[index];
        textarea.dispatchEvent(new Event("input"));
      }
      $$2('[name="mediainfo[]"]')[0].dispatchEvent(new Event("change"));
    }
    handleNoAutoCheck() {
      if (!this.info) return;
      if (!$$2(this.currentSiteInfo.source.selector).val() || !$$2(this.currentSiteInfo.format.selector).val()) {
        const { mediaInfos, videoType } = this.info;
        const mediaInfo = (mediaInfos == null ? void 0 : mediaInfos[0]) || "";
        const isBluray = !!videoType.match(/bluray/i);
        const parsedMedia = parseMedia(mediaInfo, isBluray);
        if (!parsedMedia) {
          console.warn("Failed to parse media info:", mediaInfo);
          return;
        }
        const { format: format2 = "", subtitleTracks = [] } = parsedMedia;
        this.info.format = this.getFormat(format2, videoType);
        const keyArray = [
          "source",
          "videoCodec",
          "format",
          "resolution"
        ];
        keyArray.forEach((key) => {
          var _a2, _b;
          const { selector = "", map: map2 } = this.currentSiteInfo[key];
          if (map2) {
            const mapValue = map2[this.info[key]];
            $$2(selector).val(mapValue);
            if (key === "videoCodec" && mapValue === "Other") {
              document.querySelector(selector).dispatchEvent(new Event("change"));
              $$2('input[name="codec_other"]').val(
                (_b = (_a2 = this.info[key]) == null ? void 0 : _a2.toUpperCase()) != null ? _b : ""
              );
            }
          } else {
            $$2(selector).val(this.info[key] || "");
          }
        });
        this.fillSubtitles(subtitleTracks.map((track) => track.language));
      }
    }
    fillSubtitles(subtitles) {
      var _a2;
      if (subtitles.length > 0) {
        $$2("#mixed_subtitles").attr("checked", "true");
        $$2('input[name="subtitles[]"][type="checkbox"]').each(function() {
          var _a3, _b;
          const language = (_b = (_a3 = $$2(this).attr("id")) == null ? void 0 : _a3.replace(
            /^\S|(_\S)/g,
            (letter) => letter.replace("_", " ").toUpperCase()
          )) != null ? _b : "";
          if (subtitles.includes(language)) {
            $$2(this).attr("checked", "true");
          }
        });
        const event = new Event("change");
        (_a2 = document.querySelector("#mixed_subtitles")) == null ? void 0 : _a2.dispatchEvent(event);
        const chineseLanguages = subtitles.filter(
          (item) => item.match(/Chinese|Traditional|Simplified/i)
        );
        if (chineseLanguages.length === 1 && chineseLanguages[0] === "Chinese") {
          const selector = chineseLanguages[0].match(/Traditional/i) ? "#chinese_traditional" : "#chinese_simplified";
          $$2(selector).attr("checked", "true");
        } else if (chineseLanguages.length >= 2) {
          $$2("#chinese_traditional,#chinese_simplified").attr("checked", "true");
        }
      }
    }
    fillScene() {
      if (!this.info) return;
      if (this.info.tags.scene) {
        $$2("#scene").prop("checked", true);
      }
    }
    fillProcessing() {
      if (!this.info) return;
      let { videoType, size, source, tags: tags2 } = this.info;
      if (source.match(/bluray|hddvd|dvd/)) {
        if (tags2.diy) {
          videoType = "DIY";
        }
        const videoTypeConfig = this.currentSiteInfo.videoType;
        const { selector, map: map2 } = videoTypeConfig;
        $$2(selector).val(map2[videoType]);
        $$2(selector)[0].dispatchEvent(new Event("change"));
        if (map2[videoType] === "Untouched") {
          const bdType = getBDTypeBasedOnSize(size);
          $$2('select[name="processing_other"]').val(bdType || "");
        }
        $$2(selector)[0].dispatchEvent(new Event("input"));
      }
    }
    fillDescription() {
      if (!this.info) return;
      let description = "";
      if (this.info.sourceSite === "PTP") {
        description = buildPTPDescription(this.info);
      } else if (this.info.sourceSite === "BeyondHD") {
        description = this.info.originalDescription || "";
      } else {
        description = this.buildDescription();
      }
      $$2(this.currentSiteInfo.description.selector).val(description);
      $$2(this.currentSiteInfo.description.selector)[0].dispatchEvent(
        new Event("input")
      );
    }
    buildDescription() {
      if (!this.info) return "";
      let description = "";
      if (this.info.comparisons && this.info.comparisons.length > 0) {
        for (const comparison of this.info.comparisons) {
          description += `${comparison.reason}[comparison=${comparison.title}]
${comparison.imgs.join("\n")}
[/comparison]

`;
        }
      }
      if (this.info.screenshots.length > 0) {
        description += `${this.info.screenshots.map((v2) => `[img]${v2}[/img]`).join("\n")}

`;
      }
      return description.trim();
    }
    transformInfo() {
      if (!this.info) return;
      if (["encode", "remux"].includes(this.info.videoType) && this.info.mediaInfos) {
        const newMediaInfos = [];
        for (const mediaInfo of this.info.mediaInfos) {
          if (mediaInfo.match(/Disc Title|Disc Label/i)) {
            continue;
          }
          newMediaInfos.push(mediaInfo);
        }
        this.info.mediaInfos = newMediaInfos;
      }
    }
    getFormat(format2, videoType) {
      if (videoType.match(/bluray/) && format2 !== "iso") {
        format2 = "m2ts";
      } else if (videoType.match(/dvd/)) {
        format2 = "vob";
      }
      return format2 || "mkv";
    }
  }
  registry$1.register(new GPW());
  class ZHUQUE extends BaseFiller {
    constructor() {
      super(...arguments);
      this.priority = 10;
      this.currentSiteInfo = PT_SITE.ZHUQUE;
    }
    canHandle(siteName) {
      return siteName === "ZHUQUE";
    }
    fill(info) {
      this.info = info;
      this.setupMutationObserver();
    }
    setupMutationObserver() {
      if (!this.info) return;
      const targetNode = document;
      const imdbId = getIdByIMDbUrl(this.info.imdbUrl || "");
      const insert = new MutationObserver(() => {
        this.fillBasicFields(imdbId);
        this.fillZhuqueScreenshots();
        this.fillZhuqueMediaInfo();
        this.fillZhuqueDescription();
        this.setupSelectObserver();
        this.fillTorrentFile();
        insert.disconnect();
      });
      insert.observe(targetNode, {
        attributes: false,
        childList: false,
        subtree: true,
        characterDataOldValue: false
      });
    }
    fillBasicFields(imdbId) {
      if (!this.info) return;
      $$2("input.ant-select-selection-search-input[id]").each(function() {
        this.dispatchEvent(new Event("keydown"));
      });
      $$2(this.currentSiteInfo.name.selector).val(this.info.title);
      $$2(this.currentSiteInfo.name.selector)[0].dispatchEvent(new Event("input"));
      $$2(this.currentSiteInfo.imdb.selector).val(imdbId);
      $$2(this.currentSiteInfo.imdb.selector)[0].dispatchEvent(new Event("input"));
      if (this.info.subtitle) {
        $$2(this.currentSiteInfo.subtitle.selector).val(this.info.subtitle);
        $$2(this.currentSiteInfo.subtitle.selector)[0].dispatchEvent(
          new Event("input")
        );
      }
      $$2(`.ant-btn-primary span:contains(查 询)`).trigger("click");
    }
    fillZhuqueScreenshots() {
      if (!this.info) return;
      let screenshotStr = "";
      if (this.info.screenshots.length > 0) {
        this.info.screenshots.forEach((img) => {
          screenshotStr += `${img}
`;
        });
      }
      $$2(this.currentSiteInfo.screenshots.selector).val(screenshotStr);
      $$2(this.currentSiteInfo.screenshots.selector)[0].dispatchEvent(
        new Event("input")
      );
    }
    fillZhuqueMediaInfo() {
      var _a2, _b;
      if (!this.info) return;
      $$2(this.currentSiteInfo.mediaInfo.selector).val(
        (_b = (_a2 = this.info.mediaInfos) == null ? void 0 : _a2[0]) != null ? _b : ""
      );
      $$2(this.currentSiteInfo.mediaInfo.selector)[0].dispatchEvent(
        new Event("input")
      );
    }
    fillZhuqueDescription() {
      var _a2, _b;
      if (!this.info) return;
      let description = this.info.description.replace(`[quote]${(_b = (_a2 = this.info.mediaInfos) == null ? void 0 : _a2[0]) != null ? _b : ""}[/quote]`, "").trim();
      if (this.info.mediaInfos && this.info.mediaInfos.length > 1) {
        this.info.mediaInfos.forEach((mediaInfo) => {
          description = description.replace(`[quote]${mediaInfo}[/quote]`, "");
        });
      }
      if (this.info.sourceSite === "PTP") {
        description = buildPTPDescription(this.info);
        description = description.replace(
          /\[comparison[^[]*\[\/comparison\]/gi,
          ""
        );
      } else if (this.info.sourceSite.match(/BeyondHD|UHDBits/)) {
        description = this.info.originalDescription || "";
      }
      description = description.replace(/\[url.*\[\/url\]/g, "").replace(/\[img.*\[\/img\]/g, "").replace(/\[\/?(i|b|center|quote|size|color)\]/g, "").replace(/\[(size|color)=#?[a-zA-Z0-9]*\]/g, "").replace(/\n\n*/g, "\n");
      description = description.replace(/Screen(shot)?s:(\s*)\n?/gi, "").trim();
      if (this.info.sourceSite === "KEEPFRDS") {
        description = description.replace(/截图对比:[^\n]*\n?/gi, "");
      }
      if (description !== "") {
        description = `\`\`\`
${description}
\`\`\``;
      }
      if (this.info.comparisons && this.info.comparisons.length > 0) {
        for (const comparison in this.info.comparisons) {
          description += `
对比图 ${this.info.comparisons[comparison].title}

`;
          for (const img in this.info.comparisons[comparison].imgs) {
            description += `${this.info.comparisons[comparison].imgs[img]}

`;
          }
        }
      }
      const thanksQuoteClosed = GM_getValue(
        "easy-upload.thanks-quote-closed",
        ""
      );
      if (!thanksQuoteClosed && this.info.sourceSite !== void 0) {
        description = `\`\`\`
转自 ${this.info.sourceSite} ，感谢原发布者！
\`\`\`
${description}`;
      }
      $$2(this.currentSiteInfo.description.selector).val(description);
      $$2(this.currentSiteInfo.description.selector)[0].dispatchEvent(
        new Event("input")
      );
    }
    setupSelectObserver() {
      if (!this.info) return;
      const selectNodeParent = document.querySelector("form");
      if (!selectNodeParent) return;
      const select = new MutationObserver(async () => {
        this.fillCategory();
        this.fillVideoAndAudioParameters();
        select.disconnect();
      });
      select.observe(selectNodeParent, {
        attributes: false,
        childList: true,
        subtree: true,
        characterDataOldValue: false
      });
    }
    fillCategory() {
      if (!this.info) return;
      const { category: categoryConfig } = this.currentSiteInfo;
      $$2(
        `div.ant-select-item-option-content:contains(${categoryConfig.map[this.info.category]})`
      ).trigger("click");
    }
    fillVideoAndAudioParameters() {
      var _a2;
      if (!this.info) return;
      this.fillTags();
      const keyArray = ["videoType", "videoCodec", "audioCodec"];
      keyArray.forEach((key) => {
        const { map: map2 } = this.currentSiteInfo[key];
        if (!map2) return;
        const mapValue = map2[this.info[key]];
        if (!mapValue) return;
        this.clickAppropriateOption(key, mapValue);
      });
      if (this.info.resolution !== "") {
        (_a2 = $$2(
          `div.ant-select-item-option-content:contains(${this.info.resolution})`
        )[0]) == null ? void 0 : _a2.click();
      }
    }
    async fillTags() {
      if (!this.info) return;
      const sleep = (ms) => {
        return new Promise((resolve28) => setTimeout(resolve28, ms));
      };
      const { tags: tags2 } = this.currentSiteInfo;
      for (const tag in this.info.tags) {
        if (tags2[tag]) {
          await sleep(100).then(
            () => $$2(tags2[tag])[0].click()
          );
        }
      }
    }
    clickAppropriateOption(key, mapValue) {
      if (key !== "videoType" && $$2(`div.ant-select-item-option-content:contains(${mapValue})`).length > 0) {
        $$2(`div.ant-select-item-option-content:contains(${mapValue})`)[0].click();
      } else if (mapValue === "Blu-ray") {
        $$2(`div.ant-select-item-option-content:contains(${mapValue})`)[2].click();
      } else if ($$2(`div.ant-select-item-option-content:contains(${mapValue})`).length > 0) {
        $$2(`div.ant-select-item-option-content:contains(${mapValue})`)[0].click();
      }
    }
  }
  registry$1.register(new ZHUQUE());
  class ITS extends BaseFiller {
    constructor() {
      super(...arguments);
      this.priority = 10;
    }
    canHandle(siteName) {
      return siteName === "iTS";
    }
    async fill(info) {
      this.info = info;
      if (!this.info) return;
      this.processTorrentTitle();
      this.fillTorrentTitle();
      await this.generateAndFillDescription();
      this.handleCategoryAndCollection();
      this.postProcess();
    }
    processTorrentTitle() {
      super.processTorrentTitle();
      const { title } = this.info;
      this.info.title = title.replace(/\s/gi, ".");
    }
    postProcess() {
      const { category, title, doubanUrl, imdbUrl, screenshots, subtitle } = this.info;
      if (category === "tvPack" || title.match(/Trilogy|Collection/i) || subtitle && subtitle.match(/合集/)) {
        $$2('input[name="pack"]').attr("checked", "true");
      }
      $$2(this.siteInfo.imdb.selector).val(doubanUrl || imdbUrl);
      $$2(this.siteInfo.screenshots.selector).val(screenshots.join("\n"));
    }
    handleCategoryAndCollection() {
      if (!this.info) return;
      const { resolution, category } = this.info;
      if (!resolution.match(/2160|1080|720/) && category === "movie") {
        $$2('select[name="type"]').val("67");
      }
      const collectionMap = this.getCollectionMap();
      this.fillCollections(collectionMap);
    }
    getCollectionMap() {
      const collectionMap = {};
      $$2('select[name="collection_id1"] option').each(function() {
        const option = $$2(this);
        collectionMap[option.text()] = option.val();
      });
      return collectionMap;
    }
    async fillCollections(collectionMap) {
      var _a2, _b, _c;
      if (!this.info || !this.info.imdbUrl) return;
      const { category } = this.info;
      const teamName = getTeamName(this.info.title);
      const collectionValues = [];
      if (collectionMap[teamName]) {
        collectionValues.push(collectionMap[teamName]);
      }
      if (category.match(/tv|movie|cartoon|documentary/)) {
        try {
          const imdbData = await getIMDBData(this.info.imdbUrl);
          if (imdbData) {
            const { directors = [], details } = imdbData;
            let language = details.Languages || "";
            language = (_c = (_b = (_a2 = language == null ? void 0 : language.split("|")) == null ? void 0 : _a2[0]) == null ? void 0 : _b.trim()) != null ? _c : "";
            const director = directors.map((item) => item.name)[0];
            if (collectionMap[director]) {
              collectionValues.push(collectionMap[director]);
            }
            if (collectionMap[language]) {
              collectionValues.push(collectionMap[language]);
            }
          }
        } catch (error) {
          console.error("Error fetching IMDB data:", error);
        }
      }
      collectionValues.forEach((value, index) => {
        $$2(`select[name="collection_id${index + 1}"]`).val(value);
      });
    }
    async generateAndFillDescription() {
      if (!this.info) return;
      const { category, screenshots, comparisons = [] } = this.info;
      if (!category.match(/tv|movie|cartoon|documentary/)) return;
      let template = this.createDescriptionTemplate();
      template = this.fillScreenshotsInTemplate(template, screenshots);
      template = this.fillComparisonsInTemplate(template, comparisons);
      $$2('textarea[name="descr"]').val($t$1("数据加载中..."));
      try {
        template = await this.fillTemplateWithMetadata(template);
        $$2('textarea[name="descr"]').val(template);
      } catch (error) {
        $$2('textarea[name="descr"]').val(error.message);
      }
    }
    createDescriptionTemplate() {
      return `[center]

  [img]$poster$[/img]
  
  [url=$imdbUrl$][img]https://i.ibb.co/KD855ZM/IMDb-Logo-2016.png[/img][/url][size=3]$imdbScore$[/size][*][url=$rtUrl$][img]https://i.ibb.co/BwtmdcV/rottentomatoes-logo.png[/img][/url][size=3]$rtScore$[/size][*][size=3][url=$tmdbUrl$][img]https://i.ibb.co/HhgF1gC/tmdb-logo.png[/img][/url]$tmdbScore$[/size]


  [color=DarkOrange][size=2]◢ SYNOPSIS ◣[/size][/color]
  $synopsis$
  
  [color=DarkOrange][size=2]◢ TRAILER ◣[/size][/color]
  [youtube]$youtubeUrl$[/youtube]

  [color=DarkOrange][size=2]◢ SCREENSHOTS ◣[/size][/color]
  [box][hide]$SCREENSHOTS$[/hide][/box]
  
  [/center]`;
    }
    fillScreenshotsInTemplate(template, screenshots) {
      const screenshotsBBCode = screenshots.map((img) => `[img]${img}[/img]`);
      return template.replace("$SCREENSHOTS$", screenshotsBBCode.join("\n"));
    }
    fillComparisonsInTemplate(template, comparisons) {
      const comparisonImgs = comparisons.flatMap((v2) => v2.imgs);
      if (comparisonImgs.length > 0) {
        const comparisonImgsBBCode = comparisonImgs.map(
          (img) => `[img]${img}[/img]`
        );
        return template.replace(
          /(\[\/center\])$/,
          `[color=DarkOrange][size=2]◢ COMPARISONS ◣[/size][/color]


    [box][hide]${comparisonImgsBBCode.join(" ")}[/hide][/box]

$1`
        );
      }
      return template;
    }
    async fillTemplateWithMetadata(template) {
      if (!this.info || !this.info.imdbUrl) return template;
      const { imdbUrl } = this.info;
      const replaceParams = {
        tmdbUrl: "",
        tmdbScore: "0",
        imdbScore: "0",
        imdbUrl,
        poster: "",
        synopsis: "",
        rtUrl: "",
        rtScore: "0",
        youtubeUrl: ""
      };
      await this.fillIMDBData(replaceParams);
      await this.fillTMDBData(replaceParams);
      Object.keys(replaceParams).forEach((key) => {
        template = template.replace(
          `$${key}$`,
          replaceParams[key] || ""
        );
      });
      return template;
    }
    async fillIMDBData(replaceParams) {
      var _a2, _b;
      if (!this.info || !this.info.imdbUrl) return;
      const { category, movieName } = this.info;
      try {
        const imdbData = await getIMDBData(this.info.imdbUrl);
        if (imdbData) {
          const {
            poster = "",
            imdb_rating_average: imdbRate,
            description = "",
            aka,
            year
          } = imdbData;
          replaceParams.poster = poster;
          replaceParams.synopsis = description;
          replaceParams.imdbScore = imdbRate;
          const searchMovieName = movieName || ((_b = (_a2 = aka.filter((item) => item.country.match(/(World-wide)|UK|USA/))) == null ? void 0 : _a2[0]) == null ? void 0 : _b.title);
          await this.fillRottenTomatoesData(
            replaceParams,
            searchMovieName,
            category,
            year
          );
          await this.uploadPosterToPtpImg(replaceParams, poster);
        }
      } catch (error) {
        console.error("Error fetching IMDB data:", error);
      }
    }
    async fillRottenTomatoesData(replaceParams, movieName, category, year) {
      if (!movieName) return;
      try {
        const rtInfo = await getMatchRottenTomatoes(
          movieName,
          year,
          !!category.match(/tv/)
        );
        if (!rtInfo) return;
        const { rottenTomatoes, rtId = "" } = rtInfo;
        replaceParams.rtScore = `${rottenTomatoes.audienceScore}%`;
        replaceParams.rtUrl = `https://www.rottentomatoes.com/${rtId}`;
      } catch (error) {
        console.error("Error fetching Rotten Tomatoes data:", error);
      }
    }
    async uploadPosterToPtpImg(replaceParams, poster) {
      const ptpImgApiKey = GM_getValue("easy-upload.ptp-img-api-key") || "";
      if (ptpImgApiKey && poster) {
        try {
          const ptpImgPoster = await (await uploadToPtpImg)([poster]);
          replaceParams.poster = ptpImgPoster ? ptpImgPoster[0] : "";
        } catch (error) {
          console.error("Error uploading poster to PTP image host:", error);
        }
      }
    }
    async fillTMDBData(replaceParams) {
      if (!this.info || !this.info.imdbUrl) return;
      try {
        const imdbId = getIdByIMDbUrl(this.info.imdbUrl);
        const { id: tmdbId, vote_average: tmdbRate } = await getTMDBDataByIMDBId(imdbId);
        if (tmdbId) {
          replaceParams.tmdbUrl = `https://www.themoviedb.org/movie/${tmdbId}`;
          replaceParams.tmdbScore = `${tmdbRate}`;
          await this.fillTrailerData(replaceParams, tmdbId);
        }
      } catch (error) {
        console.error("Error fetching TMDB data:", error);
      }
    }
    async fillTrailerData(replaceParams, tmdbId) {
      try {
        const videos = await getTMDBVideosById(`${tmdbId}`);
        const youtubeVideo = videos.find((video) => video.site === "YouTube");
        if (youtubeVideo == null ? void 0 : youtubeVideo.key) {
          replaceParams.youtubeUrl = `https://www.youtube.com/watch?v=${youtubeVideo.key}`;
        }
      } catch (error) {
        console.error("Error fetching trailer data:", error);
      }
    }
  }
  registry$1.register(new ITS());
  class BYR extends BaseFiller {
    constructor() {
      super(...arguments);
      this.priority = 10;
    }
    canHandle(siteName) {
      return siteName === "BYR";
    }
    fill(info) {
      this.info = info;
      if (!this.info) return;
      this.fillBasicInfo();
      this.setupDescriptionEditor();
      this.fillOriginalTitle();
      this.extractAndFillCategoryFields();
      this.fillTorrentFile();
    }
    fillBasicInfo() {
      const { subtitle, imdbUrl, doubanUrl } = this.info;
      $$2(this.siteInfo.subtitle.selector).val(subtitle || "");
      $$2(this.siteInfo.imdb.selector).val(imdbUrl || "");
      $$2(this.siteInfo.douban.selector).val(doubanUrl || "");
    }
    setupDescriptionEditor() {
      const { description } = this.info;
      CKEDITOR.on("instanceReady", () => {
        CKEDITOR.instances.descr.setData(this.convertBBCodeToHtml(description));
      });
    }
    fillOriginalTitle() {
      this.processTorrentTitle();
      const { title } = this.info;
      $$2("#movie_ename0day").val(title);
    }
    extractAndFillCategoryFields() {
      const { category } = this.info;
      const torrentInfo = this.extractTorrentInfo();
      if (category.match(/movie/)) {
        this.fillMovieFields(torrentInfo);
      } else if (category.match(/tv/)) {
        this.fillTVFields(torrentInfo);
      } else if (category.match(/variety/)) {
        this.fillVarietyFields(torrentInfo);
      }
    }
    extractTorrentInfo() {
      var _a2, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l;
      const { description, doubanInfo } = this.info;
      const fullDescription = description + doubanInfo;
      let area = (_b = (_a2 = fullDescription.match(/(产\s+地|国\s+家)\s+(.+)/)) == null ? void 0 : _a2[2]) != null ? _b : "";
      area = area.replace(/\[\/?.+?\]/g, "");
      const originalName = (_d = (_c = fullDescription.match(/(片\s+名)\s+(.+)?/)) == null ? void 0 : _c[2]) != null ? _d : "";
      const translateName = (_h = (_g = (_f = (_e = fullDescription.match(/(译\s+名)\s+(.+)/)) == null ? void 0 : _e[2]) == null ? void 0 : _f.split("/")) == null ? void 0 : _g[0]) != null ? _h : "";
      const movieType = (_j = (_i = fullDescription.match(/(类\s+别)\s+(.+)/)) == null ? void 0 : _i[2]) != null ? _j : "";
      const language = (_l = (_k = fullDescription.match(/(语\s+言)\s+(.+)/)) == null ? void 0 : _k[2]) != null ? _l : "";
      let chineseName = originalName;
      if (!originalName.match(/[\u4e00-\u9fa5]+/)) {
        chineseName = translateName.match(/[\u4e00-\u9fa5]+/) ? translateName : "";
      }
      return {
        area,
        originalName,
        translateName,
        movieType,
        language,
        chineseName
      };
    }
    fillMovieFields(torrentInfo) {
      const { area, chineseName, movieType } = torrentInfo;
      const { category } = this.info;
      const regionSelector = this.determineMovieRegion(area);
      const typeMap = {
        华语: "11",
        欧洲: "12",
        北美: "13",
        亚洲: "14",
        其他: "1"
      };
      $$2('select[name="second_type"]').val(
        typeMap[regionSelector]
      );
      $$2('select[name="second_type"]')[0].dispatchEvent(new Event("change"));
      const movieTypeArr = movieType.split(/\s\//);
      $$2("#movie_type").val(movieTypeArr.join("/"));
      fillField(
        regionSelector,
        category === "movie" ? "movie_country" : "show_country"
      );
      $$2("#movie_cname").val(chineseName);
    }
    determineMovieRegion(area) {
      if (area.match(/华语|台|港/)) {
        return "华语";
      } else if (area.match(/日本|韩国|泰国/)) {
        return "亚洲";
      } else if (area.match(/美国|加拿大/)) {
        return "北美";
      } else if (area.match(/欧|英|法|德|俄|意|苏联|EU/)) {
        return "欧洲";
      }
      return "其他";
    }
    fillTVFields(torrentInfo) {
      var _a2, _b;
      const { area, chineseName } = torrentInfo;
      const { title, videoType, mediaInfos } = this.info;
      const regionSelector = this.determineTVRegion(area);
      const typeMap = {
        大陆: "15",
        港台: "16",
        欧美: "17",
        日韩: "18",
        其他: "2"
      };
      $$2('select[name="second_type"]').val(
        typeMap[regionSelector]
      );
      $$2('select[name="second_type"]')[0].dispatchEvent(new Event("change"));
      fillField(regionSelector, "tv_type");
      $$2("#tv_ename").val(title);
      $$2("#cname").val(chineseName);
      const episode = (_b = (_a2 = title.match(/S\d+(E\d+)?/i)) == null ? void 0 : _a2[0]) != null ? _b : "";
      $$2("#tv_season").val(episode);
      const isBluray = !!videoType.match(/bluray/i);
      const parsedMedia = parseMedia(mediaInfos == null ? void 0 : mediaInfos[0], isBluray);
      if (!parsedMedia) {
        console.warn("Failed to parse media info:", mediaInfos == null ? void 0 : mediaInfos[0]);
        return;
      }
      const { format: format2 } = parsedMedia;
      fillField((format2 == null ? void 0 : format2.toUpperCase()) || "MKV", "tv_filetype");
    }
    determineTVRegion(area) {
      if (area.match(/大陆/)) {
        return "大陆";
      } else if (area.match(/台|港/)) {
        return "港台";
      } else if (area.match(/美国|欧|英|法|德|俄|意|苏联|EU/)) {
        return "欧美";
      } else if (area.match(/日本|韩国/)) {
        return "日韩";
      }
      return "其他";
    }
    fillVarietyFields(torrentInfo) {
      const { area, chineseName, language } = torrentInfo;
      const { title } = this.info;
      const regionSelector = this.determineTVRegion(area);
      const typeMap = {
        大陆: "27",
        港台: "29",
        欧美: "30",
        日韩: "28",
        其他: "5"
      };
      $$2('select[name="second_type"]').val(
        typeMap[regionSelector]
      );
      $$2('select[name="second_type"]')[0].dispatchEvent(new Event("change"));
      fillField(regionSelector, "show_country");
      $$2("#show_cname").val(chineseName);
      $$2("#show_ename").val(title);
      const languageVal = this.determineLanguage(language);
      fillField(languageVal, "show_language");
    }
    determineLanguage(language) {
      if (language.match(/汉语/)) {
        return "国语";
      } else if (language.match(/粤/)) {
        return "粤语";
      } else if (language.match(/英语/)) {
        return "英语";
      } else if (language.match(/日语/)) {
        return "日语";
      } else if (language.match(/韩语/)) {
        return "韩语";
      }
      return "";
    }
    convertBBCodeToHtml(bbcode) {
      let html2 = bbcode.replace(/\[\*\]([^\n]+)/gi, "<li>$1</li>");
      html2 = html2.replace(/(\r\n)|\n/g, "<br>");
      html2 = html2.replace(
        /\[(quote|hide=.+?)\]/gi,
        "<fieldset><legend>引用</legend>"
      );
      html2 = html2.replace(/\[(\/)(quote|hide)\]/gi, "<$1fieldset>");
      html2 = html2.replace(
        /(?!\[url=(http(s)*:\/{2}.+?)\])\[img\](.+?)\[\/img]\[url\]/g,
        '<a href="$1"><img src="$2"/></a>'
      );
      html2 = html2.replace(/\[img\](.+?)\[\/img]/g, '<img src="$1"/>');
      html2 = html2.replace(/\[(\/)?(left|right|center)\]/gi, "<$1$2>");
      html2 = html2.replace(/\[(\/)?b\]/gi, "<$1strong>");
      html2 = html2.replace(/\[color=(.+?)\]/gi, '<span style="color: $1">').replace(/\[\/color\]/g, "</span>");
      html2 = html2.replace(/\[size=(.+?)\]/gi, '<font size="$1">').replace(/\[\/size\]/g, "</font>");
      html2 = html2.replace(/\[url=(.+?)\](.+?)\[\/url\]/gi, '<a href="$1">$2</a>');
      return html2;
    }
  }
  registry$1.register(new BYR());
  class PTer extends BaseFiller {
    constructor() {
      super(...arguments);
      this.priority = 10;
    }
    canHandle(siteName) {
      return siteName === "PTer" || siteName === "PTer-offer";
    }
    processTorrentTitle() {
      const { source, title } = this.info;
      const isWebSource = !!source.match(/web/gi);
      const fixedTitle = fixTorrentTitle(title, isWebSource);
      this.info.title = fixedTitle;
      super.processTorrentTitle();
    }
    postProcess() {
      var _a2, _b;
      const { description, area } = this.info;
      const language = (_b = (_a2 = description.match(/(语\s+言)\s+(.+)/)) == null ? void 0 : _a2[2]) != null ? _b : "";
      if (!language.match(/英语/) && area === "EU") {
        $$2(this.siteInfo.area.selector).val("8");
      }
    }
    processDescription() {
      var _a2;
      let { description, comparisons } = this.info;
      const quoteRegex = /\[quote\]([\s\S]*?)\[\/quote\]/g;
      let modifiedDescription = description;
      let match;
      while ((match = quoteRegex.exec(description)) !== null) {
        const fullMatch = match[0];
        const quoteContent = match[1];
        if (quoteContent.match(/Disc Title|Disc Label/i)) {
          const replacement = `[hide=BDInfo]${quoteContent}[/hide]`;
          modifiedDescription = modifiedDescription.replace(
            fullMatch,
            replacement
          );
        } else if (quoteContent.match(/(Unique\s*ID)|(Codec\s*ID)|(Stream\s*size)/i)) {
          const replacement = `[hide=mediainfo]${quoteContent}[/hide]`;
          modifiedDescription = modifiedDescription.replace(
            fullMatch,
            replacement
          );
        }
      }
      description = modifiedDescription;
      if (comparisons == null ? void 0 : comparisons.length) {
        for (const comparison of comparisons) {
          const { title, imgs } = comparison;
          const titleCount = (_a2 = title == null ? void 0 : title.split(",").length) != null ? _a2 : "";
          imgs.forEach((img) => {
            description = description.replace(
              `[img]${img}[/img]`,
              `[img${titleCount}]${img}[/img]`
            );
          });
        }
      }
      this.info.description = description;
      super.processDescription();
    }
  }
  registry$1.register(new PTer());
  class MTV extends BaseFiller {
    constructor() {
      super(...arguments);
      this.priority = 10;
    }
    canHandle(siteName) {
      return siteName === "MTV";
    }
    postProcess() {
      if (!this.info) return;
      const { resolution, videoCodec, audioCodec, title, videoType, tags: tags2 } = this.info;
      const tagSet = /* @__PURE__ */ new Set();
      this.processResolution(resolution, tagSet);
      if (videoCodec) {
        tagSet.add(videoCodec);
      }
      this.processAudioCodec(audioCodec, tagSet);
      if (title.match(/(\s|.)hybrid(\s|.)/i)) {
        tagSet.add("hybrid");
      }
      this.processSourceAndType(title, videoType, tagSet);
      this.processAudioAndSubtitleTags(tags2, tagSet);
      this.processHDRTags(tags2, tagSet);
      this.updateTagInput(tagSet);
    }
    processDescription() {
      let { description, mediaInfos } = this.info;
      mediaInfos == null ? void 0 : mediaInfos.forEach((mediaInfo) => {
        description = description.replace(
          `[quote]${mediaInfo}[/quote]`,
          `[mediainfo]${mediaInfo}[/mediainfo]`
        );
      });
      this.info.description = description;
      super.processDescription();
    }
    processResolution(resolution, tagSet) {
      var _a2;
      if (!resolution) return;
      const cleanResolution = resolution.replace("p", "");
      (_a2 = $(`input[name="Resolution"][value="${cleanResolution}"]`)[0]) == null ? void 0 : _a2.click();
      tagSet.add(cleanResolution);
    }
    processAudioCodec(audioCodec, tagSet) {
      if (!audioCodec) return;
      if (audioCodec === "dd+") {
        tagSet.add("ddp.audio");
      } else if (audioCodec.match(/dd|ac3/i)) {
        tagSet.add("dd.audio");
      } else if (audioCodec.match(/dtshd/i)) {
        tagSet.add("dts.hd.audio");
      } else if (audioCodec.match(/dtsx/i)) {
        tagSet.add("dts.x.audio");
      } else {
        tagSet.add(`${audioCodec}.audio`);
      }
    }
    processSourceAndType(title, videoType, tagSet) {
      var _a2, _b, _c, _d;
      if (/web-dl/i.test(title)) {
        (_a2 = $('input[name="source"][value="9"]')[0]) == null ? void 0 : _a2.click();
        tagSet.add("web.dl");
        if (/NF|Netflix/i.test(title)) {
          tagSet.add("netflix.source");
        }
      } else if (/webrip/i.test(title)) {
        tagSet.add("webrip");
        (_b = $('input[name="source"][value="10"]')[0]) == null ? void 0 : _b.click();
      } else if (videoType.match(/bluray/i)) {
        tagSet.add("bluray");
        (_c = $('input[name="source"][value="7"]')[0]) == null ? void 0 : _c.click();
      } else if (videoType.match(/remux/i)) {
        tagSet.add(videoType);
        (_d = $('input[name="source"][value="7"]')[0]) == null ? void 0 : _d.click();
      } else if (videoType) {
        tagSet.add(videoType);
      }
    }
    processAudioAndSubtitleTags(tags2, tagSet) {
      if (tags2.cantonese_audio) {
        tagSet.add("cantonese.audio.track");
      }
      if (tags2.chinese_audio) {
        tagSet.add("chinese.audio.track");
      }
      if (tags2.chinese_subtitle) {
        tagSet.add("chinese.subs");
      }
    }
    processHDRTags(tags2, tagSet) {
      if (tags2.hdr10) {
        tagSet.add("hdr");
      }
      if (tags2.dolby_vision) {
        tagSet.add("dovi");
      }
      if (tags2.hdr10_plus) {
        tagSet.add("hdr10plus");
      }
    }
    updateTagInput(tagSet) {
      const tagString = Array.from(tagSet).join(" ");
      $("#taginput").val(tagString);
    }
  }
  registry$1.register(new MTV());
  async function autoFillDoubanInfo(selfDom, info) {
    try {
      $$2(selfDom).text($t$1("获取中..."));
      const {
        imdbUrl,
        movieName,
        doubanUrl,
        description: descriptionData,
        title: torrentTitle
      } = info;
      if (!imdbUrl && !doubanUrl) {
        throw new Error($t$1("请填写正确链接"));
      }
      let doubanLink = "";
      if (doubanUrl == null ? void 0 : doubanUrl.match(/movie\.douban\.com/)) {
        doubanLink = doubanUrl;
      } else {
        const doubanData = await getDoubanBasicDataByQuery(imdbUrl || movieName);
        if (doubanData) {
          let { id, isTV } = doubanData;
          if (isTV) {
            const tvData = await getDoubanTVItemData(doubanData, torrentTitle);
            if (tvData) {
              id = tvData && tvData.id;
            }
          }
          doubanLink = `https://movie.douban.com/subject/${id}`;
        }
      }
      if (doubanLink) {
        const { douban, imdb, subtitle, description, name } = CURRENT_SITE_INFO;
        if (CURRENT_SITE_NAME === "SSD") {
          $$2(imdb.selector).val(doubanLink);
        } else {
          $$2(douban == null ? void 0 : douban.selector).val(doubanLink);
        }
        if (!(descriptionData == null ? void 0 : descriptionData.match(/(片|译)\s*名/))) {
          const movieData = await getDoubanInfoByIdOrDoubanUrl(doubanLink);
          if (movieData) {
            const imdbLink = movieData.imdbLink;
            if ($$2(imdb.selector).val() !== imdbLink && CURRENT_SITE_NAME !== "SSD") {
              $$2(imdb.selector).val(imdbLink);
            }
            const torrentSubtitle = getSubTitleFromDoubanInfo(movieData, info);
            if (CURRENT_SITE_NAME === "TTG") {
              $$2(name.selector).val(`${torrentTitle || ""}[${torrentSubtitle}]`);
            } else {
              $$2(subtitle.selector).val(torrentSubtitle);
            }
            if (CURRENT_SITE_NAME !== "SSD") {
              $$2(description.selector).val(
                `${movieData.format}
${$$2(description.selector).val()}`
              );
            }
          }
        }
      }
    } catch (error) {
      console.log(error.message);
    } finally {
      $$2(selfDom).text($t$1("获取豆瓣简介"));
    }
  }
  const autofill = (info) => {
    if (info.doubanInfo) {
      return;
    }
    if (CURRENT_SITE_INFO.siteType.match(/NexusPHP|TTG/)) {
      const { imdb, douban } = CURRENT_SITE_INFO;
      let selector = $$2("");
      if ((douban == null ? void 0 : douban.selector) && $$2(douban.selector) && $$2(douban.selector).val()) {
        selector = $$2(douban.selector);
      } else if (imdb) {
        selector = $$2(imdb.selector);
      }
      if (selector) {
        selector.after(
          `<span id="auto-fill-douban">${$t$1("获取豆瓣简介")}</span>`
        );
      }
      $$2("#auto-fill-douban").on("click", () => {
        const url = selector.val();
        if (url.match(/subject\/(\d+)/)) {
          info.doubanUrl = url;
        } else if (url.match(/imdb\.com\/title\/tt\d+/)) {
          info.imdbUrl = url;
        }
        autoFillDoubanInfo($$2("#auto-fill-douban"), info);
      });
    }
  };
  const fillTargetForm = (info) => {
    if (!info) {
      console.warn("No torrent info provided for filling form");
      return;
    }
    console.log("Filling form with info:", info);
    autofill(info);
    const filler = registry$1.getApplicableFiller(
      CURRENT_SITE_NAME,
      CURRENT_SITE_INFO.siteType
    );
    if (filler) {
      filler.fill(info);
    } else {
      console.warn(`No specialized filler found for site: ${CURRENT_SITE_NAME}`);
    }
  };
  class ExtractorRegistry {
    constructor() {
      this.extractors = [];
    }
    register(extractor) {
      this.extractors.push(extractor);
      this.extractors.sort((a2, b) => b.priority - a2.priority);
    }
    getExtractor(siteName, siteType) {
      return this.extractors.find(
        (extractor) => extractor.canHandle(siteName, siteType)
      ) || null;
    }
  }
  const registry = new ExtractorRegistry();
  const CONFIG = {
    NEXUS_FILTER_KEYWORDS: [
      "温馨提示",
      "郑重",
      "PT站",
      "网上搜集",
      "本种子",
      "商业盈利",
      "商业用途",
      "带宽",
      "寬帶",
      "法律责任",
      "Quote:",
      "正版",
      "商用",
      "注明",
      "后果",
      "负责"
    ],
    FORBIDDEN_KEYWORDS: [
      "禁转",
      "禁轉",
      "严禁转载",
      "嚴禁轉載",
      "谢绝转载",
      "謝絕轉載",
      "exclusive"
    ],
    META_INFO_MATCH_RULES: {
      resolution: /(分辨率|解析度|格式):\s?([^\u4e00-\u9fa5]+)?/i,
      videoType: /(媒介|来源|质量):\s?([^\u4e00-\u9fa5]+)?/i,
      category: /(类型|分类|類別):\s?([^\u4e00-\u9fa5]+)?/i,
      audioCodec: /(音频|音频编码):\s?([^\u4e00-\u9fa5]+)?/i,
      videoCodec: /(编码|編碼):\s?([^\u4e00-\u9fa5]+)?/i,
      area: /(处理|處理|地区|地區):\s?([^\u4e00-\u9fa5]+)?/i,
      size: /(大小|容量):\s?([^\u4e00-\u9fa5]+)?/i
    },
    VIDEO_TYPE_MATCH_MAP: (resolution) => [
      {
        type: "encode",
        regex: /压制|encode|x264|x265|bdrip|hdrip/i
      },
      {
        type: "remux",
        regex: /remux/i
      },
      {
        type: "uhdbluray",
        regex: /uhd|ultra|UHD原盘|FullDisc|(BluRay\s*Raw)/i,
        condition: () => !resolution || /2160|4k/i.test(resolution)
      },
      {
        type: "bluray",
        regex: /blu|discs|bluray原盘|FullDisc|(BluRay\s*Raw)/i,
        condition: () => !resolution || /1080/i.test(resolution)
      },
      {
        type: "web",
        regex: /webdl/i
      },
      {
        type: "hdtv",
        regex: /hdtv/i
      },
      {
        type: "dvdrip",
        regex: /dvdr/i
      },
      {
        type: "dvd",
        regex: /dvd/i
      }
    ],
    VIDEO_SOURCE_MATCH_MAP: {
      uhdbluray: /(uhd|2160|4k).*(blu(-)?ray|remux)/i,
      bluray: /(blu(-)?ray|remux)/i,
      hdtv: /hdtv/i,
      web: /web(-?(rip|dl))+/i,
      hddvd: /hddvd/i,
      dvd: /dvd/i,
      vhs: /vhs/i
    },
    VIDEO_CATEGORY_MAP: {
      movie: /movie|电影/gi,
      variety: /综艺|variety/gi,
      tv: /tv|drama|剧集|电视|剧/,
      tvPack: /TVSeries|剧包/gi,
      cartoon: /anim|动(画|漫)/gi,
      sport: /sport|体育/gi,
      concert: /mv|演唱|concert/gi,
      app: /App|软件|Software|軟體|Applications/gi,
      ebook: /电子书|小说|Ebook/gi,
      audiobook: /有声书|AudioBook/gi,
      magazine: /杂志|magazine/gi,
      comics: /漫画|comics/gi,
      onlineCourse: /公开课/gi,
      documentary: /纪录片|documentary|记录/gi,
      other: /Learning Videos|Comedy/,
      music: /music|音乐/gi
    },
    RESOLUTION_MAP: {
      "4320p": /4320p|8k/i,
      "2160p": /2160p|UHD|4k/i,
      "1080p": /1080(p)?/i,
      "1080i": /1080i/i,
      "720p": /720(p)?/i,
      "576p": /576p|576i/i,
      "480p": /480(p|i)|sd/i
    },
    VIDEO_CODEC_RULES: (source, videoType) => [
      {
        codec: "x264",
        regex: /x264/i,
        condition: () => /h264|avc/i.test(source) && videoType === "encode"
      },
      {
        codec: "h264",
        regex: /h264|AVC/i
      },
      {
        codec: "x265",
        regex: /x265/i,
        condition: () => /h265|hevc/i.test(source) && videoType === "encode"
      },
      { codec: "hevc", regex: /hevc|h265/i },
      { codec: "vc1", regex: /vc-?1/i },
      { codec: "mpeg2", regex: /mpeg-?2/i },
      { codec: "mpeg4", regex: /mpeg-?4/i },
      { codec: "vvc", regex: /vvc/i }
    ],
    MEDIA_TAG_RULES: (source) => [
      { regex: /diy/i, tag: "diy" },
      {
        regex: /国配|国语|普通话|国粤/i,
        tag: "chinese_audio",
        condition: () => !/多国语(言|字幕)/.test(source)
      },
      { regex: /Atmos|杜比全景声/i, tag: "dolby_atmos" },
      { regex: /HDR10\+/i, tag: "hdr10_plus" },
      { regex: /HDR/i, tag: "hdr10" },
      { regex: /DoVi|(Dolby\s*Vision)|杜比视界/i, tag: "dolby_vision" },
      { regex: /粤/i, tag: "cantonese_audio" },
      {
        regex: /简繁|繁简|繁体|简体|中字|中英|中文/i,
        tag: "chinese_subtitle",
        condition: () => !/无中(字|文)/.test(source)
      },
      { regex: /Criterion|CC标准/i, tag: "the_criterion_collection" },
      {
        regex: /禁转|禁轉|严禁转载|嚴禁轉載|谢绝转载|謝絕轉載|禁止转载|exclusive/i,
        tag: "exclusive"
      }
    ],
    MT_BASE_API_URL: "https://api2.m-team.cc/api",
    MT_REQUEST_VERSION: "1.1.2",
    MT_SPECS_MAP: {
      source: {
        8: "web",
        1: "bluray",
        3: "dvd",
        4: "hdtv",
        5: "hdtv",
        6: "other",
        7: "cd"
      },
      medium: {
        1: "bluray",
        2: "hddvd",
        3: "remux",
        7: "encode",
        4: "bluray",
        5: "hdtv",
        6: "dvd",
        8: "cd",
        10: "web"
      },
      standard: {
        1: "1080p",
        2: "1080i",
        3: "720p",
        5: "480p",
        6: "2160p"
      }
    },
    UNIT3D_BASIC_KEY_MAP: {
      name: ["Name", "名称", "名稱"],
      size: ["Size", "体积", "體積"],
      category: ["Category", "类别", "類別"],
      type: ["Type", "规格", "規格"],
      resolution: ["Resolution"]
    },
    AVISTAZ_BASIC_KEY_MAP: {
      Type: "category",
      "File Size": "size",
      Title: "title",
      "Video Quality": "resolution",
      "Rip Type": "videoType"
    },
    BHD_SOURCE_MEDIA_TAGS_MAP: {
      common: {
        HDR10: "hdr10",
        "HDR10+": "hdr10_plus",
        "Dolby Atmos": "dolby_atmos",
        "Dolby Vision": "dolby_vision"
      },
      others: {
        "10-bit": "10_bit",
        "2-Disc Set": "2_disc_set",
        "2D/3D Edition": "2d_3d_edition",
        "2in1": "2_in_1",
        "3D": "3d",
        "3D Anaglyph": "3d_anaglyph",
        "3D Full SBS": "3d_full_sbs",
        "3D Half OU": "3d_half_ou",
        "3D Half SBS": "3d_half_sbs",
        "4K Remaster": "4k_remaster",
        "4K Restoration": "4k_restoration",
        "Digital Extras": "extras",
        "Director's Cut": "director_s_cut",
        "Dual Audio": "dual_audio",
        "English Dub": "english_dub",
        "Extended Cut": "extended_edition",
        "Extended Edition": "extended_edition",
        Extras: "extras",
        "Masters of Cinema": "masters_of_cinema",
        Scene: "scene",
        "The Criterion Collection": "the_criterion_collection",
        "Theatrical Cut": "theatrical_cut",
        "Two-Disc Set": "two_disc_set",
        Remux: "remux",
        Rifftrax: "rifftrax",
        Uncut: "uncut",
        Unrated: "unrated",
        "Warner Archive Collection": "warner_archive_collection",
        Commentary: "with_commentary"
      }
    },
    MUSIC_LOG_API_MAP: (logScore, torrentId, logId) => ({
      RED: `/torrents.php?action=loglist&torrentid=${torrentId}`,
      Orpheus: `/view.php?type=riplog&id=${torrentId}.${logId}`,
      DicMusic: `torrents.php?action=viewlog&logscore=${logScore}&torrentid=${torrentId}`
    })
  };
  const formatTorrentTitle = (title) => {
    return title.replace(/\.(?!(\d+))/gi, " ").replace(/\.(?=\d{4}|48|57|72|2k|4k|7.1|6.1|5.1|4.1|2.0|1.0)/gi, " ").trim();
  };
  const getFilterBBCode = (content) => {
    var _a2;
    if (content) {
      const bbCodes = htmlToBBCode(content);
      return (_a2 = bbCodes == null ? void 0 : bbCodes.replace(/\[quote\]((.|\n)*?)\[\/quote\]/g, (match, p1) => {
        if (p1) {
          return CONFIG.NEXUS_FILTER_KEYWORDS.some(
            (keyword) => p1.includes(keyword)
          ) ? "" : match;
        }
        return match;
      })) != null ? _a2 : "";
    }
    return "";
  };
  const refineCategory = (torrentInfo, category) => {
    var _a2, _b;
    const { description, title, subtitle = "", doubanInfo } = torrentInfo;
    const isAnimation = (genre) => /动画/.test(genre);
    const isDocumentary = (genre) => /纪录/.test(genre);
    const isSeasonPack = (title2, subtitle2) => {
      var _a3;
      return /全.+?集/.test(subtitle2) || ((_a3 = title2 == null ? void 0 : title2.match(/s\d+(\s|\.)+/i)) == null ? void 0 : _a3.length);
    };
    const isEpisode = (title2, subtitle2) => /(s0?\d{1,2})?e(p)?\d{1,2}/i.test(title2) || /第[^\s]集/.test(subtitle2);
    const movieGenre = (_b = (_a2 = (description + doubanInfo).match(/(类\s+别)\s+(.+)?/)) == null ? void 0 : _a2[2]) != null ? _b : "";
    if (isAnimation(movieGenre)) {
      return "cartoon";
    }
    if (isDocumentary(movieGenre)) {
      return "documentary";
    }
    if (isSeasonPack(title, subtitle)) {
      return "tvPack";
    }
    if (category == null ? void 0 : category.match(/tv/)) {
      return isEpisode(title, subtitle) ? "tv" : "tvPack";
    }
    return category;
  };
  const getVideoTypeFromSource = (source, resolution) => {
    if (!source) {
      return "";
    }
    const normalized = source.replace(/[.-]/g, "").toLowerCase();
    for (const { regex, type, condition } of CONFIG.VIDEO_TYPE_MATCH_MAP(
      resolution
    )) {
      if (regex.test(normalized) && (!condition || condition())) {
        return type;
      }
    }
    return "";
  };
  const getVideoSourceFromTitle = (title) => {
    for (const [key, reg] of Object.entries(CONFIG.VIDEO_SOURCE_MATCH_MAP)) {
      if (reg.test(title)) {
        return key;
      }
    }
    return "other";
  };
  const getBDInfoOrMediaInfoFromBBCode = (bbcode) => {
    var _a2, _b, _c, _d, _e;
    const quoteList = [];
    const quoteRegex = /\[quote\]([^[\]])+?\[\/quote\]/gi;
    while ((_a2 = bbcode == null ? void 0 : bbcode.match(quoteRegex)) == null ? void 0 : _a2.length) {
      const matchContent = (_c = (_b = bbcode == null ? void 0 : bbcode.match(quoteRegex)) == null ? void 0 : _b[0]) != null ? _c : "";
      quoteList.push(matchContent);
      bbcode = bbcode.replace(matchContent, "");
    }
    const cleanQuoteContent = (quote) => quote.replace(/\[\/?quote\]/g, "").replace(/\u200D/g, "").trim();
    const isBDInfo = (content) => /Disc\s?Size|\.mpls/i.test(content) || /Disc\s+(Info|Title|Label)[^[]+/i.test(content);
    const isMediaInfo = (content) => /(Unique\s*ID)|(Codec\s*ID)|(Stream\s*size)/i.test(content);
    const { bdInfo, mediaInfo } = quoteList.reduce(
      (acc, quote) => {
        const content = cleanQuoteContent(quote);
        if (isBDInfo(content)) {
          acc.bdInfo.push(content);
        }
        if (isMediaInfo(content)) {
          acc.mediaInfo.push(content);
        }
        return acc;
      },
      { bdInfo: [], mediaInfo: [] }
    );
    if (!bdInfo.length) {
      const fallback = (_e = (_d = bbcode.match(/Disc\s+(Info|Title|Label)[^[]+/i)) == null ? void 0 : _d[0]) == null ? void 0 : _e.trim();
      if (fallback) {
        bdInfo.push(fallback);
      }
    }
    return { bdInfo, mediaInfo };
  };
  const extractDetailsFromMediaInfo = (source) => {
    var _a2, _b, _c, _d, _e, _f, _g, _h;
    if (!source) {
      return null;
    }
    const result = {
      videoCodec: (_b = (_a2 = source.videoTracks) == null ? void 0 : _a2[0]) == null ? void 0 : _b.codec,
      audioCodec: (_d = (_c = source.audioTracks) == null ? void 0 : _c[0]) == null ? void 0 : _d.codec,
      resolution: (_f = (_e = source.videoTracks) == null ? void 0 : _e[0]) == null ? void 0 : _f.resolution,
      audioChannels: (_h = (_g = source.audioTracks) == null ? void 0 : _g[0]) == null ? void 0 : _h.channelName,
      audioLanguages: source.audioTracks.map((track) => track.language),
      subtitleLanguages: source.subtitleTracks.map((track) => track.language),
      hdrFormats: source.videoTracks.map((track) => {
        var _a3;
        return (_a3 = track == null ? void 0 : track.hdrType) != null ? _a3 : "";
      }).filter(Boolean)
    };
    return result;
  };
  const getMediaTags = ({
    audioCodec,
    audioLanguages,
    subtitleLanguages,
    hdrFormats
  }) => {
    const hasChineseAudio = audioLanguages.includes("Chinese");
    const hasChineseSubtitle = subtitleLanguages.includes("Chinese");
    const hasCantoneseAudio = audioLanguages.includes("Cantonese");
    const mediaTags = {};
    if (hasChineseAudio) mediaTags.chinese_audio = true;
    if (hasCantoneseAudio) mediaTags.cantonese_audio = true;
    if (hasChineseSubtitle) mediaTags.chinese_subtitle = true;
    const hdrMap = {
      HDR10: "hdr10",
      HDR: "hdr",
      HLG: "hlg",
      DV: "dolby_vision"
    };
    if (hdrFormats) {
      for (const [key, value] of Object.entries(hdrMap)) {
        if (hdrFormats.includes(key)) {
          mediaTags[value] = true;
        }
      }
    }
    if (/dtsx|atmos/gi.test(audioCodec)) {
      mediaTags.dts_x = true;
    } else if (/atmos/gi.test(audioCodec)) {
      mediaTags.dolby_atmos = true;
    }
    return mediaTags;
  };
  const getTagsFromSource = (source) => {
    const tags2 = {};
    for (const rule of CONFIG.MEDIA_TAG_RULES(source)) {
      if (rule.regex.test(source) && (!rule.condition || rule.condition())) {
        tags2[rule.tag] = true;
      }
    }
    return tags2;
  };
  const getResolutionFromSource = (source) => {
    for (const [resolution, reg] of Object.entries(CONFIG.RESOLUTION_MAP)) {
      if (reg.test(source)) {
        return resolution;
      }
    }
    return "";
  };
  const getVideoCodecFromSourceAndVideoType = (source, videoType = "") => {
    const formattedSource = source.replace(/\.|-/g, "");
    for (const { codec, regex, condition } of CONFIG.VIDEO_CODEC_RULES(
      formattedSource,
      videoType
    )) {
      if (regex.test(formattedSource) || condition && condition()) {
        return codec;
      }
    }
    return "";
  };
  const getCategoryFromSource = (source) => {
    if (!source) {
      return "";
    }
    const formattedSource = source.replace(/[.-]/g, "").toLowerCase();
    for (const [key, reg] of Object.entries(CONFIG.VIDEO_CATEGORY_MAP)) {
      if (reg.test(formattedSource)) {
        return key;
      }
    }
    return "";
  };
  const replaceRegSymbols = (string2) => {
    return string2.replace(/([*.?+$^[\](){}|\\/])/g, "\\$1");
  };
  class BaseExtractor {
    constructor() {
      this.info = {
        title: "",
        year: "",
        description: "",
        screenshots: [],
        category: "",
        videoType: "",
        format: "",
        source: "",
        videoCodec: "",
        audioCodec: "",
        resolution: "",
        area: "",
        doubanInfo: "",
        doubanUrl: "",
        imdbUrl: "",
        movieAkaName: "",
        comparisons: [],
        movieName: "",
        sourceSite: CURRENT_SITE_NAME,
        sourceSiteType: CURRENT_SITE_INFO == null ? void 0 : CURRENT_SITE_INFO.siteType,
        mediaInfos: [],
        tags: {},
        size: 0
      };
    }
    extractYear() {
      var _a2;
      const year = (_a2 = this.info.title.match(/(18|19|20)\d{2}/g)) != null ? _a2 : [];
      this.info.year = year.length > 0 ? year.pop() : "";
    }
    extractArea() {
      var _a2, _b, _c;
      const { area, description, doubanInfo } = this.info;
      if (!area) {
        const areaMatch = (_c = (_b = (_a2 = description + doubanInfo) == null ? void 0 : _a2.match(
          /(产\s*地|国\s*家|地\s*区)】?\s*(.+)/
        )) == null ? void 0 : _b[2]) != null ? _c : "";
        this.info.area = getAreaCode(areaMatch);
      }
    }
    extractMediaDetails() {
      const { mediaInfos, tags: tags2 } = this.info;
      if (!(mediaInfos == null ? void 0 : mediaInfos[0])) {
        return;
      }
      const mediaInfo = parseMedia(mediaInfos == null ? void 0 : mediaInfos[0], this.isVideoTypeBluray());
      if (!mediaInfo) {
        return;
      }
      const mediaDetail = extractDetailsFromMediaInfo(mediaInfo);
      if (!mediaDetail) {
        return;
      }
      this.info.videoCodec = mediaDetail.videoCodec;
      this.info.audioCodec = mediaDetail.audioCodec;
      this.info.resolution = mediaDetail.resolution;
      this.info.tags = __spreadValues(__spreadValues({}, tags2), getMediaTags(mediaDetail));
    }
    extractMediaInfos() {
      const { mediaInfo, bdInfo } = getBDInfoOrMediaInfoFromBBCode(
        this.info.description
      );
      this.info.mediaInfos = this.isVideoTypeBluray() ? bdInfo : mediaInfo;
    }
    extractResolution() {
      this.info.resolution = getResolutionFromSource(this.info.title);
    }
    isVideoTypeBluray() {
      return /bluray/i.test(this.info.videoType);
    }
    extractMetaInfo() {
      const { title, resolution } = this.info;
      const source = getVideoSourceFromTitle(title);
      const videoType = getVideoTypeFromSource(title, resolution);
      const tags2 = getTagsFromSource(title);
      const videoCodec = getVideoCodecFromSourceAndVideoType(title, videoType);
      const audioCodec = getAudioCodecFromSource(title);
      this.info = __spreadProps(__spreadValues({}, this.info), {
        source,
        videoType,
        tags: tags2,
        videoCodec,
        audioCodec
      });
    }
    async extractScreenshots() {
      const screenshots = await extractImgsFromBBCode(this.info.description);
      this.info.screenshots = screenshots;
    }
  }
  class NexusPHPExtractor extends BaseExtractor {
    constructor() {
      super(...arguments);
      this.priority = 10;
    }
    async extract() {
      this.extractTitle();
      this.extractSubtitle();
      this.extractYear();
      this.extractDoubanInfo();
      const descriptionResult = this.extractDescription();
      if (descriptionResult instanceof Promise) {
        await descriptionResult;
      }
      this.extractDoubanUrl();
      this.extractImdbUrl();
      await this.extractScreenshots();
      this.extractSource();
      this.extractMetaInfo();
      this.extractMediaInfos();
      this.extractMediaDetails();
      this.extractMovieNames();
      this.extractTags();
      this.determineIfIsForbidden();
      this.extractComparisonsScreenshots();
      this.extractArea();
      this.enhanceInfo();
      return this.info;
    }
    extractTitle() {
      var _a2, _b;
      const title = (_b = (_a2 = $$2("#top").text().split(/\s{3,}/)) == null ? void 0 : _a2[0]) == null ? void 0 : _b.trim();
      const formattedTitle = formatTorrentTitle(title);
      this.info.title = formattedTitle;
    }
    extractSubtitle() {
      this.info.subtitle = $$2(
        "td.rowhead:contains('副标题'), td.rowhead:contains('副標題')"
      ).next().text();
    }
    extractImdbUrl() {
      var _a2;
      const imdbUrl = $$2("#kimdb>a").attr("href") || ((_a2 = this.info.description.match(
        /http(s)?:\/\/www\.imdb\.com\/title\/tt\d+/
      )) == null ? void 0 : _a2[0]) || "";
      this.info.imdbUrl = imdbUrl;
    }
    extractDoubanUrl() {
      var _a2;
      const doubanUrl = (_a2 = this.info.description.match(
        /https:\/\/((movie|book)\.)?douban\.com\/subject\/\d+/
      )) == null ? void 0 : _a2[0];
      this.info.doubanUrl = doubanUrl;
    }
    extractDescription() {
      const bbCode = getFilterBBCode($$2("#kdescr")[0]);
      this.info.description = bbCode.replace(/\u00A0\u3000/g, " ");
    }
    extractSource() {
      this.info.source = getVideoSourceFromTitle(this.info.title);
    }
    extractTags() {
      var _a2;
      const tagsContentFromPage = $$2("td.rowhead:contains('标签')").next().text();
      this.info.tags = __spreadValues(__spreadValues({}, this.info.tags), getTagsFromSource(`${(_a2 = this.info) == null ? void 0 : _a2.subtitle}
${tagsContentFromPage}`));
    }
    extractMovieNames() {
      var _a2, _b, _c, _d, _e, _f, _g;
      const { description } = this.info;
      const originalName = (_b = (_a2 = description.match(/(片\s+名)\s+(.+)?/)) == null ? void 0 : _a2[2]) != null ? _b : "";
      const translateName = (_d = (_c = description.match(/(译\s+名)\s+(.+)/)) == null ? void 0 : _c[2]) != null ? _d : "";
      if (!originalName.match(/[\u4e00-\u9fa5]+/)) {
        this.info.movieName = originalName;
      } else {
        this.info.movieName = (_g = (_f = (_e = translateName.match(/(\w|\s){2,}/)) == null ? void 0 : _e[0]) == null ? void 0 : _f.trim()) != null ? _g : "";
      }
    }
    getMetaInfoRules() {
      return CONFIG.META_INFO_MATCH_RULES;
    }
    extractMetaInfo() {
      var _a2, _b, _c, _d, _e;
      const result = {
        category: "",
        videoType: "",
        videoCodec: "",
        audioCodec: "",
        resolution: "",
        area: "",
        size: ""
      };
      const metaInfo = $$2(
        "td.rowhead:contains('基本信息'), td.rowhead:contains('基本資訊'),.layui-table td:contains('基本信息')"
      ).next().text().replace(/：/g, ":");
      const rules = this.getMetaInfoRules();
      for (const [key, regex] of Object.entries(rules)) {
        const matchValue = (_b = (_a2 = metaInfo.match(regex)) == null ? void 0 : _a2[2]) != null ? _b : "";
        if (matchValue) {
          const value = (_e = (_d = (_c = matchValue == null ? void 0 : matchValue.replace(/\s/g, "")) == null ? void 0 : _c.trim()) == null ? void 0 : _d.toLowerCase()) != null ? _e : "";
          result[key] = value;
        }
      }
      console.log(result);
      const initialCategory = getCategoryFromSource(
        result.category || this.info.description
      );
      this.info.category = refineCategory(this.info, initialCategory);
      this.info.size = convertSizeStringToBytes(result.size);
      this.info.videoType = getVideoTypeFromSource(
        result.videoType || this.info.title
      );
      this.info.area = getAreaCode(result.area);
      if (!this.info.videoCodec) {
        this.info.videoCodec = getVideoCodecFromSourceAndVideoType(
          this.info.title || result.videoCodec,
          this.info.videoType
        );
      }
      if (!this.info.audioCodec) {
        this.info.audioCodec = getAudioCodecFromSource(
          result.audioCodec || this.info.title
        );
      }
      if (!this.info.resolution) {
        this.info.resolution = getResolutionFromSource(
          result.resolution || this.info.title
        );
      }
    }
    determineIfIsForbidden() {
      const { title, subtitle, description } = this.info;
      const combinedContent = title + subtitle + description;
      const isForbidden = CONFIG.FORBIDDEN_KEYWORDS.some(
        (keyword) => combinedContent.includes(keyword)
      );
      this.info.isForbidden = isForbidden;
    }
    extractDoubanInfo() {
    }
    enhanceInfo() {
    }
    extractComparisonsScreenshots() {
    }
  }
  class GenericNexusPHPExtractor extends NexusPHPExtractor {
    constructor() {
      super(...arguments);
      this.priority = 5;
    }
    canHandle(siteName, siteType) {
      return siteType === "NexusPHP";
    }
  }
  registry.register(new GenericNexusPHPExtractor());
  class PTerExtractor extends NexusPHPExtractor {
    constructor() {
      super(...arguments);
      this.priority = 10;
    }
    canHandle(siteName) {
      return siteName === "PTer";
    }
    extractDescription() {
      var _a2;
      let description;
      if ($$2("#descrcopyandpaster")[0]) {
        description = (_a2 = $$2("#descrcopyandpaster").val()) == null ? void 0 : _a2.replace(
          /hide(=(MediaInfo|BDInfo))?\]/gi,
          "quote]"
        );
      } else {
        description = getFilterBBCode($$2("#kdescr")[0]);
      }
      this.info.description = description.replace(/\[img\d\]/g, "[img]");
    }
    extractTags() {
      var _a2, _b;
      const tags2 = {};
      const tagImgs = $$2("td.rowhead:contains('类别与标签')").next().find("img");
      const links = Array.from(
        tagImgs.map((_2, item) => {
          var _a3, _b2;
          return (_b2 = (_a3 = $$2(item).attr("src")) == null ? void 0 : _a3.replace(/(lang\/chs\/)|(\.gif)/g, "")) != null ? _b2 : "";
        })
      );
      const tagRules = {
        chinese_subtitle: "pter-zz",
        chinese_audio: "pter-gy",
        cantonese_audio: "pter-yy",
        diy: "pter-diy"
      };
      for (const [tag, rule] of Object.entries(tagRules)) {
        tags2[tag] = links.includes(rule);
      }
      this.info.tags = __spreadValues(__spreadValues(__spreadValues({}, tags2), this.info.tags), getTagsFromSource((_b = (_a2 = this.info) == null ? void 0 : _a2.subtitle) != null ? _b : ""));
    }
    getMetaInfoRules() {
      return __spreadProps(__spreadValues({}, CONFIG.META_INFO_MATCH_RULES), {
        category: /(类型):\s*([^\s]+)?/i,
        area: /(地区):\s*([^\s]+)?/i
      });
    }
  }
  registry.register(new PTerExtractor());
  class SSDExtractor extends NexusPHPExtractor {
    constructor() {
      super(...arguments);
      this.priority = 10;
    }
    canHandle(siteName) {
      return siteName === "SSD";
    }
    extractTitle() {
      this.info.title = formatTorrentTitle($$2("#torrent-name").text());
    }
    extractDoubanUrl() {
      this.info.doubanUrl = $$2(
        ".douban_info a:contains('://movie.douban.com/subject/')"
      ).attr("href");
    }
    extractImdbUrl() {
      this.info.imdbUrl = $$2(
        ".douban_info a:contains('://www.imdb.com/title/')"
      ).attr("href");
    }
    extractDoubanInfo() {
      var _a2, _b, _c;
      const doubanInfo = getFilterBBCode((_a2 = $$2(".douban-info artical")) == null ? void 0 : _a2[0]);
      const postUrl = (_c = (_b = $$2("#kposter").find("img")) == null ? void 0 : _b.attr("src")) != null ? _c : "";
      const doubanPoster = postUrl ? `[img]${postUrl}[/img]
` : "";
      this.info.doubanInfo = doubanPoster + (doubanInfo == null ? void 0 : doubanInfo.replace(/\n{2,}/g, "\n")) || "";
    }
    extractDescription() {
      var _a2;
      let extraTextInfo = getFilterBBCode(
        (_a2 = $$2(".torrent-extra-text-container .extra-text")) == null ? void 0 : _a2[0]
      );
      extraTextInfo = extraTextInfo ? `
[quote]${extraTextInfo}[/quote]
` : "";
      const extraScreenshotDom = $$2(".screenshot").find("img");
      const imgs = [];
      if (extraScreenshotDom) {
        extraScreenshotDom.each((_2, item) => {
          var _a3, _b;
          imgs.push(`[img]${(_b = (_a3 = $$2(item).attr("src")) == null ? void 0 : _a3.trim()) != null ? _b : ""}[/img]`);
        });
      }
      const extraScreenshot = imgs.join("");
      const mediaInfo = $$2("section[data-group='mediainfo'] .codemain").text();
      this.info.mediaInfos = [mediaInfo];
      this.info.description = extraTextInfo + extraScreenshot;
    }
    getMetaInfoRules() {
      return __spreadProps(__spreadValues({}, CONFIG.META_INFO_MATCH_RULES), {
        resolution: /(分辨率|解析度):\s*([^\s]+)?/i,
        videoTypeKey: /(格式):\s*([^\s]+)?/i
      });
    }
  }
  registry.register(new SSDExtractor());
  class HDAExtractor extends NexusPHPExtractor {
    constructor() {
      super(...arguments);
      this.priority = 10;
    }
    canHandle(siteName) {
      return siteName === "HDArea";
    }
    extractTitle() {
      var _a2, _b;
      this.info.title = formatTorrentTitle(
        (_b = (_a2 = $$2("h1#top").text().split(/\s{3,}/)) == null ? void 0 : _a2[0]) == null ? void 0 : _b.trim()
      );
    }
  }
  registry.register(new HDAExtractor());
  class PuTaoExtractor extends NexusPHPExtractor {
    constructor() {
      super(...arguments);
      this.priority = 10;
    }
    canHandle(siteName) {
      return siteName === "PuTao";
    }
    extractTitle() {
      var _a2;
      this.info.title = formatTorrentTitle(
        (_a2 = $$2("h1").text().replace(/\[.+?\]|\(.+?\)/g, "")) == null ? void 0 : _a2.trim()
      );
    }
    getMetaInfoRules() {
      return __spreadProps(__spreadValues({}, CONFIG.META_INFO_MATCH_RULES), {
        category: /(类型):\s*([^\s]+)?/i
      });
    }
  }
  registry.register(new PuTaoExtractor());
  class TJUPTExtractor extends NexusPHPExtractor {
    constructor() {
      super(...arguments);
      this.priority = 10;
    }
    canHandle(siteName) {
      return siteName === "TJUPT";
    }
    extractTitle() {
      var _a2, _b, _c, _d;
      const title = formatTorrentTitle(
        (_b = (_a2 = $$2("#top").text().split(/\s{3,}/)) == null ? void 0 : _a2[0]) == null ? void 0 : _b.trim()
      );
      const matchArray = title.match(/\[[^\]]+(\.|\s)+[^\]]+\]/g) || [];
      const realTitle = (_d = (_c = matchArray.filter((item) => item.match(/\.| /))) == null ? void 0 : _c[0]) != null ? _d : "";
      this.info.title = realTitle.replace(/\[|\]/g, "");
    }
    getMetaInfoRules() {
      return __spreadProps(__spreadValues({}, CONFIG.META_INFO_MATCH_RULES), {
        category: /(类型):\s*([^\s|]+)?/i
      });
    }
  }
  registry.register(new TJUPTExtractor());
  class OurBitsExtractor extends NexusPHPExtractor {
    constructor() {
      super(...arguments);
      this.priority = 10;
    }
    canHandle(siteName) {
      return siteName === "OurBits";
    }
    extractDoubanUrl() {
      this.info.doubanUrl = $$2("#doubaninfo .doubannew a").attr("href");
    }
    extractImdbUrl() {
      this.info.imdbUrl = $$2(".imdbnew2 a:first").attr("href");
    }
    extractDoubanInfo() {
      var _a2;
      const doubanInfo = getFilterBBCode((_a2 = $$2(".doubannew2 .doubaninfo")) == null ? void 0 : _a2[0]);
      if (!doubanInfo) {
        return;
      }
      const doubanPoster = `[img]${$$2("#doubaninfo .doubannew a img").attr("src")}[/img]
`;
      this.info.doubanInfo = doubanPoster + doubanInfo;
    }
  }
  registry.register(new OurBitsExtractor());
  class FRDSExtractor extends NexusPHPExtractor {
    constructor() {
      super(...arguments);
      this.priority = 10;
    }
    canHandle(siteName) {
      return siteName === "KEEPFRDS";
    }
    extractTitle() {
      this.info.title = $$2("td.rowhead:contains('副标题')").next().text();
    }
    extractSubtitle() {
      var _a2, _b;
      this.info.subtitle = formatTorrentTitle(
        (_b = (_a2 = $$2("#top").text().split(/\s{3,}/)) == null ? void 0 : _a2[0]) == null ? void 0 : _b.trim()
      );
    }
    extractDoubanUrl() {
      this.info.doubanUrl = $$2("#kdouban .imdbwp__link").attr("href");
    }
    extractImdbUrl() {
      this.info.imdbUrl = $$2("#kimdb .imdbwp__link").attr("href");
    }
    extractMediaInfos() {
      const mediaInfoContent = $$2("div.codemain > pre:contains('Unique ID')");
      const result = [];
      if (mediaInfoContent.length > 0) {
        mediaInfoContent.each((_2, selector) => {
          result.push($$2(selector).text());
        });
        this.info.mediaInfos = result;
      }
    }
    extractDescription() {
      const element = document.createElement("div");
      $$2(element).html($$2("#outer td").has("#kdescr").html());
      let descriptionBBCode = getFilterBBCode(element);
      descriptionBBCode = descriptionBBCode.replace("  [url=", "\n  [url=").replace(/\[\/img\]\[\/url\]\n/g, "[/img][/url]");
      descriptionBBCode = descriptionBBCode.replace(
        / 截图对比\(点击空白处展开\)/g,
        "截图对比"
      );
      descriptionBBCode = descriptionBBCode.replace(
        /\[quote\]GeneralVideo[^[]*\[\/quote\]/,
        ""
      );
      this.info.description = descriptionBBCode;
    }
    enhanceInfo() {
      var _a2, _b;
      const { description, doubanUrl, imdbUrl } = this.info;
      if (!description.includes("豆瓣评分")) {
        const imdbRate = $$2("#kimdb span.imdbwp__rating").text().replace("\nRating: ", "");
        const doubanInfo = $$2("#kdouban .imdbwp__content").text().replace(/\n{2,}/g, "\n").replace(/\n[0-9]?[0-9]\.[0-9]\n/g, "\n").replace(/\n/g, "\n◎").replace(/\n◎$/, "\n").replace(
          "◎Rating:",
          `◎IMDb链接:${imdbUrl}
◎IMDb评分: ${imdbRate}
◎豆瓣链接: ${doubanUrl}
◎豆瓣评分:`
        );
        const postUrl = (_b = (_a2 = $$2("#kimdb img.imdbwp__img")) == null ? void 0 : _a2.attr("src")) != null ? _b : "";
        const doubanPoster = postUrl ? `[img]${postUrl}[/img]
` : "";
        this.info.doubanInfo = doubanPoster + doubanInfo || "";
      }
    }
    extractComparisonsScreenshots() {
      const comparisonArray = $$2("fieldset[onclick]").toArray() || [];
      const comparisons = [];
      comparisonArray.forEach((item) => {
        const imgs = [];
        $$2(item).find("a").toArray().forEach((img) => {
          if (img.href) imgs.push(img.href);
        });
        const title = $$2(item).find("legend").text().replace(" 截图对比(点击空白处展开):", "").trim();
        comparisons.push({
          title,
          imgs,
          reason: ""
        });
      });
      this.info.comparisons = comparisons;
    }
    async extractScreenshots() {
      this.info.screenshots = await extractImgsFromBBCode(
        this.info.description.replace(/\[quote\]截图对比[^\n]*\n[^\n]*/gi, "")
      );
    }
    getMetaInfoRules() {
      return __spreadProps(__spreadValues({}, CONFIG.META_INFO_MATCH_RULES), {
        videoType: /(encode):\s*([^\s]+)?/i,
        category: /(类型):\s*([^\s]+)?/i
      });
    }
  }
  registry.register(new FRDSExtractor());
  class TLFExtractor extends NexusPHPExtractor {
    constructor() {
      super(...arguments);
      this.priority = 10;
    }
    canHandle(siteName) {
      return siteName === "TLF";
    }
    getMetaInfoRules() {
      return __spreadProps(__spreadValues({}, CONFIG.META_INFO_MATCH_RULES), {
        category: /(类型):\s*([^\s]+)?/i,
        videoType: /(媒介):\s*([^\s]+)?/i
      });
    }
  }
  registry.register(new TLFExtractor());
  class HDHExtractor extends NexusPHPExtractor {
    constructor() {
      super(...arguments);
      this.priority = 10;
    }
    canHandle(siteName) {
      return siteName === "HDHome";
    }
    getMetaInfoRules() {
      return __spreadProps(__spreadValues({}, CONFIG.META_INFO_MATCH_RULES), {
        videoType: /(媒介):\s*([^\s]+)?/i
      });
    }
  }
  registry.register(new HDHExtractor());
  class HDFansExtractor extends NexusPHPExtractor {
    constructor() {
      super(...arguments);
      this.priority = 10;
    }
    canHandle(siteName) {
      return siteName === "HDFans";
    }
    getMetaInfoRules() {
      return __spreadProps(__spreadValues({}, CONFIG.META_INFO_MATCH_RULES), {
        videoType: /(媒介):(.+?)\\s{2,}?/i
      });
    }
  }
  registry.register(new HDFansExtractor());
  class SharedNexusSitesExtractor extends NexusPHPExtractor {
    constructor() {
      super(...arguments);
      this.priority = 10;
    }
    canHandle(siteName) {
      return /PTSBAO|PTHome|HDTime|BTSCHOOL|SoulVoice/.test(siteName);
    }
    getMetaInfoRules() {
      return __spreadProps(__spreadValues({}, CONFIG.META_INFO_MATCH_RULES), {
        category: /(类型):\s*([^\s]+)?/i
      });
    }
  }
  registry.register(new SharedNexusSitesExtractor());
  class TTGExtractor extends NexusPHPExtractor {
    constructor() {
      super(...arguments);
      this.priority = 10;
      this.headTitle = "";
    }
    canHandle(siteName) {
      return siteName === "TTG";
    }
    extractTitle() {
      var _a2, _b;
      const title = $$2("#main_table h1").eq(0).text();
      this.headTitle = title.replace(/^「.+?」/g, "");
      this.info.title = formatTorrentTitle(
        (_b = (_a2 = this.headTitle.match(/[^[]+/)) == null ? void 0 : _a2[0]) != null ? _b : ""
      );
    }
    extractSubtitle() {
      var _a2, _b, _c, _d;
      this.info.subtitle = (_d = (_c = (_b = (_a2 = this.headTitle) == null ? void 0 : _a2.replace(this.info.title, "")) == null ? void 0 : _b.replace(/\[|\]/g, "")) == null ? void 0 : _c.trim()) != null ? _d : "";
    }
    extractImdbUrl() {
      var _a2, _b;
      const imdbUrl = this.getHeadingTdDomsByKey("IMDb").find("a").attr("href");
      if (!imdbUrl) {
        this.info.imdbUrl = (_b = (_a2 = this.info.description.match(
          /https:\/\/www\.imdb\.com\/title\/tt\d+/
        )) == null ? void 0 : _a2[0]) != null ? _b : "";
      }
      this.info.imdbUrl = imdbUrl;
    }
    extractDoubanUrl() {
      var _a2, _b;
      this.info.doubanUrl = (_b = (_a2 = this.info.description.match(
        /https:\/\/(movie\.)?douban.com\/subject\/\d+/
      )) == null ? void 0 : _a2[0]) != null ? _b : "";
    }
    async extractDescription() {
      var _a2, _b, _c, _d;
      const pageContent = await GMFetch(location.href);
      const doc = new DOMParser().parseFromString(pageContent, "text/html");
      const descriptionContent = doc.querySelector("#kt_d");
      let description = getFilterBBCode(descriptionContent);
      const discountMatch = (_b = (_a2 = description.match(/\[color=\w+\]本种子.+?\[\/color\]/)) == null ? void 0 : _a2[0]) != null ? _b : "";
      if (discountMatch) {
        description = description.replace(discountMatch, "");
      }
      description = description.replace(/@\d+(\(\d+\))?/g, "");
      if (this.info.title.match(/-WiKi$/)) {
        const doubanPart = (_d = (_c = description.match(/◎译\s+名(.|\n)+/)) == null ? void 0 : _c[0]) != null ? _d : "";
        description = description.replace(doubanPart, "");
        description = description.replace(
          /(\[img\].+?\[\/img\])/,
          `$1

${doubanPart}`
        );
      }
      this.info.description = description;
    }
    extractMetaInfo() {
      var _a2, _b;
      const { description, title } = this.info;
      const mediaTecInfo = this.getHeadingTdDomsByKey("类型").text();
      this.info.area = getAreaCode(mediaTecInfo);
      const category = getCategoryFromSource(mediaTecInfo + description);
      this.info.category = refineCategory(this.info, category);
      this.info.videoType = getVideoTypeFromSource(mediaTecInfo + title);
      let audioCodec = getAudioCodecFromSource(title);
      if (description.match(/VIDEO(\.| )*CODEC/i)) {
        const matchCodec = (_a2 = description.match(
          /VIDEO(\.| )*CODEC\.*:?\s*([^\s_:]+)?/i
        )) == null ? void 0 : _a2[2];
        this.info.videoCodec = matchCodec ? matchCodec.replace(/\.|-/g, "").toLowerCase() : getVideoCodecFromSourceAndVideoType(title, this.info.videoType);
      }
      if (description.match(/AUDIO\s*CODEC/i)) {
        const matchCodec = (_b = description.match(/AUDIO\s*CODEC\.*:?\s*(.+)/i)) == null ? void 0 : _b[1];
        if (matchCodec) {
          audioCodec = getAudioCodecFromSource(matchCodec);
        }
      }
      this.info.audioCodec = audioCodec;
      this.info.resolution = getResolutionFromSource(title);
    }
    enhanceInfo() {
      var _a2, _b;
      const sizeMatch = (_b = (_a2 = this.getHeadingTdDomsByKey("尺寸").text().match(/\(((\d|,)+)\s*字节\)/i)) == null ? void 0 : _a2[1]) != null ? _b : "";
      this.info.size = parseInt(sizeMatch.replace(/,/g, ""), 10);
    }
    extractComparisonsScreenshots() {
      var _a2, _b, _c;
      const comparisonPart = (_a2 = this.info.description.match(
        /\.Comparisons(.|\n)+\[\/img\]\[\/url\]/
      )) == null ? void 0 : _a2[0];
      if (!comparisonPart) {
        return;
      }
      const title = (_c = (_b = comparisonPart.match(/(\[color=.+?\])(.+?)\[\/color\]/g)) == null ? void 0 : _b.map((item) => {
        var _a3, _b2;
        return (_b2 = (_a3 = item.match(/\[color=.+?\](.+?)\[\/color\]/)) == null ? void 0 : _a3[1]) != null ? _b2 : "";
      })) != null ? _c : [];
      const comparisonImgArray = [];
      const allImages = comparisonPart == null ? void 0 : comparisonPart.match(
        /(\[url=(http(s)*:\/{2}.+?)\])?\[img\](.+?)\[\/img](\[url\])?/g
      );
      if (allImages && allImages.length > 0) {
        allImages.forEach((img) => {
          var _a3;
          const matchUrl = (_a3 = img.match(/\[url=(.+?)\]/)) == null ? void 0 : _a3[1];
          if (matchUrl) {
            comparisonImgArray.push(matchUrl);
          }
        });
      }
      this.info.comparisons = [
        {
          imgs: comparisonImgArray,
          title: title.join(","),
          reason: ""
        }
      ];
    }
    async extractScreenshots() {
      var _a2, _b;
      const { description } = this.info;
      if (description.match(/More\.Screens/i)) {
        const moreScreen = (_b = (_a2 = description.match(
          /\.More\.Screens.*?\[\/u\]\[\/color\]\n((.|\n)+\[\/(url|img)\])/
        )) == null ? void 0 : _a2[1]) != null ? _b : "";
        this.info.screenshots = await extractImgsFromBBCode(moreScreen);
        return;
      }
      this.info.screenshots = await extractImgsFromBBCode(description);
    }
    getHeadingTdDomsByKey(key) {
      return $$2(`#main_table td.heading:contains(${key})`).next();
    }
  }
  registry.register(new TTGExtractor());
  class HanHanExtractor extends NexusPHPExtractor {
    constructor() {
      super(...arguments);
      this.priority = 10;
    }
    canHandle(siteName) {
      return siteName === "HH";
    }
    extractTitle() {
      var _a2;
      this.info.title = formatTorrentTitle(
        ((_a2 = document.title.match(/"(.+)"/)) == null ? void 0 : _a2[1]) || ""
      );
    }
    extractSubtitle() {
      this.info.subtitle = $$2("div.font-bold.leading-6:contains('副标题')").next().text().replace(/：/g, ":");
    }
    extractImdbUrl() {
      var _a2, _b;
      if (this.info.imdbUrl) return;
      this.info.imdbUrl = (_b = (_a2 = $$2('#kimdb a[href*="imdb.com/title"]')) == null ? void 0 : _a2.attr("href")) != null ? _b : "";
    }
    extractDoubanUrl() {
      var _a2;
      if (this.info.doubanUrl) return;
      this.info.doubanUrl = (_a2 = $$2("#douban_info-content").prev().find('a[href*="douban.com"]').attr("href")) != null ? _a2 : "";
    }
    extractMetaInfo() {
      if (this.info.category) return;
      const result = {};
      $$2("div.font-bold.leading-6:contains('基本信息')").next().find("div span").each((index, el) => {
        if (index % 2 === 0) {
          const key = $$2(el).text().replace(/:|：/g, "").trim();
          result[key] = $$2(el).next().text();
        }
      });
      const {
        类型: category,
        来源: videoType,
        编码: videoCodec,
        音频编码: audioCodec,
        分辨率: resolution,
        大小: size
      } = result;
      const initialCategory = getCategoryFromSource(category);
      this.info.category = refineCategory(this.info, initialCategory);
      this.info.videoType = getVideoTypeFromSource(videoType);
      this.info.videoCodec = getVideoCodecFromSourceAndVideoType(
        videoCodec,
        this.info.videoType
      );
      this.info.audioCodec = getAudioCodecFromSource(audioCodec);
      this.info.resolution = getResolutionFromSource(resolution);
      this.info.size = convertSizeStringToBytes(size);
    }
    extractTags() {
      var _a2;
      const tagsContentFromPage = $$2("div.font-bold.leading-6:contains('标签')").next().text();
      this.info.tags = __spreadValues(__spreadValues({}, this.info.tags), getTagsFromSource(`${(_a2 = this.info) == null ? void 0 : _a2.subtitle}
${tagsContentFromPage}`));
    }
    extractMediaInfos() {
      const mediaInfoContent = $$2("#mediainfo-raw code").text() || "";
      this.info.mediaInfos = [mediaInfoContent];
    }
    async extractScreenshots() {
      return new Promise((resolve28) => {
        const screenshots = $$2("#screenshot-content img").toArray().map((el) => {
          var _a2, _b;
          return (_b = (_a2 = $$2(el)) == null ? void 0 : _a2.attr("src")) != null ? _b : "";
        }).filter((url) => !!url);
        this.info.screenshots = screenshots;
        resolve28();
      });
    }
    extractMovieNames() {
      var _a2, _b;
      const IMDbLinkDom = $$2('#kimdb a[href*="imdb.com/title"]');
      const movieName = (_b = (_a2 = IMDbLinkDom == null ? void 0 : IMDbLinkDom.text()) == null ? void 0 : _a2.replace(/\n/g, "").trim()) != null ? _b : "";
      this.info.movieName = movieName;
    }
    extractPoster() {
      var _a2, _b;
      this.info.poster = (_b = (_a2 = $$2("#cover-content")) == null ? void 0 : _a2.attr("src")) != null ? _b : "";
    }
    async extractDescription() {
      var _a2, _b;
      this.extractDoubanUrl();
      this.extractImdbUrl();
      this.extractMetaInfo();
      const { category, doubanUrl, imdbUrl } = this.info;
      if (!doubanUrl) {
        return;
      }
      const isTV = /tv/i.test(category);
      const imdbId = (_b = (_a2 = imdbUrl == null ? void 0 : imdbUrl.match(/tt\d+/)) == null ? void 0 : _a2[0]) != null ? _b : "";
      const doubanInfo = await getDoubanInfoByIdOrDoubanUrl(
        doubanUrl,
        isTV ? "tv" : "movie",
        imdbId
      );
      if (doubanInfo) {
        this.info.doubanInfo = doubanInfo.format;
      }
    }
    enhanceInfo() {
      let { mediaInfos, screenshots, description } = this.info;
      if (mediaInfos == null ? void 0 : mediaInfos[0]) {
        description += `[quote]${mediaInfos[0]}[/quote]
`;
      }
      screenshots.forEach((url) => {
        description += `[img]${url}[/img]`;
      });
      this.info.description = description;
    }
  }
  registry.register(new HanHanExtractor());
  class MTExtractor extends BaseExtractor {
    constructor() {
      super(...arguments);
      this.priority = 10;
      this.torrentId = "";
    }
    canHandle(siteName) {
      return siteName === "MTeam";
    }
    extractTitle(title) {
      this.info.title = formatTorrentTitle(title);
    }
    extractMTResolution(standardId) {
      this.info.resolution = CONFIG.MT_SPECS_MAP.standard[standardId];
    }
    extractSource(sourceId) {
      let sourceName = CONFIG.MT_SPECS_MAP.source[sourceId];
      if (!sourceName) {
        sourceName = getVideoSourceFromTitle(this.info.title);
      } else if (sourceName === "bluray" && this.info.resolution === "2160p") {
        sourceName = "uhdbluray";
      }
      this.info.source = sourceName;
    }
    extractVideoType(mediumId) {
      const { resolution, title } = this.info;
      if (!mediumId) {
        this.info.videoType = getVideoTypeFromSource(title);
        return;
      }
      const videoType = CONFIG.MT_SPECS_MAP.medium[mediumId];
      if (videoType === "bluray" && resolution === "2160p") {
        return "uhdbluray";
      } else if (videoType === "dvd" && title.match(/dvdrip/i)) {
        return "dvdrip";
      }
      this.info.videoType = videoType;
    }
    extractCategory(categoryId) {
      const catMap = PT_SITE.MTeam.category.map;
      for (const [key, value] of Object.entries(catMap)) {
        if (value.includes(categoryId)) {
          this.info.category = key;
        }
      }
    }
    extractCodec() {
      const { title, videoType } = this.info;
      this.info.videoCodec = getVideoCodecFromSourceAndVideoType(
        title,
        videoType
      );
      this.info.audioCodec = getAudioCodecFromSource(title);
    }
    async extractScreenshots() {
      this.info.screenshots = await extractImgsFromBBCode(this.info.description);
    }
    extractMediaDetails() {
      var _a2, _b;
      if (!((_a2 = this.info.mediaInfos) == null ? void 0 : _a2[0])) {
        return;
      }
      const mediaInfo = parseMedia(
        (_b = this.info.mediaInfos) == null ? void 0 : _b[0],
        this.isVideoTypeBluray()
      );
      if (!mediaInfo) {
        return;
      }
      const mediaDetail = extractDetailsFromMediaInfo(mediaInfo);
      if (!mediaDetail) {
        return;
      }
      this.info.videoCodec = mediaDetail.videoCodec;
      this.info.audioCodec = mediaDetail.audioCodec;
      this.info.resolution = mediaDetail.resolution;
      this.info.tags = getMediaTags(mediaDetail);
    }
    extractDescription(descr) {
      this.info.description = descr.replace(/!\[\]\((.+?)\)/g, "[img]$1[/img]");
    }
    isVideoTypeBluray() {
      return /bluray/i.test(this.info.videoType);
    }
    getMovieInfo(data) {
      const { year, title, photo } = data;
      this.info.year = year;
      this.info.movieName = title;
      this.info.poster = photo.full || photo.thumb;
    }
    setRequestHeaders() {
      const version = CONFIG.MT_REQUEST_VERSION;
      const webVersion = `${version.replace(/\./g, "")}0`;
      const ts = `${Math.floor(Date.now() / 1e3)}`;
      const auth = localStorage.getItem("auth") || "";
      const visitorId = localStorage.getItem("visitorId") || "";
      const dId = localStorage.getItem("did") || "";
      return {
        Authorization: auth,
        "User-Agent": navigator.userAgent,
        Did: dId,
        Visitorid: visitorId,
        ts,
        version,
        webVersion
      };
    }
    async getIMDbDataFromAPI() {
      const { imdbUrl } = this.info;
      const formdata = createFormData({
        code: imdbUrl
      });
      const res = await GMFetch(`${CONFIG.MT_BASE_API_URL}/torrent/imdbInfo`, {
        data: formdata,
        method: "POST",
        responseType: "json",
        headers: this.setRequestHeaders()
      });
      if (res.code !== "0") {
        throw new Error(res.message);
      }
      return res.data;
    }
    async getTorrentURLFormAPI() {
      const res = await GMFetch(`${CONFIG.MT_BASE_API_URL}/torrent/genDlToken`, {
        method: "POST",
        data: createFormData({
          id: this.torrentId
        }),
        responseType: "json",
        headers: this.setRequestHeaders()
      });
      if (res.code === "0") {
        CURRENT_SITE_INFO.torrentLink = res.data;
      }
    }
    async getTorrentDetailFromAPI() {
      const formdata = createFormData({
        id: this.torrentId
      });
      const res = await GMFetch(`${CONFIG.MT_BASE_API_URL}/torrent/detail`, {
        data: formdata,
        method: "POST",
        responseType: "json",
        headers: this.setRequestHeaders()
      });
      if (res.code !== "0") {
        throw new Error(res.message);
      }
      return res.data;
    }
    async extract() {
      var _a2;
      const torrentId = (_a2 = location.pathname.match(/detail\/(\d+)/)) == null ? void 0 : _a2[1];
      if (!torrentId) {
        return this.info;
      }
      this.torrentId = torrentId;
      const torrentDetail = await this.getTorrentDetailFromAPI();
      const {
        name,
        imdb,
        douban,
        category,
        source,
        medium,
        standard,
        size,
        mediainfo,
        descr,
        smallDescr
      } = torrentDetail;
      this.extractTitle(name);
      this.extractYear();
      this.extractMTResolution(standard);
      this.extractDescription(descr);
      this.extractSource(source);
      this.extractVideoType(medium);
      this.extractCodec();
      this.extractCategory(category);
      this.info.subtitle = smallDescr;
      this.info.size = parseInt(size, 10);
      if (imdb) {
        this.info.imdbUrl = imdb;
        const imdbData = await this.getIMDbDataFromAPI();
        this.getMovieInfo(imdbData);
      }
      this.info.doubanUrl = douban;
      this.extractScreenshots();
      this.info.mediaInfos = [mediainfo];
      this.extractMediaDetails();
      this.extractArea();
      await this.getTorrentURLFormAPI();
      return this.info;
    }
  }
  registry.register(new MTExtractor());
  class GazelleExtractor extends BaseExtractor {
    constructor() {
      super(...arguments);
      this.priority = 5;
      this.torrentId = "";
      this.torrentHeaderDom = $$2();
      this.getSource = (source, codes, resolution) => {
        if (codes.match(/BD100|BD66/i)) {
          return "uhdbluray";
        }
        if (source.match(/Blu-ray/i) && resolution.match(/2160P|4K/i)) {
          return "uhdbluray";
        }
        return source.replace(/-/g, "").toLowerCase();
      };
    }
    async extract() {
      return this.info;
    }
    extractTorrentId() {
      const torrentId = getLocationSearchValueByKey("torrentid");
      this.torrentId = torrentId;
    }
    getTorrentHeaderDom() {
    }
    extractMovieNames() {
    }
    extractMediaInfos() {
    }
    extractYear() {
    }
    extractTorrentLink() {
      const torrentLink = this.torrentHeaderDom.find('a[title="Download"]').attr("href");
      CURRENT_SITE_INFO.torrentLink = torrentLink;
    }
    extractImdbUrl() {
    }
    extractCategory() {
    }
    extractComparisonsScreenshots() {
    }
    extractMetaInfo() {
    }
    extractTags() {
    }
    extractTitle() {
    }
    extractSize() {
    }
    extractArea() {
    }
    extractIsHardcodedSub() {
    }
    extractPoster() {
    }
    enhanceInfo() {
    }
  }
  class PTPExtractor extends GazelleExtractor {
    constructor() {
      super(...arguments);
      this.priority = 10;
      this.tags = [];
      this.getVideoType = (container, isRemux, codes, source) => {
        let type = "";
        if (isRemux) {
          type = "remux";
        } else if (codes.match(/BD50|BD25/gi)) {
          type = "bluray";
        } else if (codes == null ? void 0 : codes.match(/BD66|BD100/gi)) {
          type = "uhdbluray";
        } else if (source.match(/DVD/gi) && container.match(/MKV|AVI/gi)) {
          type = "dvdrip";
        } else if (codes.match(/DVD5|DVD9/gi) && container.match(/VOB|ISO/gi)) {
          type = "dvd";
        } else if (container.match(/MKV|MP4/i)) {
          type = "encode";
        }
        return type;
      };
    }
    canHandle(siteName) {
      return siteName === "PTP";
    }
    async extract() {
      this.extractTorrentId();
      if (!this.torrentId) {
        return this.info;
      }
      this.getTorrentHeaderDom();
      this.extractMediaInfos();
      this.extractMovieNames();
      this.extractYear();
      this.extractTorrentLink();
      this.extractImdbUrl();
      this.extractScreenshotsForPTP();
      this.extractCategory();
      await this.extractDescription();
      this.extractComparisonsScreenshots();
      this.extractMetaInfo();
      this.extractMediaDetails();
      this.extractSize();
      this.extractPoster();
      this.extractTitle();
      this.extractArea();
      this.extractIsHardcodedSub();
      this.enhanceInfo();
      this.extractTags();
      return this.info;
    }
    getTorrentHeaderDom() {
      this.torrentHeaderDom = $$2(`#group_torrent_header_${this.torrentId}`);
    }
    extractMovieNames() {
      var _a2, _b, _c, _d;
      const ptpMovieTitle = (_d = (_c = (_b = (_a2 = $$2(".page__title").text()) == null ? void 0 : _a2.replace(/\[.+?\]/g, "")) == null ? void 0 : _b.replace(/by.+/, "")) == null ? void 0 : _c.trim()) != null ? _d : "";
      const [movieName, movieAkaName = ""] = ptpMovieTitle.split(" AKA ");
      this.info.movieAkaName = movieAkaName;
      this.info.movieName = movieName;
    }
    extractMediaInfos() {
      const mediaInfoArray = [];
      $$2(`#torrent_${this.torrentId}`).find(".mediainfo.mediainfo--in-release-description").next("blockquote").each(function() {
        const textContent = $$2(this).text();
        if (textContent.match(/(Codec\s*ID)|mpls|(Stream\s*size)|Video/i)) {
          mediaInfoArray.push(textContent);
        }
      });
      this.info.mediaInfos = mediaInfoArray;
    }
    extractYear() {
      var _a2, _b;
      this.info.year = (_b = (_a2 = $$2(".page__title").text().match(/\[(\d+)\]/)) == null ? void 0 : _a2[1]) != null ? _b : "";
    }
    extractTorrentLink() {
      const torrentHeaderDom = $$2(`#group_torrent_header_${this.torrentId}`);
      const torrentLink = torrentHeaderDom.find('a[title="Download"]').attr("href");
      CURRENT_SITE_INFO.torrentLink = torrentLink;
    }
    extractImdbUrl() {
      var _a2, _b;
      this.info.imdbUrl = (_b = (_a2 = $$2("#imdb-title-link")) == null ? void 0 : _a2.attr("href")) != null ? _b : "";
    }
    extractScreenshotsForPTP() {
      var _a2;
      const imgList = [];
      const torrentInfoPanel = $$2(".movie-page__torrent__panel");
      const imageDom = torrentInfoPanel.find(".bbcode__image");
      for (let i = 0; i < imageDom.length; i++) {
        const parent = imageDom[i].parentElement;
        if ((parent == null ? void 0 : parent.tagName) === "A" && ((_a2 = parent == null ? void 0 : parent.getAttribute("href")) == null ? void 0 : _a2.match(/\.png$/))) {
          imgList.push(parent.getAttribute("href") || "");
        } else {
          const imgDom = imageDom[i];
          const imgSrc = imgDom.getAttribute("src") || imgDom.getAttribute("alt");
          imgList.push(imgSrc || "");
        }
      }
      this.info.screenshots = imgList;
    }
    extractCategory() {
      const typeMap = {
        "Feature Film": "movie",
        "Short Film": "movie",
        "Stand-up Comedy": "other",
        Miniseries: "tvPack",
        "Live Performance": "concert",
        "Movie Collection": "movie"
      };
      const ptpType = $$2("#torrent-table .basic-movie-list__torrent-edition__main").eq(0).text();
      this.info.category = typeMap[ptpType] || "unknown";
    }
    formateDescription(description, screenshots, mediaInfoArray) {
      let descriptionData = description.replace(/\r\n/g, "\n");
      descriptionData = descriptionData.split("\n").map((line) => {
        return line.trim();
      }).join("\n").replace(/http:\/\/ptpimg.me/g, "https://ptpimg.me");
      const originalDescription = descriptionData;
      screenshots.forEach((screenshot) => {
        const regStr = new RegExp(`\\[img${screenshot}\\[\\/img\\]`, "i");
        if (!descriptionData.match(regStr)) {
          const regLegacyFormat = new RegExp(`\\[img=${screenshot}\\]`, "i");
          if (descriptionData.match(regLegacyFormat)) {
            descriptionData = descriptionData.replace(
              regLegacyFormat,
              `[img]${screenshot}[/img]`
            );
          } else {
            descriptionData = descriptionData.replace(
              new RegExp(`(?<!\\[img\\])${screenshot}`, "ig"),
              `[img]${screenshot}[/img]`
            );
          }
        }
      });
      descriptionData = descriptionData.replace(
        /\[(\/)?mediainfo\]/g,
        "[$1quote]"
      );
      descriptionData = descriptionData.replace(
        /\[(\/)?hide(?:=(.+?))?\]/g,
        (match, p1, p2) => {
          const slash = p1 || "";
          return p2 ? `${p2}: [${slash}quote]` : `[${slash}quote]`;
        }
      );
      descriptionData = descriptionData.replace(/\[(\/)?pre\]/g, "[$1quote]");
      descriptionData = descriptionData.replace(
        /\[align(=(.+?))\]((.|\n)+?)\[\/align\]/g,
        "[quote][$2]$3[/$2][/quote]"
      );
      mediaInfoArray.forEach((mediaInfo) => {
        const regStr = new RegExp(
          `\\[quote\\]\\s*?${replaceRegSymbols(mediaInfo).slice(0, 1e4)}`,
          "i"
        );
        if (!descriptionData.match(regStr)) {
          descriptionData = descriptionData.replace(
            mediaInfo,
            `[quote]${mediaInfo}[/quote]`
          );
        }
      });
      if (this.info.category === "concert") {
        descriptionData = `${$$2("#synopsis").text()}
${descriptionData}`;
      }
      return {
        originalDescription,
        descriptionData
      };
    }
    getReleaseGroup(source) {
      var _a2, _b;
      return (_b = (_a2 = source.match(/-(\w+?)$/)) == null ? void 0 : _a2[1]) != null ? _b : "";
    }
    async getDescriptionFromAPI(id) {
      const url = `${PT_SITE.PTP.url}/torrents.php?action=get_description&id=${id}`;
      const data = await GMFetch(url);
      if (data) {
        const element = document.createElement("span");
        element.innerHTML = data;
        return element.innerText || element.textContent || "";
      }
      return "";
    }
    async extractDescription() {
      const { screenshots, mediaInfos } = this.info;
      const description = await this.getDescriptionFromAPI(this.torrentId);
      const { originalDescription, descriptionData } = this.formateDescription(
        description,
        screenshots,
        mediaInfos
      );
      this.info.description = descriptionData;
      this.info.originalDescription = originalDescription;
    }
    extractComparisonsScreenshots() {
      let { description } = this.info;
      const comparisonArray = description.match(
        /(\n.+\n)?\[comparison=(?:.+?)\]((.|\n)+?)\[\/comparison\]/gi
      ) || [];
      const comparisons = [];
      comparisonArray.forEach((item) => {
        var _a2, _b, _c, _d;
        description = description.replace(item, item.replace(/\s/g, ""));
        const reason = (_b = (_a2 = item.match(/(\n.*\n)?\[comparison=/i)) == null ? void 0 : _a2[1]) != null ? _b : "";
        const title = (_d = (_c = item.match(/\[comparison=(.*?)\]/i)) == null ? void 0 : _c[1]) != null ? _d : "";
        const comparisonImgArray = item.replace(/\[\/?comparison(=(.+?))?\]/gi, "").split(/[ \r\n]/);
        const imgs = [];
        Array.from(new Set(comparisonImgArray)).forEach((item2) => {
          const formatImg = item2.replace(/\s*/g, "");
          if (item2.match(/^https?.+/)) {
            imgs.push(formatImg);
            description = description.replace(
              new RegExp(`(?<!(\\[img\\]))${item2}`, "gi"),
              `[img]${formatImg}[/img]`
            );
          } else if (item2.match(/^\[img\]/i)) {
            imgs.push(formatImg.replace(/\[\/?img\]/g, ""));
          }
        });
        comparisons.push({
          title,
          imgs,
          reason
        });
      });
      this.info.comparisons = comparisons;
      this.info.description = description.replace(/\[comparison=(.+?)\]/gi, "\n[b]$1 Comparison:[/b]\n").replace(/\[\/comparison\]/gi, "");
    }
    extractMetaInfo() {
      const infoArray = this.torrentHeaderDom.find("#PermaLinkedTorrentToggler").text().trim().split(" / ");
      const [codes, container, source, resolution, ...otherInfo] = infoArray;
      const isRemux = otherInfo.includes("Remux");
      this.info.videoType = source === "WEB" ? "web" : this.getVideoType(container, isRemux, codes, source);
      this.info.resolution = resolution;
      this.info.source = this.getSource(source, codes, resolution);
      this.tags = otherInfo;
    }
    extractTags() {
      const releaseName = this.torrentHeaderDom.data("releasename");
      const releaseGroup = this.getReleaseGroup(releaseName);
      const { editionTags } = PT_SITE.PTP.sourceInfo;
      const knownTags = {};
      const otherTags = {};
      for (const rawTag of this.tags) {
        const tag = editionTags[rawTag];
        if (tag) {
          knownTags[tag] = true;
        } else if (tag === null || releaseGroup.includes(rawTag) || rawTag.match(/Freeleech|Halfleech|Half-Leech/i)) ;
        else {
          otherTags[rawTag] = true;
        }
      }
      this.info.tags = __spreadValues({}, knownTags);
      this.info.otherTags = otherTags;
    }
    extractTitle() {
      const releaseName = this.torrentHeaderDom.data("releasename");
      const formattedTitle = formatTorrentTitle(releaseName);
      this.info.title = formattedTitle;
    }
    extractSize() {
      var _a2, _b;
      const size = (_b = (_a2 = this.torrentHeaderDom.find(".nobr span").attr("title")) == null ? void 0 : _a2.replace(/[^\d]/g, "")) != null ? _b : "";
      this.info.size = convertSizeStringToBytes(size);
    }
    extractArea() {
      let country = [];
      const matchArray = $$2("#movieinfo div").text().match(/Country:\s+([^\n]+)/);
      if (matchArray && matchArray.length > 0) {
        country = matchArray == null ? void 0 : matchArray[1].replace(/(,)\s+/g, "$1").split(",");
      }
      this.info.area = getAreaCode(country == null ? void 0 : country[0]);
    }
    extractIsHardcodedSub() {
      const trumpReason = $$2(`#trumpable_${this.torrentId} span`).text() || "";
      this.info.hardcodedSub = trumpReason.includes("Hardcoded Subtitles");
    }
    extractPoster() {
      this.info.poster = $$2(".sidebar-cover-image").attr("src") || "";
    }
  }
  registry.register(new PTPExtractor());
  class UHDExtractor extends GazelleExtractor {
    constructor() {
      super(...arguments);
      this.priority = 10;
      this.titleText = "";
    }
    canHandle(siteName) {
      return siteName === "UHDBits";
    }
    async extract() {
      this.extractTorrentId();
      if (!this.torrentId) {
        return this.info;
      }
      this.getTorrentHeaderDom();
      this.extractTitle();
      await this.extractMediaInfos();
      this.extractMovieNames();
      this.extractYear();
      this.extractImdbUrl();
      this.extractTorrentLink();
      await this.extractMediaInfos();
      await this.extractDescription();
      await this.extractScreenshots();
      this.extractMetaInfo();
      this.extractTags();
      this.extractMediaDetails();
      return this.info;
    }
    getTorrentHeaderDom() {
      this.torrentHeaderDom = $$2(`#torrent${this.torrentId}`);
    }
    extractTitle() {
      var _a2, _b;
      const torrentFilePathDom = $$2(`#files_${this.torrentId} .filelist_path`);
      const torrentFileDom = $$2(
        `#files_${this.torrentId} .filelist_table>tbody>tr:nth-child(2) td`
      ).eq(0);
      const torrentFileName = ((_a2 = torrentFilePathDom.text()) == null ? void 0 : _a2.replace(/\//g, "")) || ((_b = torrentFileDom.text()) == null ? void 0 : _b.replace(/\.(mkv|mp4|avi|mpg|ts|iso)$/i, ""));
      this.info.title = formatTorrentTitle(torrentFileName);
    }
    async extractMediaInfos() {
      const url = `/torrents.php?action=mediainfo&id=${this.torrentId}`;
      const data = await GMFetch(url);
      if (data) {
        this.info.mediaInfos = [data];
      }
    }
    extractMovieNames() {
      var _a2, _b;
      const titleText = $$2("#scontent h2").text();
      this.titleText = titleText;
      const [movieName = "", movieAkaName = ""] = (_b = (_a2 = titleText.match(/(.+?)\[/)) == null ? void 0 : _a2[1].split("/")) != null ? _b : [];
      this.info.movieAkaName = movieAkaName.trim();
      this.info.movieName = movieName.trim();
    }
    extractYear() {
      var _a2, _b;
      this.info.year = (_b = (_a2 = this.titleText.match(/\[(\d+)\]/)) == null ? void 0 : _a2[1]) != null ? _b : "";
    }
    extractImdbUrl() {
      this.info.imdbUrl = $$2(".imovie_title .tooltip.imdb_icon").attr("href") || "";
    }
    extractTorrentLink() {
      const torrentLink = this.torrentHeaderDom.find('a[href*="action=download"]').attr("href");
      CURRENT_SITE_INFO.torrentLink = torrentLink;
    }
    async extractDescription() {
      return new Promise((resolve28) => {
        this.getTorrentHeaderDom();
        const descriptionDom = $$2(`#torrent_${this.torrentId} #description`);
        let descriptionBBCode = getFilterBBCode(descriptionDom[0]);
        descriptionBBCode = descriptionBBCode.replace(
          /https?:\/\/anonym\.to\/\?/g,
          ""
        );
        this.info.description = `${descriptionBBCode}
[quote]${this.info.mediaInfos[0]}[/quote]`;
        this.info.originalDescription = descriptionBBCode;
        resolve28();
      });
    }
    async extractScreenshots() {
      this.info.screenshots = await extractImgsFromBBCode(this.info.description);
    }
    extractMetaInfo() {
      const { title } = this.info;
      const tags2 = getTagsFromSource(title);
      const source = getVideoSourceFromTitle(title);
      const category = title.match(/Season\s+\d+/) ? "tv" : "movie";
      const size = convertSizeStringToBytes(
        $$2(`#torrent${this.torrentId} td`).eq(1).text()
      );
      const infoArray = $$2(`#torrent${this.torrentId} td:first-child>a`).text().replace(/\s/g, "").split("/");
      const [resolution] = infoArray;
      const videoType = getVideoTypeFromSource(title);
      this.info.videoType = videoType;
      this.info.resolution = resolution;
      this.info.videoCodec = getVideoCodecFromSourceAndVideoType(title);
      this.info.audioCodec = getAudioCodecFromSource(title);
      this.info.tags = tags2;
      this.info.source = source;
      this.info.size = size;
      this.info.category = refineCategory(this.info, category);
    }
  }
  registry.register(new UHDExtractor());
  class GPWExtractor extends GazelleExtractor {
    constructor() {
      super(...arguments);
      this.priority = 10;
      this._siteTorrentInfo = null;
      this._siteGroupInfo = null;
      this.tags = [];
    }
    get siteGroupInfo() {
      if (!this._siteGroupInfo) {
        throw new Error("siteGroupInfo is not initialized");
      }
      return this._siteGroupInfo;
    }
    get siteTorrentInfo() {
      if (!this._siteTorrentInfo) {
        throw new Error("siteTorrentInfo is not initialized");
      }
      return this._siteTorrentInfo;
    }
    async extract() {
      this.extractTorrentId();
      this.getTorrentHeaderDom();
      const data = await this.getSiteTorrentInfoByAPI();
      if (!data) {
        return this.info;
      }
      this._siteTorrentInfo = data.torrent;
      this._siteGroupInfo = data.group;
      this.extractTitle();
      this.extractMovieNames();
      this.extractMediaInfos();
      this.extractArea();
      this.extractDoubanUrl();
      this.extractImdbUrl();
      this.extractScreenshotsForGPW();
      this.extractCategory();
      this.extractMetaInfo();
      this.extractDescription();
      this.extractComparisonsScreenshots();
      this.extractTags();
      this.extractIsHardcodedSub();
      this.extractMediaDetails();
      const { size } = this.siteTorrentInfo;
      const { name, year, conver: poster } = this.siteGroupInfo;
      this.info.size = size;
      this.info.movieName = name;
      this.info.year = year;
      this.info.poster = poster;
      return this.info;
    }
    canHandle(siteName) {
      return siteName === "GPW";
    }
    async getSiteTorrentInfoByAPI() {
      const { status, response } = await GMFetch(
        `/ajax.php?action=torrent&id=${this.torrentId}`,
        {
          responseType: "json"
        }
      );
      if (status !== "success" || !response || !response.group || !response.torrent) {
        return null;
      }
      return response;
    }
    getTorrentHeaderDom() {
      this.torrentHeaderDom = $$2(`#torrent${this.torrentId}`);
    }
    extractTitle() {
      let { fileList, filePath } = this.siteTorrentInfo;
      fileList = fileList.replace(/\.\w+?{{{\d+}}}/g, "");
      const title = formatTorrentTitle(
        filePath.replace(/\[.+\]/g, "") || fileList
      );
      this.info.title = title;
    }
    extractMediaInfos() {
      this.info.mediaInfos = this.siteTorrentInfo.mediainfos.map(
        (info) => info.replace(/\r\n/g, "\n")
      );
    }
    extractTorrentLink() {
      const torrentLink = this.torrentHeaderDom.find('a[href*="action=download"]').attr("href");
      CURRENT_SITE_INFO.torrentLink = torrentLink;
    }
    extractImdbUrl() {
      const { imdbId } = this.siteGroupInfo;
      this.info.imdbUrl = imdbId ? `https://www.imdb.com/title/${imdbId}` : "";
    }
    extractDoubanUrl() {
      const { doubanId } = this.siteGroupInfo;
      this.info.doubanUrl = doubanId ? `https://movie.douban.com/subject/${doubanId}` : "";
    }
    extractScreenshotsForGPW() {
      var _a2;
      const imgList = [];
      const imageDom = this.torrentHeaderDom.next(".TableTorrent-rowDetail").find(".scale_image");
      for (let i = 0; i < imageDom.length; i++) {
        const parent = imageDom[i].parentElement;
        if ((parent == null ? void 0 : parent.tagName) === "A" && ((_a2 = parent == null ? void 0 : parent.getAttribute("href")) == null ? void 0 : _a2.match(/\.png$/))) {
          imgList.push(parent.getAttribute("href") || "");
        } else {
          imgList.push(
            imageDom[i].getAttribute("src") || ""
          );
        }
      }
      this.info.screenshots = imgList;
    }
    extractCategory() {
      const { releaseType } = this.siteGroupInfo;
      const typeMap = {
        长片: "movie",
        短片: "movie",
        单口喜剧: "other",
        迷你剧: "tvPack",
        现场演出: "concert",
        电影集: "movie"
      };
      this.info.category = typeMap[releaseType] || "unknown";
    }
    formateDescription(description, screenshots, mediaInfoArray) {
      const element = document.createElement("span");
      element.innerHTML = description;
      let descriptionData = element.textContent || "";
      descriptionData = descriptionData == null ? void 0 : descriptionData.replace(/\r\n/g, "\n");
      descriptionData = descriptionData.split("\n").map((line) => {
        return line.trim();
      }).join("\n");
      const originalDescription = descriptionData;
      screenshots.forEach((screenshot) => {
        const regStr = new RegExp(`\\[img\\]${screenshot}\\[\\/img\\]`, "i");
        if (!descriptionData.match(regStr)) {
          descriptionData = descriptionData.replace(
            new RegExp(screenshot, "g"),
            `[img]${screenshot}[/img]`
          );
        }
      });
      descriptionData = descriptionData.replace(
        /\[(\/)?hide(?:=(.+?))?\]/g,
        (match, p1, p2) => {
          const slash = p1 || "";
          return p2 ? `${p2}: [${slash}quote]` : `[${slash}quote]`;
        }
      );
      descriptionData = descriptionData.replace(/\[(\/)?pre\]/g, "[$1quote]");
      descriptionData = descriptionData.replace(
        /\[align(=(.+?))\]((.|\n)+?)\[\/align\]/g,
        "[$2]$3[/$2]"
      );
      mediaInfoArray.forEach((mediaInfo) => {
        descriptionData += `[quote]${mediaInfo}[/quote]`;
      });
      if (this.info.category === "concert") {
        descriptionData = `${$$2("#synopsis").text()}
${descriptionData}`;
      }
      return {
        originalDescription,
        descriptionData
      };
    }
    getReleaseGroup(source) {
      var _a2, _b;
      return (_b = (_a2 = source.match(/-(\w+?)$/)) == null ? void 0 : _a2[1]) != null ? _b : "";
    }
    async extractDescription() {
      const { screenshots, mediaInfos } = this.info;
      const { description } = this.siteTorrentInfo;
      const { originalDescription, descriptionData } = this.formateDescription(
        description,
        screenshots,
        mediaInfos
      );
      this.info.description = descriptionData;
      this.info.originalDescription = originalDescription;
    }
    extractComparisonsScreenshots() {
      let { description } = this.info;
      const comparisonArray = description.match(
        /(\n.+\n)?\[comparison=(?:.+?)\]((.|\n)+?)\[\/comparison\]/gi
      ) || [];
      const comparisons = [];
      comparisonArray.forEach((item) => {
        var _a2, _b, _c, _d;
        description = description.replace(item, item.replace(/\s/g, ""));
        const reason = (_b = (_a2 = item.match(/(\n.*\n)?\[comparison=/i)) == null ? void 0 : _a2[1]) != null ? _b : "";
        const title = (_d = (_c = item.match(/\[comparison=(.*?)\]/i)) == null ? void 0 : _c[1]) != null ? _d : "";
        const comparisonImgArray = item.replace(/\[\/?comparison(=(.+?))?\]/gi, "").split(/[ \r\n]/);
        const imgs = [];
        Array.from(new Set(comparisonImgArray)).forEach((item2) => {
          const formatImg = item2.replace(/\s*/g, "");
          if (item2.match(/^https?.+/)) {
            imgs.push(formatImg);
            description = description.replace(
              new RegExp(`(?<!(\\[img\\]))${item2}`, "gi"),
              `[img]${formatImg}[/img]`
            );
          } else if (item2.match(/^\[img\]/i)) {
            imgs.push(formatImg.replace(/\[\/?img\]/g, ""));
          }
        });
        comparisons.push({
          title,
          imgs,
          reason
        });
      });
      this.info.comparisons = comparisons;
      this.info.description = description.replace(/\[comparison=(.+?)\]/gi, "\n[b]$1 Comparison:[/b]\n").replace(/\[\/comparison\]/gi, "");
    }
    extractMetaInfo() {
      const { source, resolution, processing, container, remasterTitle } = this.siteTorrentInfo;
      const infoArray = remasterTitle.split(" / ");
      const isRemux = processing.includes("Remux");
      this.info.videoType = source === "WEB" ? "web" : this.getVideoType(container, isRemux, source, resolution, processing);
      this.info.source = this.getSource(source, processing, resolution);
      this.tags = infoArray.filter(Boolean);
    }
    getVideoType(container, isRemux, source, resolution, processing) {
      if (isRemux) {
        return "remux";
      } else if (processing.match(/DIY/gi)) {
        return resolution === "2160p" ? "uhdbluray" : "bluray";
      } else if (processing.match(/BD50|BD25/gi)) {
        return "bluray";
      } else if (processing.match(/BD66|BD100/gi) || source.match(/Blu-ray/i) && processing.match(/DIY/i)) {
        return "uhdbluray";
      } else if (source.match(/DVD/gi) && container.match(/MKV|AVI/gi)) {
        return "dvdrip";
      } else if (processing.match(/DVD5|DVD9/gi) && container.match(/VOB|ISO/gi)) {
        return "dvd";
      } else if (container.match(/MKV|MP4/i)) {
        return "encode";
      }
      return "";
    }
    extractTags() {
      const { editionTags } = PT_SITE.GPW.sourceInfo;
      const knownTags = {};
      const otherTags = {};
      for (const rawTag of this.tags) {
        const tag = editionTags[rawTag];
        if (tag) {
          knownTags[tag] = true;
        } else if (rawTag) {
          otherTags[rawTag] = true;
        }
      }
      this.info.tags = __spreadValues({}, knownTags);
      this.info.otherTags = otherTags;
    }
    extractArea() {
      const regionList = this.siteGroupInfo.region.split(",");
      this.info.area = getAreaCode(regionList == null ? void 0 : regionList[0]);
    }
    extractIsHardcodedSub() {
      const trumpReason = $$2(`#trumpable_${this.torrentId} span`).text() || "";
      this.info.hardcodedSub = trumpReason.includes("Hardcoded Subtitles");
    }
  }
  registry.register(new GPWExtractor());
  class Unite3DExtractor extends BaseExtractor {
    constructor() {
      super(...arguments);
      this.priority = 10;
    }
    async extract() {
      this.extractBasicInfo();
      this.extractTitle();
      this.extractYear();
      this.extractImdbUrl();
      this.extractSource();
      this.extractTags();
      this.extractMediaInfos();
      this.extractMediaDetails();
      this.extractDescription();
      await this.extractScreenshots();
      this.extractMovieNames();
      this.determineIfIsForbidden();
      this.extractComparisonsScreenshots();
      this.extractArea();
      this.extractPoster();
      this.enhanceInfo();
      return this.info;
    }
    extractBasicInfo() {
      const basicInfo = {
        category: "",
        type: "",
        size: "",
        resolution: ""
      };
      const formats = $$2(".torrent__tags li");
      formats.each((_2, item) => {
        var _a2;
        const className = (_a2 = $$2(item).attr("class")) == null ? void 0 : _a2.replace("torrent__", "");
        basicInfo[className] = $$2(item).text().trim();
      });
      const category = getCategoryFromSource(basicInfo.category);
      this.info.category = refineCategory(this.info, category);
      this.info.size = convertSizeStringToBytes(
        basicInfo.size.replace(/\s/g, "")
      );
      this.info.resolution = basicInfo.resolution;
      this.info.videoType = getVideoTypeFromSource(
        basicInfo.type,
        this.info.resolution
      );
    }
    extractTitle() {
      const title = $$2("h1.torrent__name").text().trim();
      const formattedTitle = formatTorrentTitle(title);
      this.info.title = formattedTitle;
    }
    extractYear() {
      var _a2, _b;
      const year = (_b = (_a2 = $$2(".meta__title").text().match(/\((\d{4})\)/)) == null ? void 0 : _a2[1]) != null ? _b : "";
      this.info.year = year;
    }
    extractImdbUrl() {
      this.info.imdbUrl = $$2(".meta__imdb a").attr("href");
    }
    extractMediaInfos() {
      const mediaInfo = $$2(".bbcode-rendered code").text();
      this.info.mediaInfos = [mediaInfo];
    }
    extractDescription() {
      const description = getFilterBBCode($$2(".panel__body.bbcode-rendered")[0]);
      const mediaInfoQuote = this.info.mediaInfos.length > 0 ? `[quote]${this.info.mediaInfos[0]}[/quote]` : "";
      this.info.description = mediaInfoQuote + description;
    }
    extractSource() {
      this.info.source = getVideoSourceFromTitle(this.info.title);
    }
    extractTags() {
      this.info.tags = __spreadValues(__spreadValues({}, this.info.tags), getTagsFromSource(this.info.title));
    }
    extractMovieNames() {
      const title = $$2(".meta__title").text();
      this.info.movieName = title.replace(/\(\d+\)/g, "").trim();
    }
    determineIfIsForbidden() {
      const { title, subtitle, description } = this.info;
      const combinedContent = title + subtitle + description;
      const isForbidden = CONFIG.FORBIDDEN_KEYWORDS.some(
        (keyword) => combinedContent.includes(keyword)
      );
      this.info.isForbidden = isForbidden;
    }
    extractPoster() {
      this.info.poster = $$2(".meta__poster-link img").attr("src");
    }
    enhanceInfo() {
    }
    extractComparisonsScreenshots() {
    }
  }
  class GenericUnit3DExtractor extends Unite3DExtractor {
    constructor() {
      super(...arguments);
      this.priority = 5;
    }
    canHandle(siteName, siteType) {
      return siteType === "UNIT3D";
    }
  }
  registry.register(new GenericUnit3DExtractor());
  class LegacyUnit3DExtractor extends Unite3DExtractor {
    constructor() {
      super(...arguments);
      this.priority = 5;
    }
    canHandle(siteName, siteType) {
      return siteType === "UNIT3D-Legacy";
    }
    extractTitle() {
      var _a2, _b, _c;
      let { title } = this.info;
      if (CURRENT_SITE_NAME === "HDPOST") {
        const englishTitle = (_b = (_a2 = title.match(/[\s\W\d]+(.+)/)) == null ? void 0 : _a2[1]) != null ? _b : "";
        this.info.subtitle = (_c = title.replace(englishTitle, "")) == null ? void 0 : _c.trim();
        title = englishTitle;
      }
      if (CURRENT_SITE_NAME === "ACM") {
        title = title.replace(/\/\s+\W+/, "");
      }
      if (CURRENT_SITE_NAME === "MDU") {
        title = $("h1.text-center").text().trim();
        this.info.subtitle = $("h2.text-center").text().trim();
      }
      this.info.title = title;
    }
    extractBasicInfo() {
      var _a2;
      const basicInfo = {
        category: "",
        type: "",
        size: "",
        resolution: "",
        name: ""
      };
      const lineSelector = $(
        '#meta-info+.meta-general>.panel:has(".table-responsive"):first table tr'
      );
      lineSelector.each((_2, element) => {
        var _a3, _b, _c;
        const keyText = $(element).find("td:first").text().replace(/\s|\n/g, "");
        for (const [key, value] of Object.entries(CONFIG.UNIT3D_BASIC_KEY_MAP)) {
          if (value.includes(keyText)) {
            let value2 = $(element).find("td:last").text();
            if (key === "name") {
              value2 = (_c = (_b = (_a3 = $(element).find("td:last")[0]) == null ? void 0 : _a3.firstChild) == null ? void 0 : _b.textContent) != null ? _c : "";
            }
            basicInfo[key] = value2.replace(/\n/g, "").trim();
          }
        }
      });
      const category = getCategoryFromSource(basicInfo.category);
      this.info.category = refineCategory(this.info, category);
      this.info.size = convertSizeStringToBytes(
        basicInfo.size.replace(/\s/g, "")
      );
      this.info.resolution = basicInfo.resolution;
      this.info.videoType = getVideoTypeFromSource(
        basicInfo.type,
        this.info.resolution
      );
      this.info.title = formatTorrentTitle((_a2 = basicInfo == null ? void 0 : basicInfo.name) != null ? _a2 : "");
    }
    extractYear() {
      const year = $(".movie-heading span:last").text();
      this.info.year = year.replace(/\(|\)|\s/g, "");
    }
    extractMovieNames() {
      const movieName = $(".movie-heading span:first").text();
      this.info.movieName = movieName;
    }
    extractImdbUrl() {
      const imdbUrl = $(".movie-details a:contains(IMDB)").attr("href");
      this.info.imdbUrl = imdbUrl;
    }
    extractPoster() {
      const poster = $(".movie-poster img").attr("src");
      this.info.poster = poster;
    }
    extractMediaInfos() {
      const mediaInfo = $(".decoda-code code").text();
      this.info.mediaInfos = [mediaInfo];
    }
    extractDescription() {
      const descriptionDom = $(".fa-sticky-note").parents(".panel-heading").siblings(".table-responsive").find(".panel-body").clone();
      descriptionDom.find("#collection_waypoint").remove();
      let descriptionBBCode = getFilterBBCode(descriptionDom[0]);
      if (this.info.mediaInfos.length > 0) {
        descriptionBBCode = `
[quote]${this.info.mediaInfos[0]}[/quote]${descriptionBBCode}`;
      }
      this.info.description = descriptionBBCode;
    }
  }
  registry.register(new LegacyUnit3DExtractor());
  class AvistaZExtractor extends BaseExtractor {
    constructor() {
      super(...arguments);
      this.priority = 10;
    }
    async extract() {
      this.extractBasicInfo();
      this.extractImdbUrl();
      this.extractSource();
      this.extractTags();
      this.extractMediaInfos();
      this.extractMediaDetails();
      this.extractDescription();
      await this.extractScreenshots();
      this.extractMovieNameAndYear();
      this.determineIfIsForbidden();
      this.extractComparisonsScreenshots();
      this.extractArea();
      this.enhanceInfo();
      return this.info;
    }
    extractBasicInfo() {
      var _a2;
      const basicInfo = {
        category: "",
        videoType: "",
        size: "",
        resolution: "",
        title: ""
      };
      $$2("#content-area .block:last table:first>tbody>tr").each((_2, element) => {
        const pageKey = $$2(element).find("td:first").text();
        const value = $$2(element).find("td:last").text();
        const infoKey = CONFIG.AVISTAZ_BASIC_KEY_MAP[pageKey];
        basicInfo[infoKey] = value.replace(/\n/g, "").trim();
      });
      this.info.title = formatTorrentTitle(basicInfo.title);
      const category = (_a2 = basicInfo.category) == null ? void 0 : _a2.toLowerCase().replace("-", "");
      this.info.category = refineCategory(this.info, category);
      this.info.size = convertSizeStringToBytes(
        basicInfo.size.replace(/\s/g, "")
      );
      this.info.resolution = basicInfo.resolution;
      this.info.videoType = getVideoTypeFromSource(
        basicInfo.videoType,
        this.info.resolution
      );
    }
    extractYear() {
      var _a2, _b;
      const year = (_b = (_a2 = $$2(".meta__title").text().match(/\((\d{4})\)/)) == null ? void 0 : _a2[1]) != null ? _b : "";
      this.info.year = year;
    }
    extractImdbUrl() {
      var _a2, _b, _c;
      this.info.imdbUrl = (_c = (_b = (_a2 = $$2('.badge-extra a[href*="www.imdb.com/title"]').attr("href")) == null ? void 0 : _a2.split("?")) == null ? void 0 : _b[1]) != null ? _c : "";
    }
    extractMediaInfos() {
      const mediaInfo = $$2("#collapseMediaInfo pre").text();
      this.info.mediaInfos = [mediaInfo];
    }
    extractDescription() {
      const descriptionBBCode = getFilterBBCode($$2(".torrent-desc")[0]);
      const mediaInfoQuote = this.info.mediaInfos.length > 0 ? `[quote]${this.info.mediaInfos[0]}[/quote]` : "";
      this.info.description = mediaInfoQuote + descriptionBBCode;
    }
    async extractScreenshots() {
      const screenshotsBBCode = $$2("#collapseScreens a").map(function() {
        return `[url=${$$2(this).attr("href")}][img]${$$2(this).find("img").attr("src")}[/img][/url]`;
      }).get();
      const screenshots = await extractImgsFromBBCode(
        screenshotsBBCode.join("\n")
      );
      this.info.screenshots = screenshots;
    }
    extractSource() {
      this.info.source = getVideoSourceFromTitle(this.info.title);
    }
    extractTags() {
      this.info.tags = __spreadValues(__spreadValues({}, this.info.tags), getTagsFromSource(this.info.title));
    }
    extractMovieNameAndYear() {
      var _a2, _b;
      const movieTitle = $$2(".block-titled h3 a").text();
      const movieName = movieTitle.split("(")[0].trim();
      const year = (_b = (_a2 = movieTitle.match(/\((\d+)\)/)) == null ? void 0 : _a2[1]) != null ? _b : "";
      this.info.movieName = movieName;
      this.info.year = year;
    }
    determineIfIsForbidden() {
      const { title, subtitle, description } = this.info;
      const combinedContent = title + subtitle + description;
      const isForbidden = CONFIG.FORBIDDEN_KEYWORDS.some(
        (keyword) => combinedContent.includes(keyword)
      );
      this.info.isForbidden = isForbidden;
    }
    extractArea() {
      const country = $$2(".fa-flag~.badge-extra:first a").text();
      const area = getAreaCode(country);
      this.info.area = area;
    }
    enhanceInfo() {
    }
    extractComparisonsScreenshots() {
    }
  }
  class GenericAvistaZExtractor extends AvistaZExtractor {
    constructor() {
      super(...arguments);
      this.priority = 5;
    }
    canHandle(siteName, siteType) {
      return siteType === "AvistaZ";
    }
  }
  registry.register(new GenericAvistaZExtractor());
  class BHDExtractor extends BaseExtractor {
    constructor() {
      super(...arguments);
      this.priority = 10;
    }
    canHandle(siteName) {
      return siteName === "BeyondHD";
    }
    async extract() {
      this.extractBasicInfo();
      this.extractYear();
      this.extractImdbUrl();
      this.extractMediaInfos();
      this.extractMediaDetails();
      this.extractDescription();
      await this.extractScreenshots();
      this.extractMovieName();
      this.extractComparisonsScreenshots();
      this.extractArea();
      this.enhanceInfo();
      return this.info;
    }
    extractBasicInfo() {
      const basicInfo = {
        Category: "",
        Name: "",
        Source: "",
        Type: "",
        Size: "",
        Video: "",
        Audio: "",
        Hybrid: "",
        Edition: "",
        Region: "",
        Extras: ""
      };
      $$2("tr.dotborder").each((_2, element) => {
        const key = $$2(element).find("td:first").text();
        const value = $$2(element).find("td:last").text();
        basicInfo[key] = value.replace(/\n/g, "").trim();
      });
      const { Category, Name, Source, Type: Type2, Size } = basicInfo;
      this.info.title = formatTorrentTitle(Name);
      const category = getCategoryFromSource(
        Category.toLowerCase().replace(/s/, "")
      );
      this.info.category = refineCategory(this.info, category);
      this.info.size = convertSizeStringToBytes(Size.replace(/\s/g, ""));
      this.info.videoType = this.getVideoType(Source, Type2);
      this.info.source = this.getSource(Source, Type2);
      const { knownTags, otherTags } = this.getEditionTags(basicInfo);
      this.info.tags = __spreadValues(__spreadValues({}, this.info.tags), knownTags);
      this.info.otherTags = otherTags;
    }
    extractYear() {
      const year = $$2(".year-link").text();
      if (!year) {
        super.extractYear();
      } else {
        this.info.year = year;
      }
    }
    extractImdbUrl() {
      this.info.imdbUrl = $$2('span[title="IMDb Rating"] a').attr("href");
    }
    extractMediaInfos() {
      const mediaInfo = $$2("#stats-full code").text();
      this.info.mediaInfos = [mediaInfo];
    }
    extractDescription() {
      const descriptionDom = $$2(".panel-heading:contains(Description)").next(".panel-body").find(".forced-nfo");
      const descriptionBBCode = getFilterBBCode(descriptionDom[0]);
      const mediaInfoQuote = this.info.mediaInfos.length > 0 ? `[quote]${this.info.mediaInfos[0]}[/quote]` : "";
      this.info.description = mediaInfoQuote + descriptionBBCode;
      this.info.originalDescription = descriptionBBCode;
    }
    extractMovieName() {
      const movieName = $$2(".bhd-title-h1 a.beta-link-blend").text();
      this.info.movieName = movieName;
    }
    extractArea() {
      const country = $$2('a[href*="library/movie?countries"]').text();
      const area = getAreaCode(country);
      this.info.area = area;
    }
    enhanceInfo() {
    }
    extractComparisonsScreenshots() {
      var _a2, _b;
      const title = (_b = (_a2 = $$2("#screenMain .screenParent").text()) == null ? void 0 : _a2.replace(/\[Show\]|Comparison/g, "")) == null ? void 0 : _b.trim();
      const imgs = Array.from($$2(".screenComparison img")).map(
        (img) => {
          var _a3, _b2;
          return (_b2 = (_a3 = $$2(img)) == null ? void 0 : _a3.attr("src")) != null ? _b2 : "";
        }
      );
      this.info.comparisons = [
        {
          title,
          imgs,
          reason: ""
        }
      ];
    }
    getVideoType(source, type) {
      type = type.replace(/\s/g, "");
      if (type.match(/Remux/i)) {
        return "remux";
      } else if (type.match(/BD50|BD25/i)) {
        return "bluray";
      } else if (type.match(/UHD50|UHD66|UHD100/i)) {
        return "uhdbluray";
      } else if (type.match(/DVD5|DVD9/i)) {
        return "dvd";
      } else if (source.match(/WEB|WEB-DL/i)) {
        return "web";
      } else if (type.match(/\d{3,4}p/i)) {
        return "encode";
      }
      return type;
    }
    getSource(source, resolution) {
      if (resolution.match(/BD100|BD66/i)) {
        return "uhdbluray";
      }
      if (source.match(/Blu-ray/i) && resolution.match(/UHD/i)) {
        return "uhdbluray";
      }
      if (source.match(/WEB|WEB-DL/i)) {
        return "web";
      }
      return source.replace(/-/g, "").toLowerCase();
    }
    getEditionTags(basicInfo) {
      const { common, others } = CONFIG.BHD_SOURCE_MEDIA_TAGS_MAP;
      const knownTags = {};
      const otherTags = {
        Hybrid: false
      };
      const { Video, Audio, Edition, Extras, Hybrid } = basicInfo;
      const text2 = [Video, Audio, Edition, Extras].filter((v2) => Boolean(v2)).join(" / ");
      for (const [source, target] of Object.entries(common)) {
        if (text2.includes(source)) {
          knownTags[target] = true;
        }
      }
      for (const [source, target] of Object.entries(others)) {
        if (text2.includes(source)) {
          otherTags[target] = true;
        }
      }
      if (Hybrid) {
        otherTags.Hybrid = true;
      }
      return {
        knownTags,
        otherTags
      };
    }
  }
  registry.register(new BHDExtractor());
  class BTNExtractor extends GazelleExtractor {
    constructor() {
      super(...arguments);
      this.priority = 10;
    }
    canHandle(siteName) {
      return siteName === "BTN";
    }
    async extract() {
      this.extractTorrentId();
      this.getTorrentHeaderDom();
      this.extractTitle();
      this.extractTorrentLink();
      await this.getShowInfo();
      this.extractBasicInfo();
      this.extractYearAndCategory();
      await this.extractDescription();
      await this.extractScreenshots();
      this.extractMediaInfos();
      this.extractMediaDetails();
      this.extractMovieName();
      this.extractSource();
      return this.info;
    }
    getTorrentHeaderDom() {
      this.torrentHeaderDom = $$2(`#torrent_${this.torrentId}`).prev();
    }
    extractTitle() {
      const torrentName = this.torrentHeaderDom.find("> td").text().replace(/»/, "").trim();
      this.info.title = formatTorrentTitle(torrentName);
    }
    extractBasicInfo() {
      const specsDom = this.torrentHeaderDom.prev();
      const rawSpecs = specsDom.find("> td > a").text().replace(/»/, "").split("/").map((v2) => v2.trim());
      const specs = rawSpecs.filter((v2) => !["NFO"].includes(v2));
      const size = specsDom.find("> td").next("td").text().replace(/\s/g, "");
      this.info.size = convertSizeStringToBytes(size);
      this.info.videoType = this.getVideoType(specs[2]);
    }
    extractYearAndCategory() {
      var _a2, _b;
      const seasonTitle = $$2("#content > div > h2").contents().last().text().trim();
      const [season = "", year = ""] = (_b = (_a2 = seasonTitle == null ? void 0 : seasonTitle.match(/(.*) \[(\d+)\]/)) == null ? void 0 : _a2.slice(1)) != null ? _b : [];
      this.info.year = year;
      const category = season.match(/season/i) ? "tvPack" : "tv";
      this.info.category = category;
    }
    extractTorrentLink() {
      const torrentLink = this.torrentHeaderDom.prev().find('a[title="Download"]').attr("href");
      CURRENT_SITE_INFO.torrentLink = torrentLink;
    }
    extractMediaInfos() {
      const { mediaInfo, bdInfo } = getBDInfoOrMediaInfoFromBBCode(
        this.info.description
      );
      this.info.mediaInfos = this.isVideoTypeBluray() ? bdInfo : mediaInfo;
    }
    extractDescription() {
      return new Promise((resolve28) => {
        const descriptionDom = $$2(
          `#torrent_${this.torrentId} > td > blockquote`
        ).last()[0];
        const descriptionBBCode = getFilterBBCode(descriptionDom);
        this.info.description = descriptionBBCode;
        resolve28();
      });
    }
    extractMovieName() {
      var _a2, _b, _c;
      const movieName = (_c = (_b = (_a2 = $$2("#content > div > h2 > a > img").attr("alt")) == null ? void 0 : _a2.replace(/\(\d+\)/, "")) == null ? void 0 : _b.trim()) != null ? _c : "";
      this.info.movieName = movieName;
    }
    extractSource() {
      this.info.source = getVideoSourceFromTitle(this.info.title);
    }
    async getShowInfo() {
      var _a2, _b, _c;
      const seriesUrl = $$2("#content > .thin > h2 > a").prop("href");
      const html2 = await GMFetch(seriesUrl);
      const infoHtml = (_b = (_a2 = html2 == null ? void 0 : html2.match(/Series Info[\s\S]*?(<ul[\s\S]+?<\/ul>)/)) == null ? void 0 : _a2[1]) != null ? _b : "";
      const infoDom = new DOMParser().parseFromString(infoHtml, "text/html");
      const info = Object.fromEntries(
        Array.from(infoDom.querySelectorAll("tr")).map((tr) => {
          const tds = Array.from(tr.children);
          return [tds[0].innerText.trim(), tds[1]];
        })
      );
      const country = info["Country:"].innerText;
      const imdbUrl = (_c = info["External Links:"].innerHTML.match(
        /https:\/\/www\.imdb\.com\/title\/tt\d+/
      )) == null ? void 0 : _c[0];
      this.info.area = getAreaCode(country);
      this.info.imdbUrl = imdbUrl;
    }
    getVideoType(source) {
      if (this.info.title.match(/remux/i)) {
        return "remux";
      } else if (["BD50", "BD25"].includes(source)) {
        return "bluray";
      } else if (["BD66", "BD100"].includes(source)) {
        return "uhdbluray";
      } else if (["WEB-DL"].includes(source)) {
        return "web";
      } else if (["HDTV"].includes(source)) {
        return "encode";
      }
      return "";
    }
  }
  registry.register(new BTNExtractor());
  class HDBExtractor extends BaseExtractor {
    constructor() {
      super(...arguments);
      this.priority = 10;
      this.torrentId = getLocationSearchValueByKey("id");
    }
    canHandle(siteName) {
      return siteName === "HDBits";
    }
    async extract() {
      this.extractTitle();
      this.getBasicInfo();
      this.extractMovieDetails();
      await this.extractMediaInfos();
      this.extractMediaDetails();
      this.extractDescription();
      await this.extractScreenshots();
      this.extractArea();
      return this.info;
    }
    extractTitle() {
      const title = $$2("h1").eq(0).text();
      this.info.title = formatTorrentTitle(title);
    }
    getBasicInfo() {
      var _a2;
      const videoTypeMap = {
        "Blu-ray/HD DVD": "bluray",
        Capture: "hdtv",
        Encode: "encode",
        Remux: "remux",
        "WEB-DL": "web"
      };
      const info = $$2("th:contains(Category)").next().text();
      const size = $$2("th:contains(Size)").eq(0).next().text();
      const splitArray = info.split("(");
      const category = splitArray[0].trim().toLowerCase();
      const videoType = splitArray[1].split(",")[1].replace(/\)/g, "").trim();
      this.info.size = convertSizeStringToBytes(size);
      this.info.category = refineCategory(this.info, category);
      this.info.videoType = (_a2 = videoTypeMap[videoType]) != null ? _a2 : videoType;
      this.info.source = getCategoryFromSource(this.info.title);
    }
    extractMovieDetails() {
      var _a2;
      const isMovieType = $$2(".contentlayout h1").length > 0;
      const IMDBLinkDom = isMovieType ? $$2(".contentlayout h1") : $$2("#details .showlinks li").eq(1);
      if (isMovieType) {
        const IMDBYear = IMDBLinkDom.prop("lastChild").nodeValue.replace(
          /\s|\(|\)/g,
          ""
        );
        const movieName = IMDBLinkDom.find("a").text();
        this.info.movieName = movieName;
        if (!IMDBYear) {
          super.extractYear();
        } else {
          this.info.year = IMDBYear;
        }
      }
      this.info.imdbUrl = (_a2 = IMDBLinkDom.find("a").attr("href")) != null ? _a2 : "";
    }
    async extractMediaInfos() {
      try {
        const res = await GMFetch(
          `/details/mediainfo?id=${this.torrentId}`
        );
        const data = res.replace(/\r\n/g, "\n");
        if (data) {
          this.info.mediaInfos = [data];
        }
      } catch (error) {
        console.log(`Error parsing mediainfo for ${this.info.title}:`, error);
      }
    }
    extractDescription() {
      var _a2, _b;
      const editDom = $$2("#details tr").has("a:contains(Edit torrent)");
      const descriptionDom = editDom.length > 0 ? editDom.prev() : $$2("#details >tbody >tr:contains(tags) + tr");
      let descriptionBBCode = getFilterBBCode(descriptionDom.find(">td")[0]);
      descriptionBBCode = (_b = (_a2 = descriptionBBCode.match(/\[quote\]((.|\n)+)\[\/quote\]/)) == null ? void 0 : _a2[1]) != null ? _b : "";
      this.info.description = descriptionBBCode;
    }
    extractMovieName() {
      const movieName = $$2(".bhd-title-h1 a.beta-link-blend").text();
      this.info.movieName = movieName;
    }
    extractArea() {
      const country = $$2("#imdbinfo th:contains(Country)").next().text();
      this.info.area = getAreaCode(country);
    }
  }
  registry.register(new HDBExtractor());
  class KGExtractor extends BaseExtractor {
    constructor() {
      super(...arguments);
      this.priority = 10;
    }
    canHandle(siteName) {
      return siteName === "KG";
    }
    async extract() {
      this.extractTitle();
      this.extractImdbUrl();
      this.extractMovieName();
      this.extractSize();
      this.extractYear();
      this.extractCategory();
      this.extractResolution();
      this.extractSource();
      this.extractMediaInfos();
      this.extractMetaInfo();
      this.extractMediaDetails();
      this.extractDescription();
      await this.extractScreenshots();
      this.extractArea();
      return this.info;
    }
    getBasicInfoDom(key) {
      return $$2(`.outer h1~table:first>tbody>tr td:contains(${key})`).next("td");
    }
    extractTitle() {
      var _a2;
      const torrentFileDom = this.getBasicInfoDom("Download").find("a.index");
      const torrentFileName = torrentFileDom.text().replace(/\.torrent$/, "");
      const fileName = (_a2 = this.getBasicInfoDom("Filename").text()) == null ? void 0 : _a2.replace(/\.\w+$/, "");
      this.info.title = formatTorrentTitle(fileName || torrentFileName);
    }
    extractImdbUrl() {
      const link = this.getBasicInfoDom("Internet Link").find("a").attr("href");
      const imdbUrl = (link == null ? void 0 : link.match(/imdb/)) ? link.replace(/\?.+/, "") : "";
      this.info.imdbUrl = imdbUrl;
    }
    extractSize() {
      var _a2, _b;
      const sizeContent = this.getBasicInfoDom("Size").text();
      const size = (_b = (_a2 = sizeContent.match(/\((.+?)\)/)) == null ? void 0 : _a2[1].replace(/\s|,/g, "")) != null ? _b : "";
      this.info.size = convertSizeStringToBytes(size);
    }
    extractYear() {
      var _a2, _b;
      const yearText = this.getBasicInfoDom("Year").text();
      const year = (_b = (_a2 = yearText.match(/\d{4}/)) == null ? void 0 : _a2[0]) != null ? _b : "";
      this.info.year = year;
    }
    extractCategory() {
      const typeText = this.getBasicInfoDom("Type").text();
      const genresText = this.getBasicInfoDom("Genres").text();
      const category = typeText.toLowerCase();
      this.info.category = genresText.match(/Animation/i) ? "cartoon" : category;
    }
    extractSource() {
      var _a2;
      const sourceText = this.getBasicInfoDom("Source").text();
      let formattedSource = (_a2 = sourceText == null ? void 0 : sourceText.replace(/-/g, "")) == null ? void 0 : _a2.toLowerCase();
      if (formattedSource === "tv") {
        formattedSource = "hdtv";
      }
      this.info.source = formattedSource;
    }
    extractMetaInfo() {
      var _a2, _b, _c, _d, _e;
      const { title, source, mediaInfos } = this.info;
      const ripSpecs = this.getBasicInfoDom("RipSpecs").text();
      let genreVideoType = (_c = (_b = (_a2 = this.getBasicInfoDom("Genres").find("tr td>img").attr("src")) == null ? void 0 : _a2.match(/genreimages\/(\w+)\.\w+/)) == null ? void 0 : _b[1]) != null ? _c : "";
      genreVideoType = ripSpecs.match(/DVD\sFormat/) ? "dvdr" : genreVideoType;
      const videoType = this.getVideoType(
        title,
        source,
        genreVideoType,
        mediaInfos.length > 0
      );
      if (genreVideoType === "dvdr" && ripSpecs) {
        this.info.videoCodec = "mpeg2";
        const audioCodec = (_e = (_d = ripSpecs.match(/DVD\sAudio:(.+)/)) == null ? void 0 : _d[1]) != null ? _e : "";
        this.info.audioCodec = getAudioCodecFromSource(audioCodec);
      } else {
        this.info.videoCodec = getVideoCodecFromSourceAndVideoType(
          title,
          videoType
        );
        this.info.audioCodec = getAudioCodecFromSource(title);
      }
      this.info.videoType = videoType;
    }
    async extractMediaInfos() {
      const mediaInfo = $$2("div.mediainfo").text();
      if (mediaInfo) {
        this.info.mediaInfos = [mediaInfo];
      }
    }
    extractDescription() {
      const descriptionDom = this.getBasicInfoDom("Description");
      let descriptionBBCode = getFilterBBCode(descriptionDom.find("article")[0]);
      descriptionBBCode = descriptionBBCode.replace(/(.|\n)+?_{5,}/g, "");
      this.info.description = descriptionBBCode;
    }
    async extractScreenshots() {
      const screenshots = await extractImgsFromBBCode(this.info.description);
      this.info.screenshots = screenshots;
    }
    extractMovieName() {
      var _a2;
      const movieTitles = $$2(".outer h1").text().split("- ");
      let movieName = "";
      let movieAkaName = "";
      if (movieTitles.length >= 2) {
        [movieName, movieAkaName] = movieTitles[1].replace(/\(\d+\)/, "").trim().split(/AKA/i);
      }
      this.info.movieName = movieName == null ? void 0 : movieName.trim();
      this.info.movieAkaName = (_a2 = movieAkaName == null ? void 0 : movieAkaName.trim()) != null ? _a2 : "";
    }
    extractArea() {
      const country = $$2(".outer h1 img").attr("alt") || "";
      this.info.area = getAreaCode(country);
    }
    getVideoType(title, source, genreVideoType, hasMediainfo) {
      if (source) {
        if (source === "bluray") {
          const blurayFlag = genreVideoType === "bluray" || !hasMediainfo;
          return blurayFlag ? "bluray" : "encode";
        } else if (source === "dvd") {
          const dvdFlag = genreVideoType === "dvdr" || !hasMediainfo;
          return dvdFlag ? "dvd" : "dvdrip";
        }
        return source;
      }
      return getVideoTypeFromSource(title);
    }
  }
  registry.register(new KGExtractor());
  class HDTExtractor extends BaseExtractor {
    constructor() {
      super(...arguments);
      this.priority = 10;
    }
    canHandle(siteName) {
      return siteName === "HDT";
    }
    async extract() {
      this.extractTitle();
      this.extractBasicInfo();
      this.extractResolution();
      this.extractImdbData();
      this.extractDescription();
      await this.extractScreenshots();
      this.extractMediaInfos();
      this.extractMediaDetails();
      this.enhanceInfo();
      return this.info;
    }
    extractTitle() {
      const title = document.title.replace(/HD-Torrents.org\s*-/gi, "").trim();
      this.info.title = formatTorrentTitle(title);
    }
    extractBasicInfo() {
      const { title } = this.info;
      const basicInfo = {
        Category: "",
        Size: "",
        Genre: ""
      };
      $$2(".detailsleft").each((_2, element) => {
        const key = $$2(element).text().replace(/:/g, "").trim();
        const value = $$2(element).next("td").text();
        if (value) {
          basicInfo[key] = value.replace(/\n/g, "").trim();
        }
      });
      const { Category, Size, Genre } = basicInfo;
      let category = Category.toLowerCase().split(/\s|\//)[0];
      category = Genre.match(/Animation/i) ? "cartoon" : category;
      this.info.category = refineCategory(this.info, category);
      this.info.size = convertSizeStringToBytes(Size);
      this.info.videoType = this.getVideoType(Category, title);
      this.info.source = getVideoSourceFromTitle(title);
    }
    extractImdbData() {
      var _a2, _b, _c, _d;
      const imdbInfoDom = $$2("#IMDBDetailsInfoHideShowTR .imdbnew2");
      const imdbUlrDom = imdbInfoDom.find(">a");
      const imdbUrl = imdbUlrDom.attr("href") || "";
      const movieName = imdbUlrDom.text();
      const year = (_b = (_a2 = imdbInfoDom.text().match(/Year:\s*(\d{4})/)) == null ? void 0 : _a2[1]) != null ? _b : "";
      const country = (_d = (_c = imdbInfoDom.text().match(/Country:\s*([^\n]+)/)) == null ? void 0 : _c[1]) != null ? _d : "";
      this.info.imdbUrl = imdbUrl;
      this.info.movieName = movieName;
      this.info.year = year;
      this.info.area = getAreaCode(country);
    }
    extractDescription() {
      const descriptionDom = $$2("#technicalInfoHideShowTR");
      let descriptionBBCode = getFilterBBCode(descriptionDom[0]);
      descriptionBBCode = descriptionBBCode.replace(
        /\[center\]((?:.|\n)+?)\[\/center\]/g,
        (match, p1) => {
          if (p1.match(/(keep seeding)|(spank your ass)/)) {
            return "";
          }
          return match;
        }
      );
      this.info.description = descriptionBBCode;
    }
    getVideoType(type, title) {
      if (type.match(/Remux/i)) {
        return "remux";
      } else if (type.match(/UHD\/Blu-Ray/i)) {
        return "uhdbluray";
      } else if (type.match(/Blu-Ray/i)) {
        return "bluray";
      }
      return getVideoTypeFromSource(title);
    }
    enhanceInfo() {
      const { title, videoType, mediaInfos } = this.info;
      if (!(mediaInfos == null ? void 0 : mediaInfos.length)) {
        this.info.videoCodec = getVideoCodecFromSourceAndVideoType(
          title,
          videoType
        );
        this.info.audioCodec = getAudioCodecFromSource(title);
        this.info.tags = getTagsFromSource(title);
      }
    }
  }
  registry.register(new HDTExtractor());
  class HDSpaceExtractor extends BaseExtractor {
    constructor() {
      super(...arguments);
      this.priority = 10;
    }
    canHandle(siteName) {
      return siteName === "HDSpace";
    }
    async extract() {
      this.extractTitle();
      this.extractSize();
      this.extractResolution();
      this.extractCategory();
      this.extractMetaInfo();
      await this.extractMovieDetails();
      this.extractMediaInfos();
      this.extractMediaDetails();
      this.extractDescription();
      await this.extractScreenshots();
      return this.info;
    }
    getTdTextByKey(key) {
      return $$2(`#mcol td.header:contains("${key}")`).eq(0).next().text().trim();
    }
    extractTitle() {
      const title = this.getTdTextByKey("Name");
      this.info.title = formatTorrentTitle(title);
    }
    extractSize() {
      const size = this.getTdTextByKey("Size");
      this.info.size = convertSizeStringToBytes(size);
    }
    extractCategory() {
      const categoryValue = this.getTdTextByKey("Category");
      const category = getCategoryFromSource(categoryValue) || "movie";
      this.info.category = refineCategory(this.info, category);
    }
    async extractMovieDetails() {
      var _a2, _b, _c, _d, _e;
      const imdbId = (_c = (_b = (_a2 = $$2("#imdb").next("script").text()) == null ? void 0 : _a2.match(/mid=(\d+)/)) == null ? void 0 : _b[1]) != null ? _c : "";
      const imdbData = await GMFetch(`/getimdb.php?mid=${imdbId}`);
      const imdbDom = new DOMParser().parseFromString(imdbData, "text/html");
      const imdbUlrDom = $$2('a[href*="imdb.com/title"]', imdbDom);
      const imdbUrl = imdbUlrDom.attr("href");
      const movieName = imdbUlrDom.text().replace(/\(\d+\)/g, "");
      const year = (_e = (_d = imdbUlrDom.text().match(/\((\d{4})\)/)) == null ? void 0 : _d[1]) != null ? _e : "";
      const country = $$2('td:contains("Country")', imdbDom).next("td").text();
      this.info = __spreadProps(__spreadValues({}, this.info), {
        imdbUrl,
        movieName,
        year,
        area: getAreaCode(country)
      });
    }
    extractDescription() {
      const descriptionDom = $$2('#mcol td.header:contains("Description")').next();
      const descriptionContent = descriptionDom.clone();
      $$2(descriptionContent).find('#slidenfo,a[href*="#nfo"]').remove();
      const descriptionBBCode = getFilterBBCode(descriptionContent[0]);
      this.info.description = descriptionBBCode;
    }
  }
  registry.register(new HDSpaceExtractor());
  /*! @license DOMPurify 3.2.4 | (c) Cure53 and other contributors | Released under the Apache license 2.0 and Mozilla Public License 2.0 | github.com/cure53/DOMPurify/blob/3.2.4/LICENSE */
  const {
    entries,
    setPrototypeOf,
    isFrozen,
    getPrototypeOf,
    getOwnPropertyDescriptor
  } = Object;
  let {
    freeze,
    seal,
    create
  } = Object;
  let {
    apply,
    construct
  } = typeof Reflect !== "undefined" && Reflect;
  if (!freeze) {
    freeze = function freeze2(x2) {
      return x2;
    };
  }
  if (!seal) {
    seal = function seal2(x2) {
      return x2;
    };
  }
  if (!apply) {
    apply = function apply2(fun, thisValue, args) {
      return fun.apply(thisValue, args);
    };
  }
  if (!construct) {
    construct = function construct2(Func, args) {
      return new Func(...args);
    };
  }
  const arrayForEach = unapply(Array.prototype.forEach);
  const arrayLastIndexOf = unapply(Array.prototype.lastIndexOf);
  const arrayPop = unapply(Array.prototype.pop);
  const arrayPush = unapply(Array.prototype.push);
  const arraySplice = unapply(Array.prototype.splice);
  const stringToLowerCase = unapply(String.prototype.toLowerCase);
  const stringToString = unapply(String.prototype.toString);
  const stringMatch = unapply(String.prototype.match);
  const stringReplace = unapply(String.prototype.replace);
  const stringIndexOf = unapply(String.prototype.indexOf);
  const stringTrim = unapply(String.prototype.trim);
  const objectHasOwnProperty = unapply(Object.prototype.hasOwnProperty);
  const regExpTest = unapply(RegExp.prototype.test);
  const typeErrorCreate = unconstruct(TypeError);
  function unapply(func) {
    return function(thisArg) {
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }
      return apply(func, thisArg, args);
    };
  }
  function unconstruct(func) {
    return function() {
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }
      return construct(func, args);
    };
  }
  function addToSet(set2, array) {
    let transformCaseFunc = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : stringToLowerCase;
    if (setPrototypeOf) {
      setPrototypeOf(set2, null);
    }
    let l2 = array.length;
    while (l2--) {
      let element = array[l2];
      if (typeof element === "string") {
        const lcElement = transformCaseFunc(element);
        if (lcElement !== element) {
          if (!isFrozen(array)) {
            array[l2] = lcElement;
          }
          element = lcElement;
        }
      }
      set2[element] = true;
    }
    return set2;
  }
  function cleanArray(array) {
    for (let index = 0; index < array.length; index++) {
      const isPropertyExist = objectHasOwnProperty(array, index);
      if (!isPropertyExist) {
        array[index] = null;
      }
    }
    return array;
  }
  function clone(object) {
    const newObject = create(null);
    for (const [property, value] of entries(object)) {
      const isPropertyExist = objectHasOwnProperty(object, property);
      if (isPropertyExist) {
        if (Array.isArray(value)) {
          newObject[property] = cleanArray(value);
        } else if (value && typeof value === "object" && value.constructor === Object) {
          newObject[property] = clone(value);
        } else {
          newObject[property] = value;
        }
      }
    }
    return newObject;
  }
  function lookupGetter(object, prop) {
    while (object !== null) {
      const desc = getOwnPropertyDescriptor(object, prop);
      if (desc) {
        if (desc.get) {
          return unapply(desc.get);
        }
        if (typeof desc.value === "function") {
          return unapply(desc.value);
        }
      }
      object = getPrototypeOf(object);
    }
    function fallbackValue() {
      return null;
    }
    return fallbackValue;
  }
  const html$1 = freeze(["a", "abbr", "acronym", "address", "area", "article", "aside", "audio", "b", "bdi", "bdo", "big", "blink", "blockquote", "body", "br", "button", "canvas", "caption", "center", "cite", "code", "col", "colgroup", "content", "data", "datalist", "dd", "decorator", "del", "details", "dfn", "dialog", "dir", "div", "dl", "dt", "element", "em", "fieldset", "figcaption", "figure", "font", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "img", "input", "ins", "kbd", "label", "legend", "li", "main", "map", "mark", "marquee", "menu", "menuitem", "meter", "nav", "nobr", "ol", "optgroup", "option", "output", "p", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "section", "select", "shadow", "small", "source", "spacer", "span", "strike", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "time", "tr", "track", "tt", "u", "ul", "var", "video", "wbr"]);
  const svg$1 = freeze(["svg", "a", "altglyph", "altglyphdef", "altglyphitem", "animatecolor", "animatemotion", "animatetransform", "circle", "clippath", "defs", "desc", "ellipse", "filter", "font", "g", "glyph", "glyphref", "hkern", "image", "line", "lineargradient", "marker", "mask", "metadata", "mpath", "path", "pattern", "polygon", "polyline", "radialgradient", "rect", "stop", "style", "switch", "symbol", "text", "textpath", "title", "tref", "tspan", "view", "vkern"]);
  const svgFilters = freeze(["feBlend", "feColorMatrix", "feComponentTransfer", "feComposite", "feConvolveMatrix", "feDiffuseLighting", "feDisplacementMap", "feDistantLight", "feDropShadow", "feFlood", "feFuncA", "feFuncB", "feFuncG", "feFuncR", "feGaussianBlur", "feImage", "feMerge", "feMergeNode", "feMorphology", "feOffset", "fePointLight", "feSpecularLighting", "feSpotLight", "feTile", "feTurbulence"]);
  const svgDisallowed = freeze(["animate", "color-profile", "cursor", "discard", "font-face", "font-face-format", "font-face-name", "font-face-src", "font-face-uri", "foreignobject", "hatch", "hatchpath", "mesh", "meshgradient", "meshpatch", "meshrow", "missing-glyph", "script", "set", "solidcolor", "unknown", "use"]);
  const mathMl$1 = freeze(["math", "menclose", "merror", "mfenced", "mfrac", "mglyph", "mi", "mlabeledtr", "mmultiscripts", "mn", "mo", "mover", "mpadded", "mphantom", "mroot", "mrow", "ms", "mspace", "msqrt", "mstyle", "msub", "msup", "msubsup", "mtable", "mtd", "mtext", "mtr", "munder", "munderover", "mprescripts"]);
  const mathMlDisallowed = freeze(["maction", "maligngroup", "malignmark", "mlongdiv", "mscarries", "mscarry", "msgroup", "mstack", "msline", "msrow", "semantics", "annotation", "annotation-xml", "mprescripts", "none"]);
  const text = freeze(["#text"]);
  const html = freeze(["accept", "action", "align", "alt", "autocapitalize", "autocomplete", "autopictureinpicture", "autoplay", "background", "bgcolor", "border", "capture", "cellpadding", "cellspacing", "checked", "cite", "class", "clear", "color", "cols", "colspan", "controls", "controlslist", "coords", "crossorigin", "datetime", "decoding", "default", "dir", "disabled", "disablepictureinpicture", "disableremoteplayback", "download", "draggable", "enctype", "enterkeyhint", "face", "for", "headers", "height", "hidden", "high", "href", "hreflang", "id", "inputmode", "integrity", "ismap", "kind", "label", "lang", "list", "loading", "loop", "low", "max", "maxlength", "media", "method", "min", "minlength", "multiple", "muted", "name", "nonce", "noshade", "novalidate", "nowrap", "open", "optimum", "pattern", "placeholder", "playsinline", "popover", "popovertarget", "popovertargetaction", "poster", "preload", "pubdate", "radiogroup", "readonly", "rel", "required", "rev", "reversed", "role", "rows", "rowspan", "spellcheck", "scope", "selected", "shape", "size", "sizes", "span", "srclang", "start", "src", "srcset", "step", "style", "summary", "tabindex", "title", "translate", "type", "usemap", "valign", "value", "width", "wrap", "xmlns", "slot"]);
  const svg = freeze(["accent-height", "accumulate", "additive", "alignment-baseline", "amplitude", "ascent", "attributename", "attributetype", "azimuth", "basefrequency", "baseline-shift", "begin", "bias", "by", "class", "clip", "clippathunits", "clip-path", "clip-rule", "color", "color-interpolation", "color-interpolation-filters", "color-profile", "color-rendering", "cx", "cy", "d", "dx", "dy", "diffuseconstant", "direction", "display", "divisor", "dur", "edgemode", "elevation", "end", "exponent", "fill", "fill-opacity", "fill-rule", "filter", "filterunits", "flood-color", "flood-opacity", "font-family", "font-size", "font-size-adjust", "font-stretch", "font-style", "font-variant", "font-weight", "fx", "fy", "g1", "g2", "glyph-name", "glyphref", "gradientunits", "gradienttransform", "height", "href", "id", "image-rendering", "in", "in2", "intercept", "k", "k1", "k2", "k3", "k4", "kerning", "keypoints", "keysplines", "keytimes", "lang", "lengthadjust", "letter-spacing", "kernelmatrix", "kernelunitlength", "lighting-color", "local", "marker-end", "marker-mid", "marker-start", "markerheight", "markerunits", "markerwidth", "maskcontentunits", "maskunits", "max", "mask", "media", "method", "mode", "min", "name", "numoctaves", "offset", "operator", "opacity", "order", "orient", "orientation", "origin", "overflow", "paint-order", "path", "pathlength", "patterncontentunits", "patterntransform", "patternunits", "points", "preservealpha", "preserveaspectratio", "primitiveunits", "r", "rx", "ry", "radius", "refx", "refy", "repeatcount", "repeatdur", "restart", "result", "rotate", "scale", "seed", "shape-rendering", "slope", "specularconstant", "specularexponent", "spreadmethod", "startoffset", "stddeviation", "stitchtiles", "stop-color", "stop-opacity", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke", "stroke-width", "style", "surfacescale", "systemlanguage", "tabindex", "tablevalues", "targetx", "targety", "transform", "transform-origin", "text-anchor", "text-decoration", "text-rendering", "textlength", "type", "u1", "u2", "unicode", "values", "viewbox", "visibility", "version", "vert-adv-y", "vert-origin-x", "vert-origin-y", "width", "word-spacing", "wrap", "writing-mode", "xchannelselector", "ychannelselector", "x", "x1", "x2", "xmlns", "y", "y1", "y2", "z", "zoomandpan"]);
  const mathMl = freeze(["accent", "accentunder", "align", "bevelled", "close", "columnsalign", "columnlines", "columnspan", "denomalign", "depth", "dir", "display", "displaystyle", "encoding", "fence", "frame", "height", "href", "id", "largeop", "length", "linethickness", "lspace", "lquote", "mathbackground", "mathcolor", "mathsize", "mathvariant", "maxsize", "minsize", "movablelimits", "notation", "numalign", "open", "rowalign", "rowlines", "rowspacing", "rowspan", "rspace", "rquote", "scriptlevel", "scriptminsize", "scriptsizemultiplier", "selection", "separator", "separators", "stretchy", "subscriptshift", "supscriptshift", "symmetric", "voffset", "width", "xmlns"]);
  const xml = freeze(["xlink:href", "xml:id", "xlink:title", "xml:space", "xmlns:xlink"]);
  const MUSTACHE_EXPR = seal(/\{\{[\w\W]*|[\w\W]*\}\}/gm);
  const ERB_EXPR = seal(/<%[\w\W]*|[\w\W]*%>/gm);
  const TMPLIT_EXPR = seal(/\$\{[\w\W]*/gm);
  const DATA_ATTR = seal(/^data-[\-\w.\u00B7-\uFFFF]+$/);
  const ARIA_ATTR = seal(/^aria-[\-\w]+$/);
  const IS_ALLOWED_URI = seal(
    /^(?:(?:(?:f|ht)tps?|mailto|tel|callto|sms|cid|xmpp):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i
    // eslint-disable-line no-useless-escape
  );
  const IS_SCRIPT_OR_DATA = seal(/^(?:\w+script|data):/i);
  const ATTR_WHITESPACE = seal(
    /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g
    // eslint-disable-line no-control-regex
  );
  const DOCTYPE_NAME = seal(/^html$/i);
  const CUSTOM_ELEMENT = seal(/^[a-z][.\w]*(-[.\w]+)+$/i);
  var EXPRESSIONS = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    ARIA_ATTR,
    ATTR_WHITESPACE,
    CUSTOM_ELEMENT,
    DATA_ATTR,
    DOCTYPE_NAME,
    ERB_EXPR,
    IS_ALLOWED_URI,
    IS_SCRIPT_OR_DATA,
    MUSTACHE_EXPR,
    TMPLIT_EXPR
  });
  const NODE_TYPE = {
    element: 1,
    attribute: 2,
    text: 3,
    cdataSection: 4,
    entityReference: 5,
    // Deprecated
    entityNode: 6,
    // Deprecated
    progressingInstruction: 7,
    comment: 8,
    document: 9,
    documentType: 10,
    documentFragment: 11,
    notation: 12
    // Deprecated
  };
  const getGlobal = function getGlobal2() {
    return typeof window === "undefined" ? null : window;
  };
  const _createTrustedTypesPolicy = function _createTrustedTypesPolicy2(trustedTypes, purifyHostElement) {
    if (typeof trustedTypes !== "object" || typeof trustedTypes.createPolicy !== "function") {
      return null;
    }
    let suffix = null;
    const ATTR_NAME = "data-tt-policy-suffix";
    if (purifyHostElement && purifyHostElement.hasAttribute(ATTR_NAME)) {
      suffix = purifyHostElement.getAttribute(ATTR_NAME);
    }
    const policyName = "dompurify" + (suffix ? "#" + suffix : "");
    try {
      return trustedTypes.createPolicy(policyName, {
        createHTML(html2) {
          return html2;
        },
        createScriptURL(scriptUrl) {
          return scriptUrl;
        }
      });
    } catch (_2) {
      console.warn("TrustedTypes policy " + policyName + " could not be created.");
      return null;
    }
  };
  const _createHooksMap = function _createHooksMap2() {
    return {
      afterSanitizeAttributes: [],
      afterSanitizeElements: [],
      afterSanitizeShadowDOM: [],
      beforeSanitizeAttributes: [],
      beforeSanitizeElements: [],
      beforeSanitizeShadowDOM: [],
      uponSanitizeAttribute: [],
      uponSanitizeElement: [],
      uponSanitizeShadowNode: []
    };
  };
  function createDOMPurify() {
    let window2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : getGlobal();
    const DOMPurify = (root) => createDOMPurify(root);
    DOMPurify.version = "3.2.4";
    DOMPurify.removed = [];
    if (!window2 || !window2.document || window2.document.nodeType !== NODE_TYPE.document || !window2.Element) {
      DOMPurify.isSupported = false;
      return DOMPurify;
    }
    let {
      document: document2
    } = window2;
    const originalDocument = document2;
    const currentScript = originalDocument.currentScript;
    const {
      DocumentFragment,
      HTMLTemplateElement,
      Node: Node3,
      Element,
      NodeFilter,
      NamedNodeMap = window2.NamedNodeMap || window2.MozNamedAttrMap,
      HTMLFormElement,
      DOMParser: DOMParser2,
      trustedTypes
    } = window2;
    const ElementPrototype = Element.prototype;
    const cloneNode = lookupGetter(ElementPrototype, "cloneNode");
    const remove = lookupGetter(ElementPrototype, "remove");
    const getNextSibling = lookupGetter(ElementPrototype, "nextSibling");
    const getChildNodes = lookupGetter(ElementPrototype, "childNodes");
    const getParentNode = lookupGetter(ElementPrototype, "parentNode");
    if (typeof HTMLTemplateElement === "function") {
      const template = document2.createElement("template");
      if (template.content && template.content.ownerDocument) {
        document2 = template.content.ownerDocument;
      }
    }
    let trustedTypesPolicy;
    let emptyHTML = "";
    const {
      implementation,
      createNodeIterator,
      createDocumentFragment,
      getElementsByTagName
    } = document2;
    const {
      importNode
    } = originalDocument;
    let hooks = _createHooksMap();
    DOMPurify.isSupported = typeof entries === "function" && typeof getParentNode === "function" && implementation && implementation.createHTMLDocument !== void 0;
    const {
      MUSTACHE_EXPR: MUSTACHE_EXPR2,
      ERB_EXPR: ERB_EXPR2,
      TMPLIT_EXPR: TMPLIT_EXPR2,
      DATA_ATTR: DATA_ATTR2,
      ARIA_ATTR: ARIA_ATTR2,
      IS_SCRIPT_OR_DATA: IS_SCRIPT_OR_DATA2,
      ATTR_WHITESPACE: ATTR_WHITESPACE2,
      CUSTOM_ELEMENT: CUSTOM_ELEMENT2
    } = EXPRESSIONS;
    let {
      IS_ALLOWED_URI: IS_ALLOWED_URI$1
    } = EXPRESSIONS;
    let ALLOWED_TAGS = null;
    const DEFAULT_ALLOWED_TAGS = addToSet({}, [...html$1, ...svg$1, ...svgFilters, ...mathMl$1, ...text]);
    let ALLOWED_ATTR = null;
    const DEFAULT_ALLOWED_ATTR = addToSet({}, [...html, ...svg, ...mathMl, ...xml]);
    let CUSTOM_ELEMENT_HANDLING = Object.seal(create(null, {
      tagNameCheck: {
        writable: true,
        configurable: false,
        enumerable: true,
        value: null
      },
      attributeNameCheck: {
        writable: true,
        configurable: false,
        enumerable: true,
        value: null
      },
      allowCustomizedBuiltInElements: {
        writable: true,
        configurable: false,
        enumerable: true,
        value: false
      }
    }));
    let FORBID_TAGS = null;
    let FORBID_ATTR = null;
    let ALLOW_ARIA_ATTR = true;
    let ALLOW_DATA_ATTR = true;
    let ALLOW_UNKNOWN_PROTOCOLS = false;
    let ALLOW_SELF_CLOSE_IN_ATTR = true;
    let SAFE_FOR_TEMPLATES = false;
    let SAFE_FOR_XML = true;
    let WHOLE_DOCUMENT = false;
    let SET_CONFIG = false;
    let FORCE_BODY = false;
    let RETURN_DOM = false;
    let RETURN_DOM_FRAGMENT = false;
    let RETURN_TRUSTED_TYPE = false;
    let SANITIZE_DOM = true;
    let SANITIZE_NAMED_PROPS = false;
    const SANITIZE_NAMED_PROPS_PREFIX = "user-content-";
    let KEEP_CONTENT = true;
    let IN_PLACE = false;
    let USE_PROFILES = {};
    let FORBID_CONTENTS = null;
    const DEFAULT_FORBID_CONTENTS = addToSet({}, ["annotation-xml", "audio", "colgroup", "desc", "foreignobject", "head", "iframe", "math", "mi", "mn", "mo", "ms", "mtext", "noembed", "noframes", "noscript", "plaintext", "script", "style", "svg", "template", "thead", "title", "video", "xmp"]);
    let DATA_URI_TAGS = null;
    const DEFAULT_DATA_URI_TAGS = addToSet({}, ["audio", "video", "img", "source", "image", "track"]);
    let URI_SAFE_ATTRIBUTES = null;
    const DEFAULT_URI_SAFE_ATTRIBUTES = addToSet({}, ["alt", "class", "for", "id", "label", "name", "pattern", "placeholder", "role", "summary", "title", "value", "style", "xmlns"]);
    const MATHML_NAMESPACE = "http://www.w3.org/1998/Math/MathML";
    const SVG_NAMESPACE = "http://www.w3.org/2000/svg";
    const HTML_NAMESPACE = "http://www.w3.org/1999/xhtml";
    let NAMESPACE = HTML_NAMESPACE;
    let IS_EMPTY_INPUT = false;
    let ALLOWED_NAMESPACES = null;
    const DEFAULT_ALLOWED_NAMESPACES = addToSet({}, [MATHML_NAMESPACE, SVG_NAMESPACE, HTML_NAMESPACE], stringToString);
    let MATHML_TEXT_INTEGRATION_POINTS = addToSet({}, ["mi", "mo", "mn", "ms", "mtext"]);
    let HTML_INTEGRATION_POINTS = addToSet({}, ["annotation-xml"]);
    const COMMON_SVG_AND_HTML_ELEMENTS = addToSet({}, ["title", "style", "font", "a", "script"]);
    let PARSER_MEDIA_TYPE = null;
    const SUPPORTED_PARSER_MEDIA_TYPES = ["application/xhtml+xml", "text/html"];
    const DEFAULT_PARSER_MEDIA_TYPE = "text/html";
    let transformCaseFunc = null;
    let CONFIG2 = null;
    const formElement = document2.createElement("form");
    const isRegexOrFunction = function isRegexOrFunction2(testValue) {
      return testValue instanceof RegExp || testValue instanceof Function;
    };
    const _parseConfig = function _parseConfig2() {
      let cfg = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      if (CONFIG2 && CONFIG2 === cfg) {
        return;
      }
      if (!cfg || typeof cfg !== "object") {
        cfg = {};
      }
      cfg = clone(cfg);
      PARSER_MEDIA_TYPE = // eslint-disable-next-line unicorn/prefer-includes
      SUPPORTED_PARSER_MEDIA_TYPES.indexOf(cfg.PARSER_MEDIA_TYPE) === -1 ? DEFAULT_PARSER_MEDIA_TYPE : cfg.PARSER_MEDIA_TYPE;
      transformCaseFunc = PARSER_MEDIA_TYPE === "application/xhtml+xml" ? stringToString : stringToLowerCase;
      ALLOWED_TAGS = objectHasOwnProperty(cfg, "ALLOWED_TAGS") ? addToSet({}, cfg.ALLOWED_TAGS, transformCaseFunc) : DEFAULT_ALLOWED_TAGS;
      ALLOWED_ATTR = objectHasOwnProperty(cfg, "ALLOWED_ATTR") ? addToSet({}, cfg.ALLOWED_ATTR, transformCaseFunc) : DEFAULT_ALLOWED_ATTR;
      ALLOWED_NAMESPACES = objectHasOwnProperty(cfg, "ALLOWED_NAMESPACES") ? addToSet({}, cfg.ALLOWED_NAMESPACES, stringToString) : DEFAULT_ALLOWED_NAMESPACES;
      URI_SAFE_ATTRIBUTES = objectHasOwnProperty(cfg, "ADD_URI_SAFE_ATTR") ? addToSet(clone(DEFAULT_URI_SAFE_ATTRIBUTES), cfg.ADD_URI_SAFE_ATTR, transformCaseFunc) : DEFAULT_URI_SAFE_ATTRIBUTES;
      DATA_URI_TAGS = objectHasOwnProperty(cfg, "ADD_DATA_URI_TAGS") ? addToSet(clone(DEFAULT_DATA_URI_TAGS), cfg.ADD_DATA_URI_TAGS, transformCaseFunc) : DEFAULT_DATA_URI_TAGS;
      FORBID_CONTENTS = objectHasOwnProperty(cfg, "FORBID_CONTENTS") ? addToSet({}, cfg.FORBID_CONTENTS, transformCaseFunc) : DEFAULT_FORBID_CONTENTS;
      FORBID_TAGS = objectHasOwnProperty(cfg, "FORBID_TAGS") ? addToSet({}, cfg.FORBID_TAGS, transformCaseFunc) : {};
      FORBID_ATTR = objectHasOwnProperty(cfg, "FORBID_ATTR") ? addToSet({}, cfg.FORBID_ATTR, transformCaseFunc) : {};
      USE_PROFILES = objectHasOwnProperty(cfg, "USE_PROFILES") ? cfg.USE_PROFILES : false;
      ALLOW_ARIA_ATTR = cfg.ALLOW_ARIA_ATTR !== false;
      ALLOW_DATA_ATTR = cfg.ALLOW_DATA_ATTR !== false;
      ALLOW_UNKNOWN_PROTOCOLS = cfg.ALLOW_UNKNOWN_PROTOCOLS || false;
      ALLOW_SELF_CLOSE_IN_ATTR = cfg.ALLOW_SELF_CLOSE_IN_ATTR !== false;
      SAFE_FOR_TEMPLATES = cfg.SAFE_FOR_TEMPLATES || false;
      SAFE_FOR_XML = cfg.SAFE_FOR_XML !== false;
      WHOLE_DOCUMENT = cfg.WHOLE_DOCUMENT || false;
      RETURN_DOM = cfg.RETURN_DOM || false;
      RETURN_DOM_FRAGMENT = cfg.RETURN_DOM_FRAGMENT || false;
      RETURN_TRUSTED_TYPE = cfg.RETURN_TRUSTED_TYPE || false;
      FORCE_BODY = cfg.FORCE_BODY || false;
      SANITIZE_DOM = cfg.SANITIZE_DOM !== false;
      SANITIZE_NAMED_PROPS = cfg.SANITIZE_NAMED_PROPS || false;
      KEEP_CONTENT = cfg.KEEP_CONTENT !== false;
      IN_PLACE = cfg.IN_PLACE || false;
      IS_ALLOWED_URI$1 = cfg.ALLOWED_URI_REGEXP || IS_ALLOWED_URI;
      NAMESPACE = cfg.NAMESPACE || HTML_NAMESPACE;
      MATHML_TEXT_INTEGRATION_POINTS = cfg.MATHML_TEXT_INTEGRATION_POINTS || MATHML_TEXT_INTEGRATION_POINTS;
      HTML_INTEGRATION_POINTS = cfg.HTML_INTEGRATION_POINTS || HTML_INTEGRATION_POINTS;
      CUSTOM_ELEMENT_HANDLING = cfg.CUSTOM_ELEMENT_HANDLING || {};
      if (cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck)) {
        CUSTOM_ELEMENT_HANDLING.tagNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck;
      }
      if (cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck)) {
        CUSTOM_ELEMENT_HANDLING.attributeNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck;
      }
      if (cfg.CUSTOM_ELEMENT_HANDLING && typeof cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements === "boolean") {
        CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements = cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements;
      }
      if (SAFE_FOR_TEMPLATES) {
        ALLOW_DATA_ATTR = false;
      }
      if (RETURN_DOM_FRAGMENT) {
        RETURN_DOM = true;
      }
      if (USE_PROFILES) {
        ALLOWED_TAGS = addToSet({}, text);
        ALLOWED_ATTR = [];
        if (USE_PROFILES.html === true) {
          addToSet(ALLOWED_TAGS, html$1);
          addToSet(ALLOWED_ATTR, html);
        }
        if (USE_PROFILES.svg === true) {
          addToSet(ALLOWED_TAGS, svg$1);
          addToSet(ALLOWED_ATTR, svg);
          addToSet(ALLOWED_ATTR, xml);
        }
        if (USE_PROFILES.svgFilters === true) {
          addToSet(ALLOWED_TAGS, svgFilters);
          addToSet(ALLOWED_ATTR, svg);
          addToSet(ALLOWED_ATTR, xml);
        }
        if (USE_PROFILES.mathMl === true) {
          addToSet(ALLOWED_TAGS, mathMl$1);
          addToSet(ALLOWED_ATTR, mathMl);
          addToSet(ALLOWED_ATTR, xml);
        }
      }
      if (cfg.ADD_TAGS) {
        if (ALLOWED_TAGS === DEFAULT_ALLOWED_TAGS) {
          ALLOWED_TAGS = clone(ALLOWED_TAGS);
        }
        addToSet(ALLOWED_TAGS, cfg.ADD_TAGS, transformCaseFunc);
      }
      if (cfg.ADD_ATTR) {
        if (ALLOWED_ATTR === DEFAULT_ALLOWED_ATTR) {
          ALLOWED_ATTR = clone(ALLOWED_ATTR);
        }
        addToSet(ALLOWED_ATTR, cfg.ADD_ATTR, transformCaseFunc);
      }
      if (cfg.ADD_URI_SAFE_ATTR) {
        addToSet(URI_SAFE_ATTRIBUTES, cfg.ADD_URI_SAFE_ATTR, transformCaseFunc);
      }
      if (cfg.FORBID_CONTENTS) {
        if (FORBID_CONTENTS === DEFAULT_FORBID_CONTENTS) {
          FORBID_CONTENTS = clone(FORBID_CONTENTS);
        }
        addToSet(FORBID_CONTENTS, cfg.FORBID_CONTENTS, transformCaseFunc);
      }
      if (KEEP_CONTENT) {
        ALLOWED_TAGS["#text"] = true;
      }
      if (WHOLE_DOCUMENT) {
        addToSet(ALLOWED_TAGS, ["html", "head", "body"]);
      }
      if (ALLOWED_TAGS.table) {
        addToSet(ALLOWED_TAGS, ["tbody"]);
        delete FORBID_TAGS.tbody;
      }
      if (cfg.TRUSTED_TYPES_POLICY) {
        if (typeof cfg.TRUSTED_TYPES_POLICY.createHTML !== "function") {
          throw typeErrorCreate('TRUSTED_TYPES_POLICY configuration option must provide a "createHTML" hook.');
        }
        if (typeof cfg.TRUSTED_TYPES_POLICY.createScriptURL !== "function") {
          throw typeErrorCreate('TRUSTED_TYPES_POLICY configuration option must provide a "createScriptURL" hook.');
        }
        trustedTypesPolicy = cfg.TRUSTED_TYPES_POLICY;
        emptyHTML = trustedTypesPolicy.createHTML("");
      } else {
        if (trustedTypesPolicy === void 0) {
          trustedTypesPolicy = _createTrustedTypesPolicy(trustedTypes, currentScript);
        }
        if (trustedTypesPolicy !== null && typeof emptyHTML === "string") {
          emptyHTML = trustedTypesPolicy.createHTML("");
        }
      }
      if (freeze) {
        freeze(cfg);
      }
      CONFIG2 = cfg;
    };
    const ALL_SVG_TAGS = addToSet({}, [...svg$1, ...svgFilters, ...svgDisallowed]);
    const ALL_MATHML_TAGS = addToSet({}, [...mathMl$1, ...mathMlDisallowed]);
    const _checkValidNamespace = function _checkValidNamespace2(element) {
      let parent = getParentNode(element);
      if (!parent || !parent.tagName) {
        parent = {
          namespaceURI: NAMESPACE,
          tagName: "template"
        };
      }
      const tagName = stringToLowerCase(element.tagName);
      const parentTagName = stringToLowerCase(parent.tagName);
      if (!ALLOWED_NAMESPACES[element.namespaceURI]) {
        return false;
      }
      if (element.namespaceURI === SVG_NAMESPACE) {
        if (parent.namespaceURI === HTML_NAMESPACE) {
          return tagName === "svg";
        }
        if (parent.namespaceURI === MATHML_NAMESPACE) {
          return tagName === "svg" && (parentTagName === "annotation-xml" || MATHML_TEXT_INTEGRATION_POINTS[parentTagName]);
        }
        return Boolean(ALL_SVG_TAGS[tagName]);
      }
      if (element.namespaceURI === MATHML_NAMESPACE) {
        if (parent.namespaceURI === HTML_NAMESPACE) {
          return tagName === "math";
        }
        if (parent.namespaceURI === SVG_NAMESPACE) {
          return tagName === "math" && HTML_INTEGRATION_POINTS[parentTagName];
        }
        return Boolean(ALL_MATHML_TAGS[tagName]);
      }
      if (element.namespaceURI === HTML_NAMESPACE) {
        if (parent.namespaceURI === SVG_NAMESPACE && !HTML_INTEGRATION_POINTS[parentTagName]) {
          return false;
        }
        if (parent.namespaceURI === MATHML_NAMESPACE && !MATHML_TEXT_INTEGRATION_POINTS[parentTagName]) {
          return false;
        }
        return !ALL_MATHML_TAGS[tagName] && (COMMON_SVG_AND_HTML_ELEMENTS[tagName] || !ALL_SVG_TAGS[tagName]);
      }
      if (PARSER_MEDIA_TYPE === "application/xhtml+xml" && ALLOWED_NAMESPACES[element.namespaceURI]) {
        return true;
      }
      return false;
    };
    const _forceRemove = function _forceRemove2(node) {
      arrayPush(DOMPurify.removed, {
        element: node
      });
      try {
        getParentNode(node).removeChild(node);
      } catch (_2) {
        remove(node);
      }
    };
    const _removeAttribute = function _removeAttribute2(name, element) {
      try {
        arrayPush(DOMPurify.removed, {
          attribute: element.getAttributeNode(name),
          from: element
        });
      } catch (_2) {
        arrayPush(DOMPurify.removed, {
          attribute: null,
          from: element
        });
      }
      element.removeAttribute(name);
      if (name === "is") {
        if (RETURN_DOM || RETURN_DOM_FRAGMENT) {
          try {
            _forceRemove(element);
          } catch (_2) {
          }
        } else {
          try {
            element.setAttribute(name, "");
          } catch (_2) {
          }
        }
      }
    };
    const _initDocument = function _initDocument2(dirty) {
      let doc = null;
      let leadingWhitespace = null;
      if (FORCE_BODY) {
        dirty = "<remove></remove>" + dirty;
      } else {
        const matches = stringMatch(dirty, /^[\r\n\t ]+/);
        leadingWhitespace = matches && matches[0];
      }
      if (PARSER_MEDIA_TYPE === "application/xhtml+xml" && NAMESPACE === HTML_NAMESPACE) {
        dirty = '<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>' + dirty + "</body></html>";
      }
      const dirtyPayload = trustedTypesPolicy ? trustedTypesPolicy.createHTML(dirty) : dirty;
      if (NAMESPACE === HTML_NAMESPACE) {
        try {
          doc = new DOMParser2().parseFromString(dirtyPayload, PARSER_MEDIA_TYPE);
        } catch (_2) {
        }
      }
      if (!doc || !doc.documentElement) {
        doc = implementation.createDocument(NAMESPACE, "template", null);
        try {
          doc.documentElement.innerHTML = IS_EMPTY_INPUT ? emptyHTML : dirtyPayload;
        } catch (_2) {
        }
      }
      const body = doc.body || doc.documentElement;
      if (dirty && leadingWhitespace) {
        body.insertBefore(document2.createTextNode(leadingWhitespace), body.childNodes[0] || null);
      }
      if (NAMESPACE === HTML_NAMESPACE) {
        return getElementsByTagName.call(doc, WHOLE_DOCUMENT ? "html" : "body")[0];
      }
      return WHOLE_DOCUMENT ? doc.documentElement : body;
    };
    const _createNodeIterator = function _createNodeIterator2(root) {
      return createNodeIterator.call(
        root.ownerDocument || root,
        root,
        // eslint-disable-next-line no-bitwise
        NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT | NodeFilter.SHOW_TEXT | NodeFilter.SHOW_PROCESSING_INSTRUCTION | NodeFilter.SHOW_CDATA_SECTION,
        null
      );
    };
    const _isClobbered = function _isClobbered2(element) {
      return element instanceof HTMLFormElement && (typeof element.nodeName !== "string" || typeof element.textContent !== "string" || typeof element.removeChild !== "function" || !(element.attributes instanceof NamedNodeMap) || typeof element.removeAttribute !== "function" || typeof element.setAttribute !== "function" || typeof element.namespaceURI !== "string" || typeof element.insertBefore !== "function" || typeof element.hasChildNodes !== "function");
    };
    const _isNode = function _isNode2(value) {
      return typeof Node3 === "function" && value instanceof Node3;
    };
    function _executeHooks(hooks2, currentNode, data) {
      arrayForEach(hooks2, (hook) => {
        hook.call(DOMPurify, currentNode, data, CONFIG2);
      });
    }
    const _sanitizeElements = function _sanitizeElements2(currentNode) {
      let content = null;
      _executeHooks(hooks.beforeSanitizeElements, currentNode, null);
      if (_isClobbered(currentNode)) {
        _forceRemove(currentNode);
        return true;
      }
      const tagName = transformCaseFunc(currentNode.nodeName);
      _executeHooks(hooks.uponSanitizeElement, currentNode, {
        tagName,
        allowedTags: ALLOWED_TAGS
      });
      if (currentNode.hasChildNodes() && !_isNode(currentNode.firstElementChild) && regExpTest(/<[/\w]/g, currentNode.innerHTML) && regExpTest(/<[/\w]/g, currentNode.textContent)) {
        _forceRemove(currentNode);
        return true;
      }
      if (currentNode.nodeType === NODE_TYPE.progressingInstruction) {
        _forceRemove(currentNode);
        return true;
      }
      if (SAFE_FOR_XML && currentNode.nodeType === NODE_TYPE.comment && regExpTest(/<[/\w]/g, currentNode.data)) {
        _forceRemove(currentNode);
        return true;
      }
      if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {
        if (!FORBID_TAGS[tagName] && _isBasicCustomElement(tagName)) {
          if (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, tagName)) {
            return false;
          }
          if (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(tagName)) {
            return false;
          }
        }
        if (KEEP_CONTENT && !FORBID_CONTENTS[tagName]) {
          const parentNode = getParentNode(currentNode) || currentNode.parentNode;
          const childNodes = getChildNodes(currentNode) || currentNode.childNodes;
          if (childNodes && parentNode) {
            const childCount = childNodes.length;
            for (let i = childCount - 1; i >= 0; --i) {
              const childClone = cloneNode(childNodes[i], true);
              childClone.__removalCount = (currentNode.__removalCount || 0) + 1;
              parentNode.insertBefore(childClone, getNextSibling(currentNode));
            }
          }
        }
        _forceRemove(currentNode);
        return true;
      }
      if (currentNode instanceof Element && !_checkValidNamespace(currentNode)) {
        _forceRemove(currentNode);
        return true;
      }
      if ((tagName === "noscript" || tagName === "noembed" || tagName === "noframes") && regExpTest(/<\/no(script|embed|frames)/i, currentNode.innerHTML)) {
        _forceRemove(currentNode);
        return true;
      }
      if (SAFE_FOR_TEMPLATES && currentNode.nodeType === NODE_TYPE.text) {
        content = currentNode.textContent;
        arrayForEach([MUSTACHE_EXPR2, ERB_EXPR2, TMPLIT_EXPR2], (expr) => {
          content = stringReplace(content, expr, " ");
        });
        if (currentNode.textContent !== content) {
          arrayPush(DOMPurify.removed, {
            element: currentNode.cloneNode()
          });
          currentNode.textContent = content;
        }
      }
      _executeHooks(hooks.afterSanitizeElements, currentNode, null);
      return false;
    };
    const _isValidAttribute = function _isValidAttribute2(lcTag, lcName, value) {
      if (SANITIZE_DOM && (lcName === "id" || lcName === "name") && (value in document2 || value in formElement)) {
        return false;
      }
      if (ALLOW_DATA_ATTR && !FORBID_ATTR[lcName] && regExpTest(DATA_ATTR2, lcName)) ;
      else if (ALLOW_ARIA_ATTR && regExpTest(ARIA_ATTR2, lcName)) ;
      else if (!ALLOWED_ATTR[lcName] || FORBID_ATTR[lcName]) {
        if (
          // First condition does a very basic check if a) it's basically a valid custom element tagname AND
          // b) if the tagName passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
          // and c) if the attribute name passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.attributeNameCheck
          _isBasicCustomElement(lcTag) && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, lcTag) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(lcTag)) && (CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.attributeNameCheck, lcName) || CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.attributeNameCheck(lcName)) || // Alternative, second condition checks if it's an `is`-attribute, AND
          // the value passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
          lcName === "is" && CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, value) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(value))
        ) ;
        else {
          return false;
        }
      } else if (URI_SAFE_ATTRIBUTES[lcName]) ;
      else if (regExpTest(IS_ALLOWED_URI$1, stringReplace(value, ATTR_WHITESPACE2, ""))) ;
      else if ((lcName === "src" || lcName === "xlink:href" || lcName === "href") && lcTag !== "script" && stringIndexOf(value, "data:") === 0 && DATA_URI_TAGS[lcTag]) ;
      else if (ALLOW_UNKNOWN_PROTOCOLS && !regExpTest(IS_SCRIPT_OR_DATA2, stringReplace(value, ATTR_WHITESPACE2, ""))) ;
      else if (value) {
        return false;
      } else ;
      return true;
    };
    const _isBasicCustomElement = function _isBasicCustomElement2(tagName) {
      return tagName !== "annotation-xml" && stringMatch(tagName, CUSTOM_ELEMENT2);
    };
    const _sanitizeAttributes = function _sanitizeAttributes2(currentNode) {
      _executeHooks(hooks.beforeSanitizeAttributes, currentNode, null);
      const {
        attributes
      } = currentNode;
      if (!attributes || _isClobbered(currentNode)) {
        return;
      }
      const hookEvent = {
        attrName: "",
        attrValue: "",
        keepAttr: true,
        allowedAttributes: ALLOWED_ATTR,
        forceKeepAttr: void 0
      };
      let l2 = attributes.length;
      while (l2--) {
        const attr = attributes[l2];
        const {
          name,
          namespaceURI,
          value: attrValue
        } = attr;
        const lcName = transformCaseFunc(name);
        let value = name === "value" ? attrValue : stringTrim(attrValue);
        hookEvent.attrName = lcName;
        hookEvent.attrValue = value;
        hookEvent.keepAttr = true;
        hookEvent.forceKeepAttr = void 0;
        _executeHooks(hooks.uponSanitizeAttribute, currentNode, hookEvent);
        value = hookEvent.attrValue;
        if (SANITIZE_NAMED_PROPS && (lcName === "id" || lcName === "name")) {
          _removeAttribute(name, currentNode);
          value = SANITIZE_NAMED_PROPS_PREFIX + value;
        }
        if (SAFE_FOR_XML && regExpTest(/((--!?|])>)|<\/(style|title)/i, value)) {
          _removeAttribute(name, currentNode);
          continue;
        }
        if (hookEvent.forceKeepAttr) {
          continue;
        }
        _removeAttribute(name, currentNode);
        if (!hookEvent.keepAttr) {
          continue;
        }
        if (!ALLOW_SELF_CLOSE_IN_ATTR && regExpTest(/\/>/i, value)) {
          _removeAttribute(name, currentNode);
          continue;
        }
        if (SAFE_FOR_TEMPLATES) {
          arrayForEach([MUSTACHE_EXPR2, ERB_EXPR2, TMPLIT_EXPR2], (expr) => {
            value = stringReplace(value, expr, " ");
          });
        }
        const lcTag = transformCaseFunc(currentNode.nodeName);
        if (!_isValidAttribute(lcTag, lcName, value)) {
          continue;
        }
        if (trustedTypesPolicy && typeof trustedTypes === "object" && typeof trustedTypes.getAttributeType === "function") {
          if (namespaceURI) ;
          else {
            switch (trustedTypes.getAttributeType(lcTag, lcName)) {
              case "TrustedHTML": {
                value = trustedTypesPolicy.createHTML(value);
                break;
              }
              case "TrustedScriptURL": {
                value = trustedTypesPolicy.createScriptURL(value);
                break;
              }
            }
          }
        }
        try {
          if (namespaceURI) {
            currentNode.setAttributeNS(namespaceURI, name, value);
          } else {
            currentNode.setAttribute(name, value);
          }
          if (_isClobbered(currentNode)) {
            _forceRemove(currentNode);
          } else {
            arrayPop(DOMPurify.removed);
          }
        } catch (_2) {
        }
      }
      _executeHooks(hooks.afterSanitizeAttributes, currentNode, null);
    };
    const _sanitizeShadowDOM = function _sanitizeShadowDOM2(fragment) {
      let shadowNode = null;
      const shadowIterator = _createNodeIterator(fragment);
      _executeHooks(hooks.beforeSanitizeShadowDOM, fragment, null);
      while (shadowNode = shadowIterator.nextNode()) {
        _executeHooks(hooks.uponSanitizeShadowNode, shadowNode, null);
        _sanitizeElements(shadowNode);
        _sanitizeAttributes(shadowNode);
        if (shadowNode.content instanceof DocumentFragment) {
          _sanitizeShadowDOM2(shadowNode.content);
        }
      }
      _executeHooks(hooks.afterSanitizeShadowDOM, fragment, null);
    };
    DOMPurify.sanitize = function(dirty) {
      let cfg = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      let body = null;
      let importedNode = null;
      let currentNode = null;
      let returnNode = null;
      IS_EMPTY_INPUT = !dirty;
      if (IS_EMPTY_INPUT) {
        dirty = "<!-->";
      }
      if (typeof dirty !== "string" && !_isNode(dirty)) {
        if (typeof dirty.toString === "function") {
          dirty = dirty.toString();
          if (typeof dirty !== "string") {
            throw typeErrorCreate("dirty is not a string, aborting");
          }
        } else {
          throw typeErrorCreate("toString is not a function");
        }
      }
      if (!DOMPurify.isSupported) {
        return dirty;
      }
      if (!SET_CONFIG) {
        _parseConfig(cfg);
      }
      DOMPurify.removed = [];
      if (typeof dirty === "string") {
        IN_PLACE = false;
      }
      if (IN_PLACE) {
        if (dirty.nodeName) {
          const tagName = transformCaseFunc(dirty.nodeName);
          if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {
            throw typeErrorCreate("root node is forbidden and cannot be sanitized in-place");
          }
        }
      } else if (dirty instanceof Node3) {
        body = _initDocument("<!---->");
        importedNode = body.ownerDocument.importNode(dirty, true);
        if (importedNode.nodeType === NODE_TYPE.element && importedNode.nodeName === "BODY") {
          body = importedNode;
        } else if (importedNode.nodeName === "HTML") {
          body = importedNode;
        } else {
          body.appendChild(importedNode);
        }
      } else {
        if (!RETURN_DOM && !SAFE_FOR_TEMPLATES && !WHOLE_DOCUMENT && // eslint-disable-next-line unicorn/prefer-includes
        dirty.indexOf("<") === -1) {
          return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(dirty) : dirty;
        }
        body = _initDocument(dirty);
        if (!body) {
          return RETURN_DOM ? null : RETURN_TRUSTED_TYPE ? emptyHTML : "";
        }
      }
      if (body && FORCE_BODY) {
        _forceRemove(body.firstChild);
      }
      const nodeIterator = _createNodeIterator(IN_PLACE ? dirty : body);
      while (currentNode = nodeIterator.nextNode()) {
        _sanitizeElements(currentNode);
        _sanitizeAttributes(currentNode);
        if (currentNode.content instanceof DocumentFragment) {
          _sanitizeShadowDOM(currentNode.content);
        }
      }
      if (IN_PLACE) {
        return dirty;
      }
      if (RETURN_DOM) {
        if (RETURN_DOM_FRAGMENT) {
          returnNode = createDocumentFragment.call(body.ownerDocument);
          while (body.firstChild) {
            returnNode.appendChild(body.firstChild);
          }
        } else {
          returnNode = body;
        }
        if (ALLOWED_ATTR.shadowroot || ALLOWED_ATTR.shadowrootmode) {
          returnNode = importNode.call(originalDocument, returnNode, true);
        }
        return returnNode;
      }
      let serializedHTML = WHOLE_DOCUMENT ? body.outerHTML : body.innerHTML;
      if (WHOLE_DOCUMENT && ALLOWED_TAGS["!doctype"] && body.ownerDocument && body.ownerDocument.doctype && body.ownerDocument.doctype.name && regExpTest(DOCTYPE_NAME, body.ownerDocument.doctype.name)) {
        serializedHTML = "<!DOCTYPE " + body.ownerDocument.doctype.name + ">\n" + serializedHTML;
      }
      if (SAFE_FOR_TEMPLATES) {
        arrayForEach([MUSTACHE_EXPR2, ERB_EXPR2, TMPLIT_EXPR2], (expr) => {
          serializedHTML = stringReplace(serializedHTML, expr, " ");
        });
      }
      return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(serializedHTML) : serializedHTML;
    };
    DOMPurify.setConfig = function() {
      let cfg = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      _parseConfig(cfg);
      SET_CONFIG = true;
    };
    DOMPurify.clearConfig = function() {
      CONFIG2 = null;
      SET_CONFIG = false;
    };
    DOMPurify.isValidAttribute = function(tag, attr, value) {
      if (!CONFIG2) {
        _parseConfig({});
      }
      const lcTag = transformCaseFunc(tag);
      const lcName = transformCaseFunc(attr);
      return _isValidAttribute(lcTag, lcName, value);
    };
    DOMPurify.addHook = function(entryPoint, hookFunction) {
      if (typeof hookFunction !== "function") {
        return;
      }
      arrayPush(hooks[entryPoint], hookFunction);
    };
    DOMPurify.removeHook = function(entryPoint, hookFunction) {
      if (hookFunction !== void 0) {
        const index = arrayLastIndexOf(hooks[entryPoint], hookFunction);
        return index === -1 ? void 0 : arraySplice(hooks[entryPoint], index, 1)[0];
      }
      return arrayPop(hooks[entryPoint]);
    };
    DOMPurify.removeHooks = function(entryPoint) {
      hooks[entryPoint] = [];
    };
    DOMPurify.removeAllHooks = function() {
      hooks = _createHooksMap();
    };
    return DOMPurify;
  }
  var purify = createDOMPurify();
  class GZMusicExtractor extends GazelleExtractor {
    constructor() {
      super(...arguments);
      this.priority = 10;
      this._siteTorrentInfo = null;
      this._siteGroupInfo = null;
    }
    get siteGroupInfo() {
      if (!this._siteGroupInfo) {
        throw new Error("siteGroupInfo is not initialized");
      }
      return this._siteGroupInfo;
    }
    get siteTorrentInfo() {
      if (!this._siteTorrentInfo) {
        throw new Error("siteTorrentInfo is not initialized");
      }
      return this._siteTorrentInfo;
    }
    canHandle(siteName) {
      return siteName.match(/(DicMusic|Orpheus|RED)/) !== null;
    }
    async extract() {
      this.extractTorrentId();
      this.getTorrentHeaderDom();
      const data = await this.getSiteTorrentInfoByAPI();
      if (!data) {
        return this.info;
      }
      this._siteGroupInfo = data.group;
      this._siteTorrentInfo = data.torrent;
      this.extractTitle();
      this.extractSubtitle();
      this.extractTorrentLink();
      this.extractCategory();
      this.extractDescription();
      await this.extractLogs();
      const { year, wikiImage, musicInfo, name, tags: tags2 } = this.siteGroupInfo;
      this.info.year = `${year}`;
      this.info.poster = wikiImage;
      const { format: format2, media, encoding, log } = this.siteTorrentInfo;
      this.info.videoCodec = media.toLowerCase().replace(/-/g, "");
      this.info.audioCodec = format2.toLowerCase();
      this.info.musicInfo = {
        name,
        tags: tags2,
        artists: musicInfo.artists.map((item) => item.name),
        media,
        encoding,
        log
      };
      this.info.musicJson = data;
      return this.info;
    }
    async getSiteTorrentInfoByAPI() {
      const { response, status } = await GMFetch(
        `/ajax.php?action=torrent&id=${this.torrentId}`,
        {
          responseType: "json"
        }
      );
      if (status !== "success" || !response || !response.group || !response.torrent) {
        return null;
      }
      if (CURRENT_SITE_NAME === "DicMusic") {
        response.group.name = this.getUTF8String(response.group.name);
        const div = document.createElement("div");
        div.innerHTML = response.group.wikiBody;
        response.group.bbBody = htmlToBBCode(div);
      } else if (CURRENT_SITE_NAME === "Orpheus") {
        response.group.bbBody = response.group.wikiBBcode || "";
      }
      return response;
    }
    getTorrentHeaderDom() {
      this.torrentHeaderDom = $$2(`#torrent${this.torrentId}`);
    }
    extractTitle() {
      const title = $$2(".header h2").text();
      this.info.title = formatTorrentTitle(title);
    }
    extractSubtitle() {
      const {
        media,
        encoding,
        format: format2,
        remasterRecordLabel,
        remasterCatalogueNumber
      } = this.siteTorrentInfo;
      let subtitle = `[${media} / ${encoding} / ${format2}]`;
      if (remasterRecordLabel) {
        subtitle += ` / ${remasterRecordLabel}`;
      }
      if (remasterCatalogueNumber) {
        subtitle += ` / ${remasterCatalogueNumber}`;
      }
      this.info.subtitle = subtitle;
    }
    extractCategory() {
      this.info.category = getCategoryFromSource(this.siteGroupInfo.categoryName);
    }
    extractTorrentLink() {
      const torrentLink = this.torrentHeaderDom.find('a[href*="download"]').attr("href");
      CURRENT_SITE_INFO.torrentLink = torrentLink;
    }
    extractDescription() {
      const { wikiImage, wikiBody, bbBody } = this.siteGroupInfo;
      const div = document.createElement("div");
      div.innerHTML = wikiBody;
      let description = bbBody || htmlToBBCode(div) || "";
      description = `[img]${wikiImage}[/img]
${description}`;
      description = purify.sanitize(description);
      const descSource = new DOMParser().parseFromString(
        description,
        "text/html"
      );
      if (descSource.documentElement.textContent) {
        description = descSource.documentElement.textContent.replace(/\[\/?artist\]/g, "").replace(
          /\[url=https:\/\/redacted\.ch\/torrents\.php\?(taglist|recordlabel)=[a-zA-Z%0-9]*\]/g,
          ""
        ).replace(new RegExp("(?<=(\\[\\/b\\]|,)[\\s\\\\.a-zA-Z]*)\\[\\/url\\]", "g"), "");
      }
      this.info.description = description;
    }
    async extractLogs() {
      const { logScore, ripLogIds } = this.siteTorrentInfo;
      const { media } = this.siteTorrentInfo;
      const logList = [];
      if ((ripLogIds == null ? void 0 : ripLogIds.length) > 0) {
        for (let i = 1; i < ripLogIds.length; i++) {
          const log = await this.getLogFromApi(
            logScore,
            this.torrentId,
            ripLogIds[i]
          );
          logList.push(log);
        }
      } else if (media === "CD") {
        const logData = await this.getLogFromApi(logScore, this.torrentId, "0");
        if (logData) {
          logList.push(logData);
        }
      }
      this.siteTorrentInfo.log = logList;
    }
    getUTF8String(entityString) {
      const tempElement = document.createElement("textarea");
      tempElement.innerHTML = entityString;
      const utf8String = tempElement.value;
      return utf8String;
    }
    async getLogFromApi(logScore, torrentId, ripLogId) {
      const apiUrlMap = CONFIG.MUSIC_LOG_API_MAP(logScore, torrentId, ripLogId);
      const response = await GMFetch(
        apiUrlMap[CURRENT_SITE_NAME]
      );
      if (CURRENT_SITE_NAME.match(/DicMusic|RED/)) {
        const div = document.createElement("div");
        div.innerHTML = response;
        return $$2(div).find("pre").text() || "";
      } else if (CURRENT_SITE_NAME.match(/Orpheus|/)) {
        return response;
      }
      return "";
    }
  }
  registry.register(new GZMusicExtractor());
  async function getTorrentInfo() {
    if (!CURRENT_SITE_INFO) {
      console.log("No site info found");
      return null;
    }
    const extractor = registry.getExtractor(
      CURRENT_SITE_NAME,
      CURRENT_SITE_INFO.siteType
    );
    if (!extractor) {
      console.log(`No extractor found for this site ${CURRENT_SITE_NAME}`);
      return null;
    }
    try {
      return await extractor.extract();
    } catch (error) {
      console.log("Error extracting torrent info", error);
      return null;
    }
  }
  const filterBluTorrent = (imdb = "", name = "") => {
    if (imdb) {
      $$2("#imdb").val(imdb);
    } else if (name) {
      $$2("#search").val(name);
    }
    const token = $$2('meta[name="csrf_token"]').attr("content");
    const url = `${CURRENT_SITE_INFO.url}/torrents/filter?search=${name}&imdb=${imdb}&_token=${token}&sorting=size&direction=desc`;
    GMFetch(url).then((data) => {
      $$2("#facetedSearch").html(data);
    });
  };
  const fillSearchImdb = () => {
    const imdbParam = getLocationSearchValueByKey("imdb");
    const nameParam = getLocationSearchValueByKey("name");
    if (imdbParam || nameParam) {
      if (CURRENT_SITE_INFO.siteType === "UNIT3D" && CURRENT_SITE_NAME !== "Blutopia") {
        filterBluTorrent(imdbParam, nameParam);
      } else if (CURRENT_SITE_NAME === "PTN") {
        $$2("#movieimdb").val(imdbParam);
        $$2("#moviename").val(nameParam);
      }
    }
  };
  class TorrentInfoStore {
    constructor() {
      this.listeners = /* @__PURE__ */ new Set();
      const cached = GM_getValue("cachedTorrentInfo");
      this.info = cached;
    }
    getInfo() {
      return this.info;
    }
    setInfo(info) {
      if (info && info.title) {
        this.info = info;
        GM_setValue("cachedTorrentInfo", info);
        this.listeners.forEach((listener) => listener(info));
      }
    }
    updateInfo(updater) {
      if (!this.info) return;
      const newInfo = typeof updater === "function" ? updater(this.info) : __spreadValues(__spreadValues({}, this.info), updater);
      this.setInfo(newInfo);
    }
    subscribe(listener) {
      this.listeners.add(listener);
      return () => this.listeners.delete(listener);
    }
  }
  const torrentInfoStore = new TorrentInfoStore();
  var t, r, u, i$1, o = 0, f = [], c = preact.options, e = c.__b, a = c.__r, v$1 = c.diffed, l = c.__c, m = c.unmount, s = c.__;
  function d(n, t2) {
    c.__h && c.__h(r, n, o || t2), o = 0;
    var u2 = r.__H || (r.__H = { __: [], __h: [] });
    return n >= u2.__.length && u2.__.push({}), u2.__[n];
  }
  function h(n) {
    return o = 1, p(D$1, n);
  }
  function p(n, u2, i) {
    var o2 = d(t++, 2);
    if (o2.t = n, !o2.__c && (o2.__ = [i ? i(u2) : D$1(void 0, u2), function(n2) {
      var t2 = o2.__N ? o2.__N[0] : o2.__[0], r2 = o2.t(t2, n2);
      t2 !== r2 && (o2.__N = [r2, o2.__[1]], o2.__c.setState({}));
    }], o2.__c = r, !r.u)) {
      var f2 = function(n2, t2, r2) {
        if (!o2.__c.__H) return true;
        var u3 = o2.__c.__H.__.filter(function(n3) {
          return !!n3.__c;
        });
        if (u3.every(function(n3) {
          return !n3.__N;
        })) return !c2 || c2.call(this, n2, t2, r2);
        var i2 = false;
        return u3.forEach(function(n3) {
          if (n3.__N) {
            var t3 = n3.__[0];
            n3.__ = n3.__N, n3.__N = void 0, t3 !== n3.__[0] && (i2 = true);
          }
        }), !(!i2 && o2.__c.props === n2) && (!c2 || c2.call(this, n2, t2, r2));
      };
      r.u = true;
      var c2 = r.shouldComponentUpdate, e2 = r.componentWillUpdate;
      r.componentWillUpdate = function(n2, t2, r2) {
        if (this.__e) {
          var u3 = c2;
          c2 = void 0, f2(n2, t2, r2), c2 = u3;
        }
        e2 && e2.call(this, n2, t2, r2);
      }, r.shouldComponentUpdate = f2;
    }
    return o2.__N || o2.__;
  }
  function y(n, u2) {
    var i = d(t++, 3);
    !c.__s && C$1(i.__H, u2) && (i.__ = n, i.i = u2, r.__H.__h.push(i));
  }
  function _(n, u2) {
    var i = d(t++, 4);
    !c.__s && C$1(i.__H, u2) && (i.__ = n, i.i = u2, r.__h.push(i));
  }
  function A$1(n) {
    return o = 5, T$1(function() {
      return { current: n };
    }, []);
  }
  function F$1(n, t2, r2) {
    o = 6, _(function() {
      return "function" == typeof n ? (n(t2()), function() {
        return n(null);
      }) : n ? (n.current = t2(), function() {
        return n.current = null;
      }) : void 0;
    }, null == r2 ? r2 : r2.concat(n));
  }
  function T$1(n, r2) {
    var u2 = d(t++, 7);
    return C$1(u2.__H, r2) && (u2.__ = n(), u2.__H = r2, u2.__h = n), u2.__;
  }
  function q$1(n, t2) {
    return o = 8, T$1(function() {
      return n;
    }, t2);
  }
  function x$1(n) {
    var u2 = r.context[n.__c], i = d(t++, 9);
    return i.c = n, u2 ? (null == i.__ && (i.__ = true, u2.sub(r)), u2.props.value) : n.__;
  }
  function P$1(n, t2) {
    c.useDebugValue && c.useDebugValue(t2 ? t2(n) : n);
  }
  function g$1() {
    var n = d(t++, 11);
    if (!n.__) {
      for (var u2 = r.__v; null !== u2 && !u2.__m && null !== u2.__; ) u2 = u2.__;
      var i = u2.__m || (u2.__m = [0, 0]);
      n.__ = "P" + i[0] + "-" + i[1]++;
    }
    return n.__;
  }
  function j$1() {
    for (var n; n = f.shift(); ) if (n.__P && n.__H) try {
      n.__H.__h.forEach(z$1), n.__H.__h.forEach(B$1), n.__H.__h = [];
    } catch (t2) {
      n.__H.__h = [], c.__e(t2, n.__v);
    }
  }
  c.__b = function(n) {
    r = null, e && e(n);
  }, c.__ = function(n, t2) {
    n && t2.__k && t2.__k.__m && (n.__m = t2.__k.__m), s && s(n, t2);
  }, c.__r = function(n) {
    a && a(n), t = 0;
    var i = (r = n.__c).__H;
    i && (u === r ? (i.__h = [], r.__h = [], i.__.forEach(function(n2) {
      n2.__N && (n2.__ = n2.__N), n2.i = n2.__N = void 0;
    })) : (i.__h.forEach(z$1), i.__h.forEach(B$1), i.__h = [], t = 0)), u = r;
  }, c.diffed = function(n) {
    v$1 && v$1(n);
    var t2 = n.__c;
    t2 && t2.__H && (t2.__H.__h.length && (1 !== f.push(t2) && i$1 === c.requestAnimationFrame || ((i$1 = c.requestAnimationFrame) || w$1)(j$1)), t2.__H.__.forEach(function(n2) {
      n2.i && (n2.__H = n2.i), n2.i = void 0;
    })), u = r = null;
  }, c.__c = function(n, t2) {
    t2.some(function(n2) {
      try {
        n2.__h.forEach(z$1), n2.__h = n2.__h.filter(function(n3) {
          return !n3.__ || B$1(n3);
        });
      } catch (r2) {
        t2.some(function(n3) {
          n3.__h && (n3.__h = []);
        }), t2 = [], c.__e(r2, n2.__v);
      }
    }), l && l(n, t2);
  }, c.unmount = function(n) {
    m && m(n);
    var t2, r2 = n.__c;
    r2 && r2.__H && (r2.__H.__.forEach(function(n2) {
      try {
        z$1(n2);
      } catch (n3) {
        t2 = n3;
      }
    }), r2.__H = void 0, t2 && c.__e(t2, r2.__v));
  };
  var k$1 = "function" == typeof requestAnimationFrame;
  function w$1(n) {
    var t2, r2 = function() {
      clearTimeout(u2), k$1 && cancelAnimationFrame(t2), setTimeout(n);
    }, u2 = setTimeout(r2, 100);
    k$1 && (t2 = requestAnimationFrame(r2));
  }
  function z$1(n) {
    var t2 = r, u2 = n.__c;
    "function" == typeof u2 && (n.__c = void 0, u2()), r = t2;
  }
  function B$1(n) {
    var t2 = r;
    n.__c = n.__(), r = t2;
  }
  function C$1(n, t2) {
    return !n || n.length !== t2.length || t2.some(function(t3, r2) {
      return t3 !== n[r2];
    });
  }
  function D$1(n, t2) {
    return "function" == typeof t2 ? t2(n) : t2;
  }
  function g(n, t2) {
    for (var e2 in n) if ("__source" !== e2 && !(e2 in t2)) return true;
    for (var r2 in t2) if ("__source" !== r2 && n[r2] !== t2[r2]) return true;
    return false;
  }
  function E(n, t2) {
    this.props = n, this.context = t2;
  }
  function C(n, e2) {
    function r2(n2) {
      var t2 = this.props.ref, r3 = t2 == n2.ref;
      return !r3 && t2 && (t2.call ? t2(null) : t2.current = null), e2 ? !e2(this.props, n2) || !r3 : g(this.props, n2);
    }
    function u2(e3) {
      return this.shouldComponentUpdate = r2, preact.createElement(n, e3);
    }
    return u2.displayName = "Memo(" + (n.displayName || n.name) + ")", u2.prototype.isReactComponent = true, u2.__f = true, u2;
  }
  (E.prototype = new preact.Component()).isPureReactComponent = true, E.prototype.shouldComponentUpdate = function(n, t2) {
    return g(this.props, n) || g(this.state, t2);
  };
  var x = preact.options.__b;
  preact.options.__b = function(n) {
    n.type && n.type.__f && n.ref && (n.props.ref = n.ref, n.ref = null), x && x(n);
  };
  var R = "undefined" != typeof Symbol && Symbol.for && Symbol.for("react.forward_ref") || 3911;
  function w(n) {
    function t2(t3) {
      if (!("ref" in t3)) return n(t3, null);
      var e2 = t3.ref;
      delete t3.ref;
      var r2 = n(t3, e2);
      return t3.ref = e2, r2;
    }
    return t2.$$typeof = R, t2.render = t2, t2.prototype.isReactComponent = t2.__f = true, t2.displayName = "ForwardRef(" + (n.displayName || n.name) + ")", t2;
  }
  var k = function(n, t2) {
    return null == n ? null : preact.toChildArray(preact.toChildArray(n).map(t2));
  }, I = { map: k, forEach: k, count: function(n) {
    return n ? preact.toChildArray(n).length : 0;
  }, only: function(n) {
    var t2 = preact.toChildArray(n);
    if (1 !== t2.length) throw "Children.only";
    return t2[0];
  }, toArray: preact.toChildArray }, N = preact.options.__e;
  preact.options.__e = function(n, t2, e2, r2) {
    if (n.then) {
      for (var u2, o2 = t2; o2 = o2.__; ) if ((u2 = o2.__c) && u2.__c) return null == t2.__e && (t2.__e = e2.__e, t2.__k = e2.__k), u2.__c(n, t2);
    }
    N(n, t2, e2, r2);
  };
  var M = preact.options.unmount;
  function T(n, t2, e2) {
    return n && (n.__c && n.__c.__H && (n.__c.__H.__.forEach(function(n2) {
      "function" == typeof n2.__c && n2.__c();
    }), n.__c.__H = null), null != (n = function(n2, t3) {
      for (var e3 in t3) n2[e3] = t3[e3];
      return n2;
    }({}, n)).__c && (n.__c.__P === e2 && (n.__c.__P = t2), n.__c = null), n.__k = n.__k && n.__k.map(function(n2) {
      return T(n2, t2, e2);
    })), n;
  }
  function A(n, t2, e2) {
    return n && e2 && (n.__v = null, n.__k = n.__k && n.__k.map(function(n2) {
      return A(n2, t2, e2);
    }), n.__c && n.__c.__P === t2 && (n.__e && e2.appendChild(n.__e), n.__c.__e = true, n.__c.__P = e2)), n;
  }
  function D() {
    this.__u = 0, this.t = null, this.__b = null;
  }
  function L(n) {
    var t2 = n.__.__c;
    return t2 && t2.__a && t2.__a(n);
  }
  function O(n) {
    var e2, r2, u2;
    function o2(o3) {
      if (e2 || (e2 = n()).then(function(n2) {
        r2 = n2.default || n2;
      }, function(n2) {
        u2 = n2;
      }), u2) throw u2;
      if (!r2) throw e2;
      return preact.createElement(r2, o3);
    }
    return o2.displayName = "Lazy", o2.__f = true, o2;
  }
  function F() {
    this.u = null, this.o = null;
  }
  preact.options.unmount = function(n) {
    var t2 = n.__c;
    t2 && t2.__R && t2.__R(), t2 && 32 & n.__u && (n.type = null), M && M(n);
  }, (D.prototype = new preact.Component()).__c = function(n, t2) {
    var e2 = t2.__c, r2 = this;
    null == r2.t && (r2.t = []), r2.t.push(e2);
    var u2 = L(r2.__v), o2 = false, i = function() {
      o2 || (o2 = true, e2.__R = null, u2 ? u2(c2) : c2());
    };
    e2.__R = i;
    var c2 = function() {
      if (!--r2.__u) {
        if (r2.state.__a) {
          var n2 = r2.state.__a;
          r2.__v.__k[0] = A(n2, n2.__c.__P, n2.__c.__O);
        }
        var t3;
        for (r2.setState({ __a: r2.__b = null }); t3 = r2.t.pop(); ) t3.forceUpdate();
      }
    };
    r2.__u++ || 32 & t2.__u || r2.setState({ __a: r2.__b = r2.__v.__k[0] }), n.then(i, i);
  }, D.prototype.componentWillUnmount = function() {
    this.t = [];
  }, D.prototype.render = function(n, e2) {
    if (this.__b) {
      if (this.__v.__k) {
        var r2 = document.createElement("div"), o2 = this.__v.__k[0].__c;
        this.__v.__k[0] = T(this.__b, r2, o2.__O = o2.__P);
      }
      this.__b = null;
    }
    var i = e2.__a && preact.createElement(preact.Fragment, null, n.fallback);
    return i && (i.__u &= -33), [preact.createElement(preact.Fragment, null, e2.__a ? null : n.children), i];
  };
  var U$1 = function(n, t2, e2) {
    if (++e2[1] === e2[0] && n.o.delete(t2), n.props.revealOrder && ("t" !== n.props.revealOrder[0] || !n.o.size)) for (e2 = n.u; e2; ) {
      for (; e2.length > 3; ) e2.pop()();
      if (e2[1] < e2[0]) break;
      n.u = e2 = e2[2];
    }
  };
  function V(n) {
    return this.getChildContext = function() {
      return n.context;
    }, n.children;
  }
  function W(n) {
    var e2 = this, r2 = n.i;
    e2.componentWillUnmount = function() {
      preact.render(null, e2.l), e2.l = null, e2.i = null;
    }, e2.i && e2.i !== r2 && e2.componentWillUnmount(), e2.l || (e2.i = r2, e2.l = { nodeType: 1, parentNode: r2, childNodes: [], contains: function() {
      return true;
    }, appendChild: function(n2) {
      this.childNodes.push(n2), e2.i.appendChild(n2);
    }, insertBefore: function(n2, t2) {
      this.childNodes.push(n2), e2.i.appendChild(n2);
    }, removeChild: function(n2) {
      this.childNodes.splice(this.childNodes.indexOf(n2) >>> 1, 1), e2.i.removeChild(n2);
    } }), preact.render(preact.createElement(V, { context: e2.context }, n.__v), e2.l);
  }
  function P(n, e2) {
    var r2 = preact.createElement(W, { __v: n, i: e2 });
    return r2.containerInfo = e2, r2;
  }
  (F.prototype = new preact.Component()).__a = function(n) {
    var t2 = this, e2 = L(t2.__v), r2 = t2.o.get(n);
    return r2[0]++, function(u2) {
      var o2 = function() {
        t2.props.revealOrder ? (r2.push(u2), U$1(t2, n, r2)) : u2();
      };
      e2 ? e2(o2) : o2();
    };
  }, F.prototype.render = function(n) {
    this.u = null, this.o = /* @__PURE__ */ new Map();
    var t2 = preact.toChildArray(n.children);
    n.revealOrder && "b" === n.revealOrder[0] && t2.reverse();
    for (var e2 = t2.length; e2--; ) this.o.set(t2[e2], this.u = [1, 0, this.u]);
    return n.children;
  }, F.prototype.componentDidUpdate = F.prototype.componentDidMount = function() {
    var n = this;
    this.o.forEach(function(t2, e2) {
      U$1(n, e2, t2);
    });
  };
  var j = "undefined" != typeof Symbol && Symbol.for && Symbol.for("react.element") || 60103, z = /^(?:accent|alignment|arabic|baseline|cap|clip(?!PathU)|color|dominant|fill|flood|font|glyph(?!R)|horiz|image(!S)|letter|lighting|marker(?!H|W|U)|overline|paint|pointer|shape|stop|strikethrough|stroke|text(?!L)|transform|underline|unicode|units|v|vector|vert|word|writing|x(?!C))[A-Z]/, B = /^on(Ani|Tra|Tou|BeforeInp|Compo)/, H = /[A-Z0-9]/g, Z = "undefined" != typeof document, Y = function(n) {
    return ("undefined" != typeof Symbol && "symbol" == typeof Symbol() ? /fil|che|rad/ : /fil|che|ra/).test(n);
  };
  function $$1(n, t2, e2) {
    return null == t2.__k && (t2.textContent = ""), preact.render(n, t2), "function" == typeof e2 && e2(), n ? n.__c : null;
  }
  function q(n, t2, e2) {
    return preact.hydrate(n, t2), "function" == typeof e2 && e2(), n ? n.__c : null;
  }
  preact.Component.prototype.isReactComponent = {}, ["componentWillMount", "componentWillReceiveProps", "componentWillUpdate"].forEach(function(t2) {
    Object.defineProperty(preact.Component.prototype, t2, { configurable: true, get: function() {
      return this["UNSAFE_" + t2];
    }, set: function(n) {
      Object.defineProperty(this, t2, { configurable: true, writable: true, value: n });
    } });
  });
  var G = preact.options.event;
  function J() {
  }
  function K() {
    return this.cancelBubble;
  }
  function Q() {
    return this.defaultPrevented;
  }
  preact.options.event = function(n) {
    return G && (n = G(n)), n.persist = J, n.isPropagationStopped = K, n.isDefaultPrevented = Q, n.nativeEvent = n;
  };
  var X, nn = { enumerable: false, configurable: true, get: function() {
    return this.class;
  } }, tn = preact.options.vnode;
  preact.options.vnode = function(n) {
    "string" == typeof n.type && function(n2) {
      var t2 = n2.props, e2 = n2.type, u2 = {}, o2 = -1 === e2.indexOf("-");
      for (var i in t2) {
        var c2 = t2[i];
        if (!("value" === i && "defaultValue" in t2 && null == c2 || Z && "children" === i && "noscript" === e2 || "class" === i || "className" === i)) {
          var f2 = i.toLowerCase();
          "defaultValue" === i && "value" in t2 && null == t2.value ? i = "value" : "download" === i && true === c2 ? c2 = "" : "translate" === f2 && "no" === c2 ? c2 = false : "o" === f2[0] && "n" === f2[1] ? "ondoubleclick" === f2 ? i = "ondblclick" : "onchange" !== f2 || "input" !== e2 && "textarea" !== e2 || Y(t2.type) ? "onfocus" === f2 ? i = "onfocusin" : "onblur" === f2 ? i = "onfocusout" : B.test(i) && (i = f2) : f2 = i = "oninput" : o2 && z.test(i) ? i = i.replace(H, "-$&").toLowerCase() : null === c2 && (c2 = void 0), "oninput" === f2 && u2[i = f2] && (i = "oninputCapture"), u2[i] = c2;
        }
      }
      "select" == e2 && u2.multiple && Array.isArray(u2.value) && (u2.value = preact.toChildArray(t2.children).forEach(function(n3) {
        n3.props.selected = -1 != u2.value.indexOf(n3.props.value);
      })), "select" == e2 && null != u2.defaultValue && (u2.value = preact.toChildArray(t2.children).forEach(function(n3) {
        n3.props.selected = u2.multiple ? -1 != u2.defaultValue.indexOf(n3.props.value) : u2.defaultValue == n3.props.value;
      })), t2.class && !t2.className ? (u2.class = t2.class, Object.defineProperty(u2, "className", nn)) : (t2.className && !t2.class || t2.class && t2.className) && (u2.class = u2.className = t2.className), n2.props = u2;
    }(n), n.$$typeof = j, tn && tn(n);
  };
  var en = preact.options.__r;
  preact.options.__r = function(n) {
    en && en(n), X = n.__c;
  };
  var rn = preact.options.diffed;
  preact.options.diffed = function(n) {
    rn && rn(n);
    var t2 = n.props, e2 = n.__e;
    null != e2 && "textarea" === n.type && "value" in t2 && t2.value !== e2.value && (e2.value = null == t2.value ? "" : t2.value), X = null;
  };
  var un = { ReactCurrentDispatcher: { current: { readContext: function(n) {
    return X.__n[n.__c].props.value;
  }, useCallback: q$1, useContext: x$1, useDebugValue: P$1, useDeferredValue: _n, useEffect: y, useId: g$1, useImperativeHandle: F$1, useInsertionEffect: Sn, useLayoutEffect: _, useMemo: T$1, useReducer: p, useRef: A$1, useState: h, useSyncExternalStore: En, useTransition: bn } } };
  function cn(n) {
    return preact.createElement.bind(null, n);
  }
  function fn(n) {
    return !!n && n.$$typeof === j;
  }
  function ln(n) {
    return fn(n) && n.type === preact.Fragment;
  }
  function an(n) {
    return !!n && !!n.displayName && ("string" == typeof n.displayName || n.displayName instanceof String) && n.displayName.startsWith("Memo(");
  }
  function sn(n) {
    return fn(n) ? preact.cloneElement.apply(null, arguments) : n;
  }
  function hn(n) {
    return !!n.__k && (preact.render(null, n), true);
  }
  function vn(n) {
    return n && (n.base || 1 === n.nodeType && n) || null;
  }
  var dn = function(n, t2) {
    return n(t2);
  }, pn = function(n, t2) {
    return n(t2);
  }, mn = preact.Fragment;
  function yn(n) {
    n();
  }
  function _n(n) {
    return n;
  }
  function bn() {
    return [false, yn];
  }
  var Sn = _, gn = fn;
  function En(n, t2) {
    var e2 = t2(), r2 = h({ h: { __: e2, v: t2 } }), u2 = r2[0].h, o2 = r2[1];
    return _(function() {
      u2.__ = e2, u2.v = t2, Cn(u2) && o2({ h: u2 });
    }, [n, e2, t2]), y(function() {
      return Cn(u2) && o2({ h: u2 }), n(function() {
        Cn(u2) && o2({ h: u2 });
      });
    }, [n]), e2;
  }
  function Cn(n) {
    var t2, e2, r2 = n.v, u2 = n.__;
    try {
      var o2 = r2();
      return !((t2 = u2) === (e2 = o2) && (0 !== t2 || 1 / t2 == 1 / e2) || t2 != t2 && e2 != e2);
    } catch (n2) {
      return true;
    }
  }
  var xn = { useState: h, useId: g$1, useReducer: p, useEffect: y, useLayoutEffect: _, useInsertionEffect: Sn, useTransition: bn, useDeferredValue: _n, useSyncExternalStore: En, startTransition: yn, useRef: A$1, useImperativeHandle: F$1, useMemo: T$1, useCallback: q$1, useContext: x$1, useDebugValue: P$1, version: "18.3.1", Children: I, render: $$1, hydrate: q, unmountComponentAtNode: hn, createPortal: P, createElement: preact.createElement, createContext: preact.createContext, createFactory: cn, cloneElement: sn, createRef: preact.createRef, Fragment: preact.Fragment, isValidElement: fn, isElement: gn, isFragment: ln, isMemo: an, findDOMNode: vn, Component: preact.Component, PureComponent: E, memo: C, forwardRef: w, flushSync: pn, unstable_batchedUpdates: dn, StrictMode: mn, Suspense: D, SuspenseList: F, lazy: O, __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: un };
  var Ct = (s2) => {
    switch (s2) {
      case "success":
        return $t;
      case "info":
        return _t;
      case "warning":
        return Wt;
      case "error":
        return Ut;
      default:
        return null;
    }
  }, Ft = Array(12).fill(0), It = ({ visible: s2 }) => xn.createElement("div", { className: "sonner-loading-wrapper", "data-visible": s2 }, xn.createElement("div", { className: "sonner-spinner" }, Ft.map((o2, t2) => xn.createElement("div", { className: "sonner-loading-bar", key: `spinner-bar-${t2}` })))), $t = xn.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 20 20", fill: "currentColor", height: "20", width: "20" }, xn.createElement("path", { fillRule: "evenodd", d: "M10 18a8 8 0 100-16 8 8 0 000 16zm3.857-9.809a.75.75 0 00-1.214-.882l-3.483 4.79-1.88-1.88a.75.75 0 10-1.06 1.061l2.5 2.5a.75.75 0 001.137-.089l4-5.5z", clipRule: "evenodd" })), Wt = xn.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", fill: "currentColor", height: "20", width: "20" }, xn.createElement("path", { fillRule: "evenodd", d: "M9.401 3.003c1.155-2 4.043-2 5.197 0l7.355 12.748c1.154 2-.29 4.5-2.599 4.5H4.645c-2.309 0-3.752-2.5-2.598-4.5L9.4 3.003zM12 8.25a.75.75 0 01.75.75v3.75a.75.75 0 01-1.5 0V9a.75.75 0 01.75-.75zm0 8.25a.75.75 0 100-1.5.75.75 0 000 1.5z", clipRule: "evenodd" })), _t = xn.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 20 20", fill: "currentColor", height: "20", width: "20" }, xn.createElement("path", { fillRule: "evenodd", d: "M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a.75.75 0 000 1.5h.253a.25.25 0 01.244.304l-.459 2.066A1.75 1.75 0 0010.747 15H11a.75.75 0 000-1.5h-.253a.25.25 0 01-.244-.304l.459-2.066A1.75 1.75 0 009.253 9H9z", clipRule: "evenodd" })), Ut = xn.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 20 20", fill: "currentColor", height: "20", width: "20" }, xn.createElement("path", { fillRule: "evenodd", d: "M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-8-5a.75.75 0 01.75.75v4.5a.75.75 0 01-1.5 0v-4.5A.75.75 0 0110 5zm0 10a1 1 0 100-2 1 1 0 000 2z", clipRule: "evenodd" }));
  var Dt = () => {
    let [s2, o2] = xn.useState(document.hidden);
    return xn.useEffect(() => {
      let t2 = () => {
        o2(document.hidden);
      };
      return document.addEventListener("visibilitychange", t2), () => window.removeEventListener("visibilitychange", t2);
    }, []), s2;
  };
  var ct = 1, ut = class {
    constructor() {
      this.subscribe = (o2) => (this.subscribers.push(o2), () => {
        let t2 = this.subscribers.indexOf(o2);
        this.subscribers.splice(t2, 1);
      });
      this.publish = (o2) => {
        this.subscribers.forEach((t2) => t2(o2));
      };
      this.addToast = (o2) => {
        this.publish(o2), this.toasts = [...this.toasts, o2];
      };
      this.create = (o2) => {
        var b;
        let _a2 = o2, { message: t2 } = _a2, n = __objRest(_a2, ["message"]), h2 = typeof (o2 == null ? void 0 : o2.id) == "number" || ((b = o2.id) == null ? void 0 : b.length) > 0 ? o2.id : ct++, u2 = this.toasts.find((d2) => d2.id === h2), g2 = o2.dismissible === void 0 ? true : o2.dismissible;
        return u2 ? this.toasts = this.toasts.map((d2) => d2.id === h2 ? (this.publish(__spreadProps(__spreadValues(__spreadValues({}, d2), o2), { id: h2, title: t2 })), __spreadProps(__spreadValues(__spreadValues({}, d2), o2), { id: h2, dismissible: g2, title: t2 })) : d2) : this.addToast(__spreadProps(__spreadValues({ title: t2 }, n), { dismissible: g2, id: h2 })), h2;
      };
      this.dismiss = (o2) => (o2 || this.toasts.forEach((t2) => {
        this.subscribers.forEach((n) => n({ id: t2.id, dismiss: true }));
      }), this.subscribers.forEach((t2) => t2({ id: o2, dismiss: true })), o2);
      this.message = (o2, t2) => this.create(__spreadProps(__spreadValues({}, t2), { message: o2 }));
      this.error = (o2, t2) => this.create(__spreadProps(__spreadValues({}, t2), { message: o2, type: "error" }));
      this.success = (o2, t2) => this.create(__spreadProps(__spreadValues({}, t2), { type: "success", message: o2 }));
      this.info = (o2, t2) => this.create(__spreadProps(__spreadValues({}, t2), { type: "info", message: o2 }));
      this.warning = (o2, t2) => this.create(__spreadProps(__spreadValues({}, t2), { type: "warning", message: o2 }));
      this.loading = (o2, t2) => this.create(__spreadProps(__spreadValues({}, t2), { type: "loading", message: o2 }));
      this.promise = (o2, t2) => {
        if (!t2) return;
        let n;
        t2.loading !== void 0 && (n = this.create(__spreadProps(__spreadValues({}, t2), { promise: o2, type: "loading", message: t2.loading, description: typeof t2.description != "function" ? t2.description : void 0 })));
        let h2 = o2 instanceof Promise ? o2 : o2(), u2 = n !== void 0;
        return h2.then(async (g2) => {
          if (Ot(g2) && !g2.ok) {
            u2 = false;
            let b = typeof t2.error == "function" ? await t2.error(`HTTP error! status: ${g2.status}`) : t2.error, d2 = typeof t2.description == "function" ? await t2.description(`HTTP error! status: ${g2.status}`) : t2.description;
            this.create({ id: n, type: "error", message: b, description: d2 });
          } else if (t2.success !== void 0) {
            u2 = false;
            let b = typeof t2.success == "function" ? await t2.success(g2) : t2.success, d2 = typeof t2.description == "function" ? await t2.description(g2) : t2.description;
            this.create({ id: n, type: "success", message: b, description: d2 });
          }
        }).catch(async (g2) => {
          if (t2.error !== void 0) {
            u2 = false;
            let b = typeof t2.error == "function" ? await t2.error(g2) : t2.error, d2 = typeof t2.description == "function" ? await t2.description(g2) : t2.description;
            this.create({ id: n, type: "error", message: b, description: d2 });
          }
        }).finally(() => {
          var g2;
          u2 && (this.dismiss(n), n = void 0), (g2 = t2.finally) == null || g2.call(t2);
        }), n;
      };
      this.custom = (o2, t2) => {
        let n = (t2 == null ? void 0 : t2.id) || ct++;
        return this.create(__spreadValues({ jsx: o2(n), id: n }, t2)), n;
      };
      this.subscribers = [], this.toasts = [];
    }
  }, v = new ut(), Vt = (s2, o2) => {
    let t2 = (o2 == null ? void 0 : o2.id) || ct++;
    return v.addToast(__spreadProps(__spreadValues({ title: s2 }, o2), { id: t2 })), t2;
  }, Ot = (s2) => s2 && typeof s2 == "object" && "ok" in s2 && typeof s2.ok == "boolean" && "status" in s2 && typeof s2.status == "number", Kt = Vt, Xt = () => v.toasts, Jt = Object.assign(Kt, { success: v.success, info: v.info, warning: v.warning, error: v.error, custom: v.custom, message: v.message, promise: v.promise, dismiss: v.dismiss, loading: v.loading }, { getHistory: Xt });
  function ft(s2, { insertAt: o2 } = {}) {
    if (typeof document == "undefined") return;
    let t2 = document.head || document.getElementsByTagName("head")[0], n = document.createElement("style");
    n.type = "text/css", o2 === "top" && t2.firstChild ? t2.insertBefore(n, t2.firstChild) : t2.appendChild(n), n.styleSheet ? n.styleSheet.cssText = s2 : n.appendChild(document.createTextNode(s2));
  }
  ft(`:where(html[dir="ltr"]),:where([data-sonner-toaster][dir="ltr"]){--toast-icon-margin-start: -3px;--toast-icon-margin-end: 4px;--toast-svg-margin-start: -1px;--toast-svg-margin-end: 0px;--toast-button-margin-start: auto;--toast-button-margin-end: 0;--toast-close-button-start: 0;--toast-close-button-end: unset;--toast-close-button-transform: translate(-35%, -35%)}:where(html[dir="rtl"]),:where([data-sonner-toaster][dir="rtl"]){--toast-icon-margin-start: 4px;--toast-icon-margin-end: -3px;--toast-svg-margin-start: 0px;--toast-svg-margin-end: -1px;--toast-button-margin-start: 0;--toast-button-margin-end: auto;--toast-close-button-start: unset;--toast-close-button-end: 0;--toast-close-button-transform: translate(35%, -35%)}:where([data-sonner-toaster]){position:fixed;width:var(--width);font-family:ui-sans-serif,system-ui,-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica Neue,Arial,Noto Sans,sans-serif,Apple Color Emoji,Segoe UI Emoji,Segoe UI Symbol,Noto Color Emoji;--gray1: hsl(0, 0%, 99%);--gray2: hsl(0, 0%, 97.3%);--gray3: hsl(0, 0%, 95.1%);--gray4: hsl(0, 0%, 93%);--gray5: hsl(0, 0%, 90.9%);--gray6: hsl(0, 0%, 88.7%);--gray7: hsl(0, 0%, 85.8%);--gray8: hsl(0, 0%, 78%);--gray9: hsl(0, 0%, 56.1%);--gray10: hsl(0, 0%, 52.3%);--gray11: hsl(0, 0%, 43.5%);--gray12: hsl(0, 0%, 9%);--border-radius: 8px;box-sizing:border-box;padding:0;margin:0;list-style:none;outline:none;z-index:999999999}:where([data-sonner-toaster][data-x-position="right"]){right:max(var(--offset),env(safe-area-inset-right))}:where([data-sonner-toaster][data-x-position="left"]){left:max(var(--offset),env(safe-area-inset-left))}:where([data-sonner-toaster][data-x-position="center"]){left:50%;transform:translate(-50%)}:where([data-sonner-toaster][data-y-position="top"]){top:max(var(--offset),env(safe-area-inset-top))}:where([data-sonner-toaster][data-y-position="bottom"]){bottom:max(var(--offset),env(safe-area-inset-bottom))}:where([data-sonner-toast]){--y: translateY(100%);--lift-amount: calc(var(--lift) * var(--gap));z-index:var(--z-index);position:absolute;opacity:0;transform:var(--y);filter:blur(0);touch-action:none;transition:transform .4s,opacity .4s,height .4s,box-shadow .2s;box-sizing:border-box;outline:none;overflow-wrap:anywhere}:where([data-sonner-toast][data-styled="true"]){padding:16px;background:var(--normal-bg);border:1px solid var(--normal-border);color:var(--normal-text);border-radius:var(--border-radius);box-shadow:0 4px 12px #0000001a;width:var(--width);font-size:13px;display:flex;align-items:center;gap:6px}:where([data-sonner-toast]:focus-visible){box-shadow:0 4px 12px #0000001a,0 0 0 2px #0003}:where([data-sonner-toast][data-y-position="top"]){top:0;--y: translateY(-100%);--lift: 1;--lift-amount: calc(1 * var(--gap))}:where([data-sonner-toast][data-y-position="bottom"]){bottom:0;--y: translateY(100%);--lift: -1;--lift-amount: calc(var(--lift) * var(--gap))}:where([data-sonner-toast]) :where([data-description]){font-weight:400;line-height:1.4;color:inherit}:where([data-sonner-toast]) :where([data-title]){font-weight:500;line-height:1.5;color:inherit}:where([data-sonner-toast]) :where([data-icon]){display:flex;height:16px;width:16px;position:relative;justify-content:flex-start;align-items:center;flex-shrink:0;margin-left:var(--toast-icon-margin-start);margin-right:var(--toast-icon-margin-end)}:where([data-sonner-toast][data-promise="true"]) :where([data-icon])>svg{opacity:0;transform:scale(.8);transform-origin:center;animation:sonner-fade-in .3s ease forwards}:where([data-sonner-toast]) :where([data-icon])>*{flex-shrink:0}:where([data-sonner-toast]) :where([data-icon]) svg{margin-left:var(--toast-svg-margin-start);margin-right:var(--toast-svg-margin-end)}:where([data-sonner-toast]) :where([data-content]){display:flex;flex-direction:column;gap:2px}[data-sonner-toast][data-styled=true] [data-button]{border-radius:4px;padding-left:8px;padding-right:8px;height:24px;font-size:12px;color:var(--normal-bg);background:var(--normal-text);margin-left:var(--toast-button-margin-start);margin-right:var(--toast-button-margin-end);border:none;cursor:pointer;outline:none;display:flex;align-items:center;flex-shrink:0;transition:opacity .4s,box-shadow .2s}:where([data-sonner-toast]) :where([data-button]):focus-visible{box-shadow:0 0 0 2px #0006}:where([data-sonner-toast]) :where([data-button]):first-of-type{margin-left:var(--toast-button-margin-start);margin-right:var(--toast-button-margin-end)}:where([data-sonner-toast]) :where([data-cancel]){color:var(--normal-text);background:rgba(0,0,0,.08)}:where([data-sonner-toast][data-theme="dark"]) :where([data-cancel]){background:rgba(255,255,255,.3)}:where([data-sonner-toast]) :where([data-close-button]){position:absolute;left:var(--toast-close-button-start);right:var(--toast-close-button-end);top:0;height:20px;width:20px;display:flex;justify-content:center;align-items:center;padding:0;background:var(--gray1);color:var(--gray12);border:1px solid var(--gray4);transform:var(--toast-close-button-transform);border-radius:50%;cursor:pointer;z-index:1;transition:opacity .1s,background .2s,border-color .2s}:where([data-sonner-toast]) :where([data-close-button]):focus-visible{box-shadow:0 4px 12px #0000001a,0 0 0 2px #0003}:where([data-sonner-toast]) :where([data-disabled="true"]){cursor:not-allowed}:where([data-sonner-toast]):hover :where([data-close-button]):hover{background:var(--gray2);border-color:var(--gray5)}:where([data-sonner-toast][data-swiping="true"]):before{content:"";position:absolute;left:0;right:0;height:100%;z-index:-1}:where([data-sonner-toast][data-y-position="top"][data-swiping="true"]):before{bottom:50%;transform:scaleY(3) translateY(50%)}:where([data-sonner-toast][data-y-position="bottom"][data-swiping="true"]):before{top:50%;transform:scaleY(3) translateY(-50%)}:where([data-sonner-toast][data-swiping="false"][data-removed="true"]):before{content:"";position:absolute;inset:0;transform:scaleY(2)}:where([data-sonner-toast]):after{content:"";position:absolute;left:0;height:calc(var(--gap) + 1px);bottom:100%;width:100%}:where([data-sonner-toast][data-mounted="true"]){--y: translateY(0);opacity:1}:where([data-sonner-toast][data-expanded="false"][data-front="false"]){--scale: var(--toasts-before) * .05 + 1;--y: translateY(calc(var(--lift-amount) * var(--toasts-before))) scale(calc(-1 * var(--scale)));height:var(--front-toast-height)}:where([data-sonner-toast])>*{transition:opacity .4s}:where([data-sonner-toast][data-expanded="false"][data-front="false"][data-styled="true"])>*{opacity:0}:where([data-sonner-toast][data-visible="false"]){opacity:0;pointer-events:none}:where([data-sonner-toast][data-mounted="true"][data-expanded="true"]){--y: translateY(calc(var(--lift) * var(--offset)));height:var(--initial-height)}:where([data-sonner-toast][data-removed="true"][data-front="true"][data-swipe-out="false"]){--y: translateY(calc(var(--lift) * -100%));opacity:0}:where([data-sonner-toast][data-removed="true"][data-front="false"][data-swipe-out="false"][data-expanded="true"]){--y: translateY(calc(var(--lift) * var(--offset) + var(--lift) * -100%));opacity:0}:where([data-sonner-toast][data-removed="true"][data-front="false"][data-swipe-out="false"][data-expanded="false"]){--y: translateY(40%);opacity:0;transition:transform .5s,opacity .2s}:where([data-sonner-toast][data-removed="true"][data-front="false"]):before{height:calc(var(--initial-height) + 20%)}[data-sonner-toast][data-swiping=true]{transform:var(--y) translateY(var(--swipe-amount, 0px));transition:none}[data-sonner-toast][data-swipe-out=true][data-y-position=bottom],[data-sonner-toast][data-swipe-out=true][data-y-position=top]{animation:swipe-out .2s ease-out forwards}@keyframes swipe-out{0%{transform:translateY(calc(var(--lift) * var(--offset) + var(--swipe-amount)));opacity:1}to{transform:translateY(calc(var(--lift) * var(--offset) + var(--swipe-amount) + var(--lift) * -100%));opacity:0}}@media (max-width: 600px){[data-sonner-toaster]{position:fixed;--mobile-offset: 16px;right:var(--mobile-offset);left:var(--mobile-offset);width:100%}[data-sonner-toaster] [data-sonner-toast]{left:0;right:0;width:calc(100% - var(--mobile-offset) * 2)}[data-sonner-toaster][data-x-position=left]{left:var(--mobile-offset)}[data-sonner-toaster][data-y-position=bottom]{bottom:20px}[data-sonner-toaster][data-y-position=top]{top:20px}[data-sonner-toaster][data-x-position=center]{left:var(--mobile-offset);right:var(--mobile-offset);transform:none}}[data-sonner-toaster][data-theme=light]{--normal-bg: #fff;--normal-border: var(--gray4);--normal-text: var(--gray12);--success-bg: hsl(143, 85%, 96%);--success-border: hsl(145, 92%, 91%);--success-text: hsl(140, 100%, 27%);--info-bg: hsl(208, 100%, 97%);--info-border: hsl(221, 91%, 91%);--info-text: hsl(210, 92%, 45%);--warning-bg: hsl(49, 100%, 97%);--warning-border: hsl(49, 91%, 91%);--warning-text: hsl(31, 92%, 45%);--error-bg: hsl(359, 100%, 97%);--error-border: hsl(359, 100%, 94%);--error-text: hsl(360, 100%, 45%)}[data-sonner-toaster][data-theme=light] [data-sonner-toast][data-invert=true]{--normal-bg: #000;--normal-border: hsl(0, 0%, 20%);--normal-text: var(--gray1)}[data-sonner-toaster][data-theme=dark] [data-sonner-toast][data-invert=true]{--normal-bg: #fff;--normal-border: var(--gray3);--normal-text: var(--gray12)}[data-sonner-toaster][data-theme=dark]{--normal-bg: #000;--normal-border: hsl(0, 0%, 20%);--normal-text: var(--gray1);--success-bg: hsl(150, 100%, 6%);--success-border: hsl(147, 100%, 12%);--success-text: hsl(150, 86%, 65%);--info-bg: hsl(215, 100%, 6%);--info-border: hsl(223, 100%, 12%);--info-text: hsl(216, 87%, 65%);--warning-bg: hsl(64, 100%, 6%);--warning-border: hsl(60, 100%, 12%);--warning-text: hsl(46, 87%, 65%);--error-bg: hsl(358, 76%, 10%);--error-border: hsl(357, 89%, 16%);--error-text: hsl(358, 100%, 81%)}[data-rich-colors=true][data-sonner-toast][data-type=success],[data-rich-colors=true][data-sonner-toast][data-type=success] [data-close-button]{background:var(--success-bg);border-color:var(--success-border);color:var(--success-text)}[data-rich-colors=true][data-sonner-toast][data-type=info],[data-rich-colors=true][data-sonner-toast][data-type=info] [data-close-button]{background:var(--info-bg);border-color:var(--info-border);color:var(--info-text)}[data-rich-colors=true][data-sonner-toast][data-type=warning],[data-rich-colors=true][data-sonner-toast][data-type=warning] [data-close-button]{background:var(--warning-bg);border-color:var(--warning-border);color:var(--warning-text)}[data-rich-colors=true][data-sonner-toast][data-type=error],[data-rich-colors=true][data-sonner-toast][data-type=error] [data-close-button]{background:var(--error-bg);border-color:var(--error-border);color:var(--error-text)}.sonner-loading-wrapper{--size: 16px;height:var(--size);width:var(--size);position:absolute;inset:0;z-index:10}.sonner-loading-wrapper[data-visible=false]{transform-origin:center;animation:sonner-fade-out .2s ease forwards}.sonner-spinner{position:relative;top:50%;left:50%;height:var(--size);width:var(--size)}.sonner-loading-bar{animation:sonner-spin 1.2s linear infinite;background:var(--gray11);border-radius:6px;height:8%;left:-10%;position:absolute;top:-3.9%;width:24%}.sonner-loading-bar:nth-child(1){animation-delay:-1.2s;transform:rotate(.0001deg) translate(146%)}.sonner-loading-bar:nth-child(2){animation-delay:-1.1s;transform:rotate(30deg) translate(146%)}.sonner-loading-bar:nth-child(3){animation-delay:-1s;transform:rotate(60deg) translate(146%)}.sonner-loading-bar:nth-child(4){animation-delay:-.9s;transform:rotate(90deg) translate(146%)}.sonner-loading-bar:nth-child(5){animation-delay:-.8s;transform:rotate(120deg) translate(146%)}.sonner-loading-bar:nth-child(6){animation-delay:-.7s;transform:rotate(150deg) translate(146%)}.sonner-loading-bar:nth-child(7){animation-delay:-.6s;transform:rotate(180deg) translate(146%)}.sonner-loading-bar:nth-child(8){animation-delay:-.5s;transform:rotate(210deg) translate(146%)}.sonner-loading-bar:nth-child(9){animation-delay:-.4s;transform:rotate(240deg) translate(146%)}.sonner-loading-bar:nth-child(10){animation-delay:-.3s;transform:rotate(270deg) translate(146%)}.sonner-loading-bar:nth-child(11){animation-delay:-.2s;transform:rotate(300deg) translate(146%)}.sonner-loading-bar:nth-child(12){animation-delay:-.1s;transform:rotate(330deg) translate(146%)}@keyframes sonner-fade-in{0%{opacity:0;transform:scale(.8)}to{opacity:1;transform:scale(1)}}@keyframes sonner-fade-out{0%{opacity:1;transform:scale(1)}to{opacity:0;transform:scale(.8)}}@keyframes sonner-spin{0%{opacity:1}to{opacity:.15}}@media (prefers-reduced-motion){[data-sonner-toast],[data-sonner-toast]>*,.sonner-loading-bar{transition:none!important;animation:none!important}}.sonner-loader{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);transform-origin:center;transition:opacity .2s,transform .2s}.sonner-loader[data-visible=false]{opacity:0;transform:scale(.8) translate(-50%,-50%)}
`);
  function U(s2) {
    return s2.label !== void 0;
  }
  var qt = 3, Qt = "32px", Zt = 4e3, te = 356, ee = 14, oe = 20, ae = 200;
  function ne(...s2) {
    return s2.filter(Boolean).join(" ");
  }
  var se = (s2) => {
    var yt, xt, vt, wt, Tt, St, Rt, Et, Nt, Pt;
    let { invert: o2, toast: t2, unstyled: n, interacting: h2, setHeights: u2, visibleToasts: g2, heights: b, index: d2, toasts: q2, expanded: $2, removeToast: V2, defaultRichColors: Q2, closeButton: i, style: O2, cancelButtonStyle: K2, actionButtonStyle: Z2, className: tt = "", descriptionClassName: et = "", duration: X2, position: ot, gap: w2, loadingIcon: j2, expandByDefault: W2, classNames: r2, icons: I2, closeButtonAriaLabel: at = "Close toast", pauseWhenPageIsHidden: k2, cn: T2 } = s2, [z2, nt] = xn.useState(false), [D2, H2] = xn.useState(false), [st, N2] = xn.useState(false), [M2, rt] = xn.useState(false), [c2, m2] = xn.useState(0), [y2, S] = xn.useState(0), A2 = xn.useRef(null), l2 = xn.useRef(null), _2 = d2 === 0, J2 = d2 + 1 <= g2, x2 = t2.type, P2 = t2.dismissible !== false, Mt = t2.className || "", At = t2.descriptionClassName || "", G2 = xn.useMemo(() => b.findIndex((a2) => a2.toastId === t2.id) || 0, [b, t2.id]), Lt = xn.useMemo(() => {
      var a2;
      return (a2 = t2.closeButton) != null ? a2 : i;
    }, [t2.closeButton, i]), mt = xn.useMemo(() => t2.duration || X2 || Zt, [t2.duration, X2]), it = xn.useRef(0), Y2 = xn.useRef(0), pt = xn.useRef(0), F2 = xn.useRef(null), [gt, zt] = ot.split("-"), ht = xn.useMemo(() => b.reduce((a2, f2, p2) => p2 >= G2 ? a2 : a2 + f2.height, 0), [b, G2]), bt = Dt(), jt = t2.invert || o2, lt = x2 === "loading";
    Y2.current = xn.useMemo(() => G2 * w2 + ht, [G2, ht]), xn.useEffect(() => {
      nt(true);
    }, []), xn.useLayoutEffect(() => {
      if (!z2) return;
      let a2 = l2.current, f2 = a2.style.height;
      a2.style.height = "auto";
      let p2 = a2.getBoundingClientRect().height;
      a2.style.height = f2, S(p2), u2((B2) => B2.find((R2) => R2.toastId === t2.id) ? B2.map((R2) => R2.toastId === t2.id ? __spreadProps(__spreadValues({}, R2), { height: p2 }) : R2) : [{ toastId: t2.id, height: p2, position: t2.position }, ...B2]);
    }, [z2, t2.title, t2.description, u2, t2.id]);
    let L2 = xn.useCallback(() => {
      H2(true), m2(Y2.current), u2((a2) => a2.filter((f2) => f2.toastId !== t2.id)), setTimeout(() => {
        V2(t2);
      }, ae);
    }, [t2, V2, u2, Y2]);
    xn.useEffect(() => {
      if (t2.promise && x2 === "loading" || t2.duration === 1 / 0 || t2.type === "loading") return;
      let a2, f2 = mt;
      return $2 || h2 || k2 && bt ? (() => {
        if (pt.current < it.current) {
          let C2 = (/* @__PURE__ */ new Date()).getTime() - it.current;
          f2 = f2 - C2;
        }
        pt.current = (/* @__PURE__ */ new Date()).getTime();
      })() : (() => {
        f2 !== 1 / 0 && (it.current = (/* @__PURE__ */ new Date()).getTime(), a2 = setTimeout(() => {
          var C2;
          (C2 = t2.onAutoClose) == null || C2.call(t2, t2), L2();
        }, f2));
      })(), () => clearTimeout(a2);
    }, [$2, h2, W2, t2, mt, L2, t2.promise, x2, k2, bt]), xn.useEffect(() => {
      let a2 = l2.current;
      if (a2) {
        let f2 = a2.getBoundingClientRect().height;
        return S(f2), u2((p2) => [{ toastId: t2.id, height: f2, position: t2.position }, ...p2]), () => u2((p2) => p2.filter((B2) => B2.toastId !== t2.id));
      }
    }, [u2, t2.id]), xn.useEffect(() => {
      t2.delete && L2();
    }, [L2, t2.delete]);
    function Yt() {
      return I2 != null && I2.loading ? xn.createElement("div", { className: "sonner-loader", "data-visible": x2 === "loading" }, I2.loading) : j2 ? xn.createElement("div", { className: "sonner-loader", "data-visible": x2 === "loading" }, j2) : xn.createElement(It, { visible: x2 === "loading" });
    }
    return xn.createElement("li", { "aria-live": t2.important ? "assertive" : "polite", "aria-atomic": "true", role: "status", tabIndex: 0, ref: l2, className: T2(tt, Mt, r2 == null ? void 0 : r2.toast, (yt = t2 == null ? void 0 : t2.classNames) == null ? void 0 : yt.toast, r2 == null ? void 0 : r2.default, r2 == null ? void 0 : r2[x2], (xt = t2 == null ? void 0 : t2.classNames) == null ? void 0 : xt[x2]), "data-sonner-toast": "", "data-rich-colors": (vt = t2.richColors) != null ? vt : Q2, "data-styled": !(t2.jsx || t2.unstyled || n), "data-mounted": z2, "data-promise": !!t2.promise, "data-removed": D2, "data-visible": J2, "data-y-position": gt, "data-x-position": zt, "data-index": d2, "data-front": _2, "data-swiping": st, "data-dismissible": P2, "data-type": x2, "data-invert": jt, "data-swipe-out": M2, "data-expanded": !!($2 || W2 && z2), style: __spreadValues(__spreadValues({ "--index": d2, "--toasts-before": d2, "--z-index": q2.length - d2, "--offset": `${D2 ? c2 : Y2.current}px`, "--initial-height": W2 ? "auto" : `${y2}px` }, O2), t2.style), onPointerDown: (a2) => {
      lt || !P2 || (A2.current = /* @__PURE__ */ new Date(), m2(Y2.current), a2.target.setPointerCapture(a2.pointerId), a2.target.tagName !== "BUTTON" && (N2(true), F2.current = { x: a2.clientX, y: a2.clientY }));
    }, onPointerUp: () => {
      var B2, C2, R2, dt;
      if (M2 || !P2) return;
      F2.current = null;
      let a2 = Number(((B2 = l2.current) == null ? void 0 : B2.style.getPropertyValue("--swipe-amount").replace("px", "")) || 0), f2 = (/* @__PURE__ */ new Date()).getTime() - ((C2 = A2.current) == null ? void 0 : C2.getTime()), p2 = Math.abs(a2) / f2;
      if (Math.abs(a2) >= oe || p2 > 0.11) {
        m2(Y2.current), (R2 = t2.onDismiss) == null || R2.call(t2, t2), L2(), rt(true);
        return;
      }
      (dt = l2.current) == null || dt.style.setProperty("--swipe-amount", "0px"), N2(false);
    }, onPointerMove: (a2) => {
      var Bt;
      if (!F2.current || !P2) return;
      let f2 = a2.clientY - F2.current.y, p2 = a2.clientX - F2.current.x, C2 = (gt === "top" ? Math.min : Math.max)(0, f2), R2 = a2.pointerType === "touch" ? 10 : 2;
      Math.abs(C2) > R2 ? (Bt = l2.current) == null || Bt.style.setProperty("--swipe-amount", `${f2}px`) : Math.abs(p2) > R2 && (F2.current = null);
    } }, Lt && !t2.jsx ? xn.createElement("button", { "aria-label": at, "data-disabled": lt, "data-close-button": true, onClick: lt || !P2 ? () => {
    } : () => {
      var a2;
      L2(), (a2 = t2.onDismiss) == null || a2.call(t2, t2);
    }, className: T2(r2 == null ? void 0 : r2.closeButton, (wt = t2 == null ? void 0 : t2.classNames) == null ? void 0 : wt.closeButton) }, xn.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "12", height: "12", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "1.5", strokeLinecap: "round", strokeLinejoin: "round" }, xn.createElement("line", { x1: "18", y1: "6", x2: "6", y2: "18" }), xn.createElement("line", { x1: "6", y1: "6", x2: "18", y2: "18" }))) : null, t2.jsx || xn.isValidElement(t2.title) ? t2.jsx || t2.title : xn.createElement(xn.Fragment, null, x2 || t2.icon || t2.promise ? xn.createElement("div", { "data-icon": "", className: T2(r2 == null ? void 0 : r2.icon, (Tt = t2 == null ? void 0 : t2.classNames) == null ? void 0 : Tt.icon) }, t2.promise || t2.type === "loading" && !t2.icon ? t2.icon || Yt() : null, t2.type !== "loading" ? t2.icon || (I2 == null ? void 0 : I2[x2]) || Ct(x2) : null) : null, xn.createElement("div", { "data-content": "", className: T2(r2 == null ? void 0 : r2.content, (St = t2 == null ? void 0 : t2.classNames) == null ? void 0 : St.content) }, xn.createElement("div", { "data-title": "", className: T2(r2 == null ? void 0 : r2.title, (Rt = t2 == null ? void 0 : t2.classNames) == null ? void 0 : Rt.title) }, t2.title), t2.description ? xn.createElement("div", { "data-description": "", className: T2(et, At, r2 == null ? void 0 : r2.description, (Et = t2 == null ? void 0 : t2.classNames) == null ? void 0 : Et.description) }, t2.description) : null), xn.isValidElement(t2.cancel) ? t2.cancel : t2.cancel && U(t2.cancel) ? xn.createElement("button", { "data-button": true, "data-cancel": true, style: t2.cancelButtonStyle || K2, onClick: (a2) => {
      var f2, p2;
      U(t2.cancel) && P2 && ((p2 = (f2 = t2.cancel).onClick) == null || p2.call(f2, a2), L2());
    }, className: T2(r2 == null ? void 0 : r2.cancelButton, (Nt = t2 == null ? void 0 : t2.classNames) == null ? void 0 : Nt.cancelButton) }, t2.cancel.label) : null, xn.isValidElement(t2.action) ? t2.action : t2.action && U(t2.action) ? xn.createElement("button", { "data-button": true, "data-action": true, style: t2.actionButtonStyle || Z2, onClick: (a2) => {
      var f2, p2;
      U(t2.action) && (a2.defaultPrevented || ((p2 = (f2 = t2.action).onClick) == null || p2.call(f2, a2), L2()));
    }, className: T2(r2 == null ? void 0 : r2.actionButton, (Pt = t2 == null ? void 0 : t2.classNames) == null ? void 0 : Pt.actionButton) }, t2.action.label) : null));
  };
  function Ht() {
    if (typeof window == "undefined" || typeof document == "undefined") return "ltr";
    let s2 = document.documentElement.getAttribute("dir");
    return s2 === "auto" || !s2 ? window.getComputedStyle(document.documentElement).direction : s2;
  }
  var Te = (s2) => {
    let { invert: o2, position: t2 = "bottom-right", hotkey: n = ["altKey", "KeyT"], expand: h2, closeButton: u2, className: g2, offset: b, theme: d2 = "light", richColors: q2, duration: $2, style: V2, visibleToasts: Q2 = qt, toastOptions: i, dir: O2 = Ht(), gap: K2 = ee, loadingIcon: Z2, icons: tt, containerAriaLabel: et = "Notifications", pauseWhenPageIsHidden: X2, cn: ot = ne } = s2, [w2, j2] = xn.useState([]), W2 = xn.useMemo(() => Array.from(new Set([t2].concat(w2.filter((c2) => c2.position).map((c2) => c2.position)))), [w2, t2]), [r2, I2] = xn.useState([]), [at, k2] = xn.useState(false), [T2, z2] = xn.useState(false), [nt, D2] = xn.useState(d2 !== "system" ? d2 : typeof window != "undefined" && window.matchMedia && window.matchMedia("(prefers-color-scheme: dark)").matches ? "dark" : "light"), H2 = xn.useRef(null), st = n.join("+").replace(/Key/g, "").replace(/Digit/g, ""), N2 = xn.useRef(null), M2 = xn.useRef(false), rt = xn.useCallback((c2) => {
      var m2;
      (m2 = w2.find((y2) => y2.id === c2.id)) != null && m2.delete || v.dismiss(c2.id), j2((y2) => y2.filter(({ id: S }) => S !== c2.id));
    }, [w2]);
    return xn.useEffect(() => v.subscribe((c2) => {
      if (c2.dismiss) {
        j2((m2) => m2.map((y2) => y2.id === c2.id ? __spreadProps(__spreadValues({}, y2), { delete: true }) : y2));
        return;
      }
      setTimeout(() => {
        xn.flushSync(() => {
          j2((m2) => {
            let y2 = m2.findIndex((S) => S.id === c2.id);
            return y2 !== -1 ? [...m2.slice(0, y2), __spreadValues(__spreadValues({}, m2[y2]), c2), ...m2.slice(y2 + 1)] : [c2, ...m2];
          });
        });
      });
    }), []), xn.useEffect(() => {
      if (d2 !== "system") {
        D2(d2);
        return;
      }
      d2 === "system" && (window.matchMedia && window.matchMedia("(prefers-color-scheme: dark)").matches ? D2("dark") : D2("light")), typeof window != "undefined" && window.matchMedia("(prefers-color-scheme: dark)").addEventListener("change", ({ matches: c2 }) => {
        D2(c2 ? "dark" : "light");
      });
    }, [d2]), xn.useEffect(() => {
      w2.length <= 1 && k2(false);
    }, [w2]), xn.useEffect(() => {
      let c2 = (m2) => {
        var S, A2;
        n.every((l2) => m2[l2] || m2.code === l2) && (k2(true), (S = H2.current) == null || S.focus()), m2.code === "Escape" && (document.activeElement === H2.current || (A2 = H2.current) != null && A2.contains(document.activeElement)) && k2(false);
      };
      return document.addEventListener("keydown", c2), () => document.removeEventListener("keydown", c2);
    }, [n]), xn.useEffect(() => {
      if (H2.current) return () => {
        N2.current && (N2.current.focus({ preventScroll: true }), N2.current = null, M2.current = false);
      };
    }, [H2.current]), w2.length ? xn.createElement("section", { "aria-label": `${et} ${st}`, tabIndex: -1 }, W2.map((c2, m2) => {
      var A2;
      let [y2, S] = c2.split("-");
      return xn.createElement("ol", { key: c2, dir: O2 === "auto" ? Ht() : O2, tabIndex: -1, ref: H2, className: g2, "data-sonner-toaster": true, "data-theme": nt, "data-y-position": y2, "data-x-position": S, style: __spreadValues({ "--front-toast-height": `${((A2 = r2[0]) == null ? void 0 : A2.height) || 0}px`, "--offset": typeof b == "number" ? `${b}px` : b || Qt, "--width": `${te}px`, "--gap": `${K2}px` }, V2), onBlur: (l2) => {
        M2.current && !l2.currentTarget.contains(l2.relatedTarget) && (M2.current = false, N2.current && (N2.current.focus({ preventScroll: true }), N2.current = null));
      }, onFocus: (l2) => {
        l2.target instanceof HTMLElement && l2.target.dataset.dismissible === "false" || M2.current || (M2.current = true, N2.current = l2.relatedTarget);
      }, onMouseEnter: () => k2(true), onMouseMove: () => k2(true), onMouseLeave: () => {
        T2 || k2(false);
      }, onPointerDown: (l2) => {
        l2.target instanceof HTMLElement && l2.target.dataset.dismissible === "false" || z2(true);
      }, onPointerUp: () => z2(false) }, w2.filter((l2) => !l2.position && m2 === 0 || l2.position === c2).map((l2, _2) => {
        var J2, x2;
        return xn.createElement(se, { key: l2.id, icons: tt, index: _2, toast: l2, defaultRichColors: q2, duration: (J2 = i == null ? void 0 : i.duration) != null ? J2 : $2, className: i == null ? void 0 : i.className, descriptionClassName: i == null ? void 0 : i.descriptionClassName, invert: o2, visibleToasts: Q2, closeButton: (x2 = i == null ? void 0 : i.closeButton) != null ? x2 : u2, interacting: T2, position: c2, style: i == null ? void 0 : i.style, unstyled: i == null ? void 0 : i.unstyled, classNames: i == null ? void 0 : i.classNames, cancelButtonStyle: i == null ? void 0 : i.cancelButtonStyle, actionButtonStyle: i == null ? void 0 : i.actionButtonStyle, removeToast: rt, toasts: w2.filter((P2) => P2.position == l2.position), heights: r2.filter((P2) => P2.position == l2.position), setHeights: I2, expandByDefault: h2, gap: K2, loadingIcon: Z2, expanded: at, pauseWhenPageIsHidden: X2, cn: ot });
      }));
    })) : null;
  };
  if (location.host === "ptpimg.me") {
    const ptpImgApiKey = GM_getValue("easy-upload.ptp-img-api-key", "");
    if (!ptpImgApiKey) {
      const div = document.createElement("div");
      preact.render(
        /* @__PURE__ */ u$1("div", { class: "ptp-api-key-btn", children: [
          /* @__PURE__ */ u$1(Te, { position: "top-right", richColors: true }),
          /* @__PURE__ */ u$1(
            "button",
            {
              class: "btn btn-info",
              onClick: () => {
                const apiKey = $$2("#api_key").val();
                GM_setValue("easy-upload.ptp-img-api-key", apiKey);
                Jt.success("Success! Saved to EasyUpload.");
              },
              children: [
                /* @__PURE__ */ u$1("i", { class: "glyphicon glyphicon-floppy-saved" }),
                /* @__PURE__ */ u$1("span", { children: "Save ApiKey" })
              ]
            }
          )
        ] }),
        div
      );
      (_a = document.querySelector("#form_file_upload")) == null ? void 0 : _a.after(div);
    }
  }
  function _typeof(obj) {
    "@babel/helpers - typeof";
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof = function(obj2) {
        return typeof obj2;
      };
    } else {
      _typeof = function(obj2) {
        return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      };
    }
    return _typeof(obj);
  }
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
  }
  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        writable: true,
        configurable: true
      }
    });
    if (superClass) _setPrototypeOf(subClass, superClass);
  }
  function _getPrototypeOf(o2) {
    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o3) {
      return o3.__proto__ || Object.getPrototypeOf(o3);
    };
    return _getPrototypeOf(o2);
  }
  function _setPrototypeOf(o2, p2) {
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o3, p3) {
      o3.__proto__ = p3;
      return o3;
    };
    return _setPrototypeOf(o2, p2);
  }
  function _isNativeReflectConstruct() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;
    try {
      Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      }));
      return true;
    } catch (e2) {
      return false;
    }
  }
  function _construct(Parent, args, Class) {
    if (_isNativeReflectConstruct()) {
      _construct = Reflect.construct;
    } else {
      _construct = function _construct2(Parent2, args2, Class2) {
        var a2 = [null];
        a2.push.apply(a2, args2);
        var Constructor = Function.bind.apply(Parent2, a2);
        var instance = new Constructor();
        if (Class2) _setPrototypeOf(instance, Class2.prototype);
        return instance;
      };
    }
    return _construct.apply(null, arguments);
  }
  function _isNativeFunction(fn2) {
    return Function.toString.call(fn2).indexOf("[native code]") !== -1;
  }
  function _wrapNativeSuper(Class) {
    var _cache = typeof Map === "function" ? /* @__PURE__ */ new Map() : void 0;
    _wrapNativeSuper = function _wrapNativeSuper2(Class2) {
      if (Class2 === null || !_isNativeFunction(Class2)) return Class2;
      if (typeof Class2 !== "function") {
        throw new TypeError("Super expression must either be null or a function");
      }
      if (typeof _cache !== "undefined") {
        if (_cache.has(Class2)) return _cache.get(Class2);
        _cache.set(Class2, Wrapper);
      }
      function Wrapper() {
        return _construct(Class2, arguments, _getPrototypeOf(this).constructor);
      }
      Wrapper.prototype = Object.create(Class2.prototype, {
        constructor: {
          value: Wrapper,
          enumerable: false,
          writable: true,
          configurable: true
        }
      });
      return _setPrototypeOf(Wrapper, Class2);
    };
    return _wrapNativeSuper(Class);
  }
  function _assertThisInitialized(self2) {
    if (self2 === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return self2;
  }
  function _possibleConstructorReturn(self2, call) {
    if (call && (typeof call === "object" || typeof call === "function")) {
      return call;
    }
    return _assertThisInitialized(self2);
  }
  function _createSuper(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct();
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived), result;
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor;
        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }
      return _possibleConstructorReturn(this, result);
    };
  }
  function _superPropBase(object, property) {
    while (!Object.prototype.hasOwnProperty.call(object, property)) {
      object = _getPrototypeOf(object);
      if (object === null) break;
    }
    return object;
  }
  function _get(target, property, receiver) {
    if (typeof Reflect !== "undefined" && Reflect.get) {
      _get = Reflect.get;
    } else {
      _get = function _get2(target2, property2, receiver2) {
        var base = _superPropBase(target2, property2);
        if (!base) return;
        var desc = Object.getOwnPropertyDescriptor(base, property2);
        if (desc.get) {
          return desc.get.call(receiver2);
        }
        return desc.value;
      };
    }
    return _get(target, property, receiver || target);
  }
  function _slicedToArray(arr, i) {
    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
  }
  function _toArray(arr) {
    return _arrayWithHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableRest();
  }
  function _arrayWithHoles(arr) {
    if (Array.isArray(arr)) return arr;
  }
  function _iterableToArray(iter) {
    if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter);
  }
  function _iterableToArrayLimit(arr, i) {
    if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return;
    var _arr = [];
    var _n2 = true;
    var _d = false;
    var _e = void 0;
    try {
      for (var _i = arr[Symbol.iterator](), _s; !(_n2 = (_s = _i.next()).done); _n2 = true) {
        _arr.push(_s.value);
        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n2 && _i["return"] != null) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }
    return _arr;
  }
  function _unsupportedIterableToArray(o2, minLen) {
    if (!o2) return;
    if (typeof o2 === "string") return _arrayLikeToArray(o2, minLen);
    var n = Object.prototype.toString.call(o2).slice(8, -1);
    if (n === "Object" && o2.constructor) n = o2.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o2);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o2, minLen);
  }
  function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
    return arr2;
  }
  function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  function _createForOfIteratorHelper(o2, allowArrayLike) {
    var it;
    if (typeof Symbol === "undefined" || o2[Symbol.iterator] == null) {
      if (Array.isArray(o2) || (it = _unsupportedIterableToArray(o2)) || allowArrayLike) {
        if (it) o2 = it;
        var i = 0;
        var F2 = function() {
        };
        return {
          s: F2,
          n: function() {
            if (i >= o2.length) return {
              done: true
            };
            return {
              done: false,
              value: o2[i++]
            };
          },
          e: function(e2) {
            throw e2;
          },
          f: F2
        };
      }
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var normalCompletion = true, didErr = false, err;
    return {
      s: function() {
        it = o2[Symbol.iterator]();
      },
      n: function() {
        var step = it.next();
        normalCompletion = step.done;
        return step;
      },
      e: function(e2) {
        didErr = true;
        err = e2;
      },
      f: function() {
        try {
          if (!normalCompletion && it.return != null) it.return();
        } finally {
          if (didErr) throw err;
        }
      }
    };
  }
  var Char = {
    ANCHOR: "&",
    COMMENT: "#",
    TAG: "!",
    DIRECTIVES_END: "-",
    DOCUMENT_END: "."
  };
  var Type = {
    ALIAS: "ALIAS",
    BLANK_LINE: "BLANK_LINE",
    BLOCK_FOLDED: "BLOCK_FOLDED",
    BLOCK_LITERAL: "BLOCK_LITERAL",
    COMMENT: "COMMENT",
    DIRECTIVE: "DIRECTIVE",
    DOCUMENT: "DOCUMENT",
    FLOW_MAP: "FLOW_MAP",
    FLOW_SEQ: "FLOW_SEQ",
    MAP: "MAP",
    MAP_KEY: "MAP_KEY",
    MAP_VALUE: "MAP_VALUE",
    PLAIN: "PLAIN",
    QUOTE_DOUBLE: "QUOTE_DOUBLE",
    QUOTE_SINGLE: "QUOTE_SINGLE",
    SEQ: "SEQ",
    SEQ_ITEM: "SEQ_ITEM"
  };
  var defaultTagPrefix = "tag:yaml.org,2002:";
  var defaultTags = {
    MAP: "tag:yaml.org,2002:map",
    SEQ: "tag:yaml.org,2002:seq",
    STR: "tag:yaml.org,2002:str"
  };
  function findLineStarts(src) {
    var ls = [0];
    var offset = src.indexOf("\n");
    while (offset !== -1) {
      offset += 1;
      ls.push(offset);
      offset = src.indexOf("\n", offset);
    }
    return ls;
  }
  function getSrcInfo(cst) {
    var lineStarts, src;
    if (typeof cst === "string") {
      lineStarts = findLineStarts(cst);
      src = cst;
    } else {
      if (Array.isArray(cst)) cst = cst[0];
      if (cst && cst.context) {
        if (!cst.lineStarts) cst.lineStarts = findLineStarts(cst.context.src);
        lineStarts = cst.lineStarts;
        src = cst.context.src;
      }
    }
    return {
      lineStarts,
      src
    };
  }
  function getLinePos(offset, cst) {
    if (typeof offset !== "number" || offset < 0) return null;
    var _getSrcInfo = getSrcInfo(cst), lineStarts = _getSrcInfo.lineStarts, src = _getSrcInfo.src;
    if (!lineStarts || !src || offset > src.length) return null;
    for (var i = 0; i < lineStarts.length; ++i) {
      var start = lineStarts[i];
      if (offset < start) {
        return {
          line: i,
          col: offset - lineStarts[i - 1] + 1
        };
      }
      if (offset === start) return {
        line: i + 1,
        col: 1
      };
    }
    var line = lineStarts.length;
    return {
      line,
      col: offset - lineStarts[line - 1] + 1
    };
  }
  function getLine(line, cst) {
    var _getSrcInfo2 = getSrcInfo(cst), lineStarts = _getSrcInfo2.lineStarts, src = _getSrcInfo2.src;
    if (!lineStarts || !(line >= 1) || line > lineStarts.length) return null;
    var start = lineStarts[line - 1];
    var end = lineStarts[line];
    while (end && end > start && src[end - 1] === "\n") {
      --end;
    }
    return src.slice(start, end);
  }
  function getPrettyContext(_ref, cst) {
    var start = _ref.start, end = _ref.end;
    var maxWidth = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 80;
    var src = getLine(start.line, cst);
    if (!src) return null;
    var col = start.col;
    if (src.length > maxWidth) {
      if (col <= maxWidth - 10) {
        src = src.substr(0, maxWidth - 1) + "…";
      } else {
        var halfWidth = Math.round(maxWidth / 2);
        if (src.length > col + halfWidth) src = src.substr(0, col + halfWidth - 1) + "…";
        col -= src.length - maxWidth;
        src = "…" + src.substr(1 - maxWidth);
      }
    }
    var errLen = 1;
    var errEnd = "";
    if (end) {
      if (end.line === start.line && col + (end.col - start.col) <= maxWidth + 1) {
        errLen = end.col - start.col;
      } else {
        errLen = Math.min(src.length + 1, maxWidth) - col;
        errEnd = "…";
      }
    }
    var offset = col > 1 ? " ".repeat(col - 1) : "";
    var err = "^".repeat(errLen);
    return "".concat(src, "\n").concat(offset).concat(err).concat(errEnd);
  }
  var Range = /* @__PURE__ */ function() {
    function Range2(start, end) {
      _classCallCheck(this, Range2);
      this.start = start;
      this.end = end || start;
    }
    _createClass(Range2, [{
      key: "isEmpty",
      value: function isEmpty() {
        return typeof this.start !== "number" || !this.end || this.end <= this.start;
      }
      /**
       * Set `origStart` and `origEnd` to point to the original source range for
       * this node, which may differ due to dropped CR characters.
       *
       * @param {number[]} cr - Positions of dropped CR characters
       * @param {number} offset - Starting index of `cr` from the last call
       * @returns {number} - The next offset, matching the one found for `origStart`
       */
    }, {
      key: "setOrigRange",
      value: function setOrigRange(cr, offset) {
        var start = this.start, end = this.end;
        if (cr.length === 0 || end <= cr[0]) {
          this.origStart = start;
          this.origEnd = end;
          return offset;
        }
        var i = offset;
        while (i < cr.length) {
          if (cr[i] > start) break;
          else ++i;
        }
        this.origStart = start + i;
        var nextOffset = i;
        while (i < cr.length) {
          if (cr[i] >= end) break;
          else ++i;
        }
        this.origEnd = end + i;
        return nextOffset;
      }
    }], [{
      key: "copy",
      value: function copy(orig) {
        return new Range2(orig.start, orig.end);
      }
    }]);
    return Range2;
  }();
  var Node$1 = /* @__PURE__ */ function() {
    function Node3(type, props, context) {
      _classCallCheck(this, Node3);
      Object.defineProperty(this, "context", {
        value: context || null,
        writable: true
      });
      this.error = null;
      this.range = null;
      this.valueRange = null;
      this.props = props || [];
      this.type = type;
      this.value = null;
    }
    _createClass(Node3, [{
      key: "getPropValue",
      value: function getPropValue(idx, key, skipKey) {
        if (!this.context) return null;
        var src = this.context.src;
        var prop = this.props[idx];
        return prop && src[prop.start] === key ? src.slice(prop.start + (skipKey ? 1 : 0), prop.end) : null;
      }
    }, {
      key: "anchor",
      get: function get() {
        for (var i = 0; i < this.props.length; ++i) {
          var anchor = this.getPropValue(i, Char.ANCHOR, true);
          if (anchor != null) return anchor;
        }
        return null;
      }
    }, {
      key: "comment",
      get: function get() {
        var comments = [];
        for (var i = 0; i < this.props.length; ++i) {
          var comment = this.getPropValue(i, Char.COMMENT, true);
          if (comment != null) comments.push(comment);
        }
        return comments.length > 0 ? comments.join("\n") : null;
      }
    }, {
      key: "commentHasRequiredWhitespace",
      value: function commentHasRequiredWhitespace(start) {
        var src = this.context.src;
        if (this.header && start === this.header.end) return false;
        if (!this.valueRange) return false;
        var end = this.valueRange.end;
        return start !== end || Node3.atBlank(src, end - 1);
      }
    }, {
      key: "hasComment",
      get: function get() {
        if (this.context) {
          var src = this.context.src;
          for (var i = 0; i < this.props.length; ++i) {
            if (src[this.props[i].start] === Char.COMMENT) return true;
          }
        }
        return false;
      }
    }, {
      key: "hasProps",
      get: function get() {
        if (this.context) {
          var src = this.context.src;
          for (var i = 0; i < this.props.length; ++i) {
            if (src[this.props[i].start] !== Char.COMMENT) return true;
          }
        }
        return false;
      }
    }, {
      key: "includesTrailingLines",
      get: function get() {
        return false;
      }
    }, {
      key: "jsonLike",
      get: function get() {
        var jsonLikeTypes = [Type.FLOW_MAP, Type.FLOW_SEQ, Type.QUOTE_DOUBLE, Type.QUOTE_SINGLE];
        return jsonLikeTypes.indexOf(this.type) !== -1;
      }
    }, {
      key: "rangeAsLinePos",
      get: function get() {
        if (!this.range || !this.context) return void 0;
        var start = getLinePos(this.range.start, this.context.root);
        if (!start) return void 0;
        var end = getLinePos(this.range.end, this.context.root);
        return {
          start,
          end
        };
      }
    }, {
      key: "rawValue",
      get: function get() {
        if (!this.valueRange || !this.context) return null;
        var _this$valueRange = this.valueRange, start = _this$valueRange.start, end = _this$valueRange.end;
        return this.context.src.slice(start, end);
      }
    }, {
      key: "tag",
      get: function get() {
        for (var i = 0; i < this.props.length; ++i) {
          var tag = this.getPropValue(i, Char.TAG, false);
          if (tag != null) {
            if (tag[1] === "<") {
              return {
                verbatim: tag.slice(2, -1)
              };
            } else {
              var _tag$match = tag.match(/^(.*!)([^!]*)$/), _tag$match2 = _slicedToArray(_tag$match, 3);
              _tag$match2[0];
              var handle = _tag$match2[1], suffix = _tag$match2[2];
              return {
                handle,
                suffix
              };
            }
          }
        }
        return null;
      }
    }, {
      key: "valueRangeContainsNewline",
      get: function get() {
        if (!this.valueRange || !this.context) return false;
        var _this$valueRange2 = this.valueRange, start = _this$valueRange2.start, end = _this$valueRange2.end;
        var src = this.context.src;
        for (var i = start; i < end; ++i) {
          if (src[i] === "\n") return true;
        }
        return false;
      }
    }, {
      key: "parseComment",
      value: function parseComment(start) {
        var src = this.context.src;
        if (src[start] === Char.COMMENT) {
          var end = Node3.endOfLine(src, start + 1);
          var commentRange = new Range(start, end);
          this.props.push(commentRange);
          return end;
        }
        return start;
      }
      /**
       * Populates the `origStart` and `origEnd` values of all ranges for this
       * node. Extended by child classes to handle descendant nodes.
       *
       * @param {number[]} cr - Positions of dropped CR characters
       * @param {number} offset - Starting index of `cr` from the last call
       * @returns {number} - The next offset, matching the one found for `origStart`
       */
    }, {
      key: "setOrigRanges",
      value: function setOrigRanges(cr, offset) {
        if (this.range) offset = this.range.setOrigRange(cr, offset);
        if (this.valueRange) this.valueRange.setOrigRange(cr, offset);
        this.props.forEach(function(prop) {
          return prop.setOrigRange(cr, offset);
        });
        return offset;
      }
    }, {
      key: "toString",
      value: function toString() {
        var src = this.context.src, range = this.range, value = this.value;
        if (value != null) return value;
        var str = src.slice(range.start, range.end);
        return Node3.addStringTerminator(src, range.end, str);
      }
    }], [{
      key: "addStringTerminator",
      value: function addStringTerminator(src, offset, str) {
        if (str[str.length - 1] === "\n") return str;
        var next = Node3.endOfWhiteSpace(src, offset);
        return next >= src.length || src[next] === "\n" ? str + "\n" : str;
      }
      // ^(---|...)
    }, {
      key: "atDocumentBoundary",
      value: function atDocumentBoundary(src, offset, sep) {
        var ch0 = src[offset];
        if (!ch0) return true;
        var prev = src[offset - 1];
        if (prev && prev !== "\n") return false;
        if (sep) {
          if (ch0 !== sep) return false;
        } else {
          if (ch0 !== Char.DIRECTIVES_END && ch0 !== Char.DOCUMENT_END) return false;
        }
        var ch1 = src[offset + 1];
        var ch2 = src[offset + 2];
        if (ch1 !== ch0 || ch2 !== ch0) return false;
        var ch3 = src[offset + 3];
        return !ch3 || ch3 === "\n" || ch3 === "	" || ch3 === " ";
      }
    }, {
      key: "endOfIdentifier",
      value: function endOfIdentifier(src, offset) {
        var ch = src[offset];
        var isVerbatim = ch === "<";
        var notOk = isVerbatim ? ["\n", "	", " ", ">"] : ["\n", "	", " ", "[", "]", "{", "}", ","];
        while (ch && notOk.indexOf(ch) === -1) {
          ch = src[offset += 1];
        }
        if (isVerbatim && ch === ">") offset += 1;
        return offset;
      }
    }, {
      key: "endOfIndent",
      value: function endOfIndent(src, offset) {
        var ch = src[offset];
        while (ch === " ") {
          ch = src[offset += 1];
        }
        return offset;
      }
    }, {
      key: "endOfLine",
      value: function endOfLine(src, offset) {
        var ch = src[offset];
        while (ch && ch !== "\n") {
          ch = src[offset += 1];
        }
        return offset;
      }
    }, {
      key: "endOfWhiteSpace",
      value: function endOfWhiteSpace(src, offset) {
        var ch = src[offset];
        while (ch === "	" || ch === " ") {
          ch = src[offset += 1];
        }
        return offset;
      }
    }, {
      key: "startOfLine",
      value: function startOfLine(src, offset) {
        var ch = src[offset - 1];
        if (ch === "\n") return offset;
        while (ch && ch !== "\n") {
          ch = src[offset -= 1];
        }
        return offset + 1;
      }
      /**
       * End of indentation, or null if the line's indent level is not more
       * than `indent`
       *
       * @param {string} src
       * @param {number} indent
       * @param {number} lineStart
       * @returns {?number}
       */
    }, {
      key: "endOfBlockIndent",
      value: function endOfBlockIndent(src, indent, lineStart) {
        var inEnd = Node3.endOfIndent(src, lineStart);
        if (inEnd > lineStart + indent) {
          return inEnd;
        } else {
          var wsEnd = Node3.endOfWhiteSpace(src, inEnd);
          var ch = src[wsEnd];
          if (!ch || ch === "\n") return wsEnd;
        }
        return null;
      }
    }, {
      key: "atBlank",
      value: function atBlank(src, offset, endAsBlank) {
        var ch = src[offset];
        return ch === "\n" || ch === "	" || ch === " " || endAsBlank && !ch;
      }
    }, {
      key: "nextNodeIsIndented",
      value: function nextNodeIsIndented(ch, indentDiff, indicatorAsIndent) {
        if (!ch || indentDiff < 0) return false;
        if (indentDiff > 0) return true;
        return indicatorAsIndent && ch === "-";
      }
      // should be at line or string end, or at next non-whitespace char
    }, {
      key: "normalizeOffset",
      value: function normalizeOffset(src, offset) {
        var ch = src[offset];
        return !ch ? offset : ch !== "\n" && src[offset - 1] === "\n" ? offset - 1 : Node3.endOfWhiteSpace(src, offset);
      }
      // fold single newline into space, multiple newlines to N - 1 newlines
      // presumes src[offset] === '\n'
    }, {
      key: "foldNewline",
      value: function foldNewline(src, offset, indent) {
        var inCount = 0;
        var error = false;
        var fold = "";
        var ch = src[offset + 1];
        while (ch === " " || ch === "	" || ch === "\n") {
          switch (ch) {
            case "\n":
              inCount = 0;
              offset += 1;
              fold += "\n";
              break;
            case "	":
              if (inCount <= indent) error = true;
              offset = Node3.endOfWhiteSpace(src, offset + 2) - 1;
              break;
            case " ":
              inCount += 1;
              offset += 1;
              break;
          }
          ch = src[offset + 1];
        }
        if (!fold) fold = " ";
        if (ch && inCount <= indent) error = true;
        return {
          fold,
          offset,
          error
        };
      }
    }]);
    return Node3;
  }();
  var YAMLError = /* @__PURE__ */ function(_Error) {
    _inherits(YAMLError2, _Error);
    var _super = _createSuper(YAMLError2);
    function YAMLError2(name, source, message) {
      var _this;
      _classCallCheck(this, YAMLError2);
      if (!message || !(source instanceof Node$1)) throw new Error("Invalid arguments for new ".concat(name));
      _this = _super.call(this);
      _this.name = name;
      _this.message = message;
      _this.source = source;
      return _this;
    }
    _createClass(YAMLError2, [{
      key: "makePretty",
      value: function makePretty() {
        if (!this.source) return;
        this.nodeType = this.source.type;
        var cst = this.source.context && this.source.context.root;
        if (typeof this.offset === "number") {
          this.range = new Range(this.offset, this.offset + 1);
          var start = cst && getLinePos(this.offset, cst);
          if (start) {
            var end = {
              line: start.line,
              col: start.col + 1
            };
            this.linePos = {
              start,
              end
            };
          }
          delete this.offset;
        } else {
          this.range = this.source.range;
          this.linePos = this.source.rangeAsLinePos;
        }
        if (this.linePos) {
          var _this$linePos$start = this.linePos.start, line = _this$linePos$start.line, col = _this$linePos$start.col;
          this.message += " at line ".concat(line, ", column ").concat(col);
          var ctx = cst && getPrettyContext(this.linePos, cst);
          if (ctx) this.message += ":\n\n".concat(ctx, "\n");
        }
        delete this.source;
      }
    }]);
    return YAMLError2;
  }(/* @__PURE__ */ _wrapNativeSuper(Error));
  var YAMLReferenceError = /* @__PURE__ */ function(_YAMLError) {
    _inherits(YAMLReferenceError2, _YAMLError);
    var _super2 = _createSuper(YAMLReferenceError2);
    function YAMLReferenceError2(source, message) {
      _classCallCheck(this, YAMLReferenceError2);
      return _super2.call(this, "YAMLReferenceError", source, message);
    }
    return YAMLReferenceError2;
  }(YAMLError);
  var YAMLSemanticError = /* @__PURE__ */ function(_YAMLError2) {
    _inherits(YAMLSemanticError2, _YAMLError2);
    var _super3 = _createSuper(YAMLSemanticError2);
    function YAMLSemanticError2(source, message) {
      _classCallCheck(this, YAMLSemanticError2);
      return _super3.call(this, "YAMLSemanticError", source, message);
    }
    return YAMLSemanticError2;
  }(YAMLError);
  var YAMLSyntaxError = /* @__PURE__ */ function(_YAMLError3) {
    _inherits(YAMLSyntaxError2, _YAMLError3);
    var _super4 = _createSuper(YAMLSyntaxError2);
    function YAMLSyntaxError2(source, message) {
      _classCallCheck(this, YAMLSyntaxError2);
      return _super4.call(this, "YAMLSyntaxError", source, message);
    }
    return YAMLSyntaxError2;
  }(YAMLError);
  var YAMLWarning = /* @__PURE__ */ function(_YAMLError4) {
    _inherits(YAMLWarning2, _YAMLError4);
    var _super5 = _createSuper(YAMLWarning2);
    function YAMLWarning2(source, message) {
      _classCallCheck(this, YAMLWarning2);
      return _super5.call(this, "YAMLWarning", source, message);
    }
    return YAMLWarning2;
  }(YAMLError);
  var PlainValue = /* @__PURE__ */ function(_Node) {
    _inherits(PlainValue2, _Node);
    var _super = _createSuper(PlainValue2);
    function PlainValue2() {
      _classCallCheck(this, PlainValue2);
      return _super.apply(this, arguments);
    }
    _createClass(PlainValue2, [{
      key: "strValue",
      get: function get() {
        if (!this.valueRange || !this.context) return null;
        var _this$valueRange = this.valueRange, start = _this$valueRange.start, end = _this$valueRange.end;
        var src = this.context.src;
        var ch = src[end - 1];
        while (start < end && (ch === "\n" || ch === "	" || ch === " ")) {
          ch = src[--end - 1];
        }
        var str = "";
        for (var i = start; i < end; ++i) {
          var _ch = src[i];
          if (_ch === "\n") {
            var _Node$foldNewline = Node$1.foldNewline(src, i, -1), fold = _Node$foldNewline.fold, offset = _Node$foldNewline.offset;
            str += fold;
            i = offset;
          } else if (_ch === " " || _ch === "	") {
            var wsStart = i;
            var next = src[i + 1];
            while (i < end && (next === " " || next === "	")) {
              i += 1;
              next = src[i + 1];
            }
            if (next !== "\n") str += i > wsStart ? src.slice(wsStart, i + 1) : _ch;
          } else {
            str += _ch;
          }
        }
        var ch0 = src[start];
        switch (ch0) {
          case "	": {
            var msg = "Plain value cannot start with a tab character";
            var errors = [new YAMLSemanticError(this, msg)];
            return {
              errors,
              str
            };
          }
          case "@":
          case "`": {
            var _msg = "Plain value cannot start with reserved character ".concat(ch0);
            var _errors = [new YAMLSemanticError(this, _msg)];
            return {
              errors: _errors,
              str
            };
          }
          default:
            return str;
        }
      }
    }, {
      key: "parseBlockValue",
      value: function parseBlockValue(start) {
        var _this$context = this.context, indent = _this$context.indent, inFlow = _this$context.inFlow, src = _this$context.src;
        var offset = start;
        var valueEnd = start;
        for (var ch = src[offset]; ch === "\n"; ch = src[offset]) {
          if (Node$1.atDocumentBoundary(src, offset + 1)) break;
          var end = Node$1.endOfBlockIndent(src, indent, offset + 1);
          if (end === null || src[end] === "#") break;
          if (src[end] === "\n") {
            offset = end;
          } else {
            valueEnd = PlainValue2.endOfLine(src, end, inFlow);
            offset = valueEnd;
          }
        }
        if (this.valueRange.isEmpty()) this.valueRange.start = start;
        this.valueRange.end = valueEnd;
        return valueEnd;
      }
      /**
       * Parses a plain value from the source
       *
       * Accepted forms are:
       * ```
       * #comment
       *
       * first line
       *
       * first line #comment
       *
       * first line
       * block
       * lines
       *
       * #comment
       * block
       * lines
       * ```
       * where block lines are empty or have an indent level greater than `indent`.
       *
       * @param {ParseContext} context
       * @param {number} start - Index of first character
       * @returns {number} - Index of the character after this scalar, may be `\n`
       */
    }, {
      key: "parse",
      value: function parse3(context, start) {
        this.context = context;
        var inFlow = context.inFlow, src = context.src;
        var offset = start;
        var ch = src[offset];
        if (ch && ch !== "#" && ch !== "\n") {
          offset = PlainValue2.endOfLine(src, start, inFlow);
        }
        this.valueRange = new Range(start, offset);
        offset = Node$1.endOfWhiteSpace(src, offset);
        offset = this.parseComment(offset);
        if (!this.hasComment || this.valueRange.isEmpty()) {
          offset = this.parseBlockValue(offset);
        }
        return offset;
      }
    }], [{
      key: "endOfLine",
      value: function endOfLine(src, start, inFlow) {
        var ch = src[start];
        var offset = start;
        while (ch && ch !== "\n") {
          if (inFlow && (ch === "[" || ch === "]" || ch === "{" || ch === "}" || ch === ",")) break;
          var next = src[offset + 1];
          if (ch === ":" && (!next || next === "\n" || next === "	" || next === " " || inFlow && next === ",")) break;
          if ((ch === " " || ch === "	") && next === "#") break;
          offset += 1;
          ch = next;
        }
        return offset;
      }
    }]);
    return PlainValue2;
  }(Node$1);
  var BlankLine = /* @__PURE__ */ function(_Node) {
    _inherits(BlankLine2, _Node);
    var _super = _createSuper(BlankLine2);
    function BlankLine2() {
      _classCallCheck(this, BlankLine2);
      return _super.call(this, Type.BLANK_LINE);
    }
    _createClass(BlankLine2, [{
      key: "includesTrailingLines",
      get: function get() {
        return true;
      }
      /**
       * Parses a blank line from the source
       *
       * @param {ParseContext} context
       * @param {number} start - Index of first \n character
       * @returns {number} - Index of the character after this
       */
    }, {
      key: "parse",
      value: function parse3(context, start) {
        this.context = context;
        this.range = new Range(start, start + 1);
        return start + 1;
      }
    }]);
    return BlankLine2;
  }(Node$1);
  var CollectionItem = /* @__PURE__ */ function(_Node) {
    _inherits(CollectionItem2, _Node);
    var _super = _createSuper(CollectionItem2);
    function CollectionItem2(type, props) {
      var _this;
      _classCallCheck(this, CollectionItem2);
      _this = _super.call(this, type, props);
      _this.node = null;
      return _this;
    }
    _createClass(CollectionItem2, [{
      key: "includesTrailingLines",
      get: function get() {
        return !!this.node && this.node.includesTrailingLines;
      }
      /**
       * @param {ParseContext} context
       * @param {number} start - Index of first character
       * @returns {number} - Index of the character after this
       */
    }, {
      key: "parse",
      value: function parse3(context, start) {
        this.context = context;
        var parseNode = context.parseNode, src = context.src;
        var atLineStart = context.atLineStart, lineStart = context.lineStart;
        if (!atLineStart && this.type === Type.SEQ_ITEM) this.error = new YAMLSemanticError(this, "Sequence items must not have preceding content on the same line");
        var indent = atLineStart ? start - lineStart : context.indent;
        var offset = Node$1.endOfWhiteSpace(src, start + 1);
        var ch = src[offset];
        var inlineComment = ch === "#";
        var comments = [];
        var blankLine = null;
        while (ch === "\n" || ch === "#") {
          if (ch === "#") {
            var _end = Node$1.endOfLine(src, offset + 1);
            comments.push(new Range(offset, _end));
            offset = _end;
          } else {
            atLineStart = true;
            lineStart = offset + 1;
            var wsEnd = Node$1.endOfWhiteSpace(src, lineStart);
            if (src[wsEnd] === "\n" && comments.length === 0) {
              blankLine = new BlankLine();
              lineStart = blankLine.parse({
                src
              }, lineStart);
            }
            offset = Node$1.endOfIndent(src, lineStart);
          }
          ch = src[offset];
        }
        if (Node$1.nextNodeIsIndented(ch, offset - (lineStart + indent), this.type !== Type.SEQ_ITEM)) {
          this.node = parseNode({
            atLineStart,
            inCollection: false,
            indent,
            lineStart,
            parent: this
          }, offset);
        } else if (ch && lineStart > start + 1) {
          offset = lineStart - 1;
        }
        if (this.node) {
          if (blankLine) {
            var items = context.parent.items || context.parent.contents;
            if (items) items.push(blankLine);
          }
          if (comments.length) Array.prototype.push.apply(this.props, comments);
          offset = this.node.range.end;
        } else {
          if (inlineComment) {
            var c2 = comments[0];
            this.props.push(c2);
            offset = c2.end;
          } else {
            offset = Node$1.endOfLine(src, start + 1);
          }
        }
        var end = this.node ? this.node.valueRange.end : offset;
        this.valueRange = new Range(start, end);
        return offset;
      }
    }, {
      key: "setOrigRanges",
      value: function setOrigRanges(cr, offset) {
        offset = _get(_getPrototypeOf(CollectionItem2.prototype), "setOrigRanges", this).call(this, cr, offset);
        return this.node ? this.node.setOrigRanges(cr, offset) : offset;
      }
    }, {
      key: "toString",
      value: function toString() {
        var src = this.context.src, node = this.node, range = this.range, value = this.value;
        if (value != null) return value;
        var str = node ? src.slice(range.start, node.range.start) + String(node) : src.slice(range.start, range.end);
        return Node$1.addStringTerminator(src, range.end, str);
      }
    }]);
    return CollectionItem2;
  }(Node$1);
  var Comment = /* @__PURE__ */ function(_Node) {
    _inherits(Comment2, _Node);
    var _super = _createSuper(Comment2);
    function Comment2() {
      _classCallCheck(this, Comment2);
      return _super.call(this, Type.COMMENT);
    }
    _createClass(Comment2, [{
      key: "parse",
      value: function parse3(context, start) {
        this.context = context;
        var offset = this.parseComment(start);
        this.range = new Range(start, offset);
        return offset;
      }
    }]);
    return Comment2;
  }(Node$1);
  function grabCollectionEndComments(node) {
    var cnode = node;
    while (cnode instanceof CollectionItem) {
      cnode = cnode.node;
    }
    if (!(cnode instanceof Collection$1)) return null;
    var len = cnode.items.length;
    var ci = -1;
    for (var i = len - 1; i >= 0; --i) {
      var n = cnode.items[i];
      if (n.type === Type.COMMENT) {
        var _n$context = n.context, indent = _n$context.indent, lineStart = _n$context.lineStart;
        if (indent > 0 && n.range.start >= lineStart + indent) break;
        ci = i;
      } else if (n.type === Type.BLANK_LINE) ci = i;
      else break;
    }
    if (ci === -1) return null;
    var ca = cnode.items.splice(ci, len - ci);
    var prevEnd = ca[0].range.start;
    while (true) {
      cnode.range.end = prevEnd;
      if (cnode.valueRange && cnode.valueRange.end > prevEnd) cnode.valueRange.end = prevEnd;
      if (cnode === node) break;
      cnode = cnode.context.parent;
    }
    return ca;
  }
  var Collection$1 = /* @__PURE__ */ function(_Node) {
    _inherits(Collection2, _Node);
    var _super = _createSuper(Collection2);
    function Collection2(firstItem) {
      var _this;
      _classCallCheck(this, Collection2);
      _this = _super.call(this, firstItem.type === Type.SEQ_ITEM ? Type.SEQ : Type.MAP);
      for (var i = firstItem.props.length - 1; i >= 0; --i) {
        if (firstItem.props[i].start < firstItem.context.lineStart) {
          _this.props = firstItem.props.slice(0, i + 1);
          firstItem.props = firstItem.props.slice(i + 1);
          var itemRange = firstItem.props[0] || firstItem.valueRange;
          firstItem.range.start = itemRange.start;
          break;
        }
      }
      _this.items = [firstItem];
      var ec = grabCollectionEndComments(firstItem);
      if (ec) Array.prototype.push.apply(_this.items, ec);
      return _this;
    }
    _createClass(Collection2, [{
      key: "includesTrailingLines",
      get: function get() {
        return this.items.length > 0;
      }
      /**
       * @param {ParseContext} context
       * @param {number} start - Index of first character
       * @returns {number} - Index of the character after this
       */
    }, {
      key: "parse",
      value: function parse3(context, start) {
        this.context = context;
        var parseNode = context.parseNode, src = context.src;
        var lineStart = Node$1.startOfLine(src, start);
        var firstItem = this.items[0];
        firstItem.context.parent = this;
        this.valueRange = Range.copy(firstItem.valueRange);
        var indent = firstItem.range.start - firstItem.context.lineStart;
        var offset = start;
        offset = Node$1.normalizeOffset(src, offset);
        var ch = src[offset];
        var atLineStart = Node$1.endOfWhiteSpace(src, lineStart) === offset;
        var prevIncludesTrailingLines = false;
        while (ch) {
          while (ch === "\n" || ch === "#") {
            if (atLineStart && ch === "\n" && !prevIncludesTrailingLines) {
              var blankLine = new BlankLine();
              offset = blankLine.parse({
                src
              }, offset);
              this.valueRange.end = offset;
              if (offset >= src.length) {
                ch = null;
                break;
              }
              this.items.push(blankLine);
              offset -= 1;
            } else if (ch === "#") {
              if (offset < lineStart + indent && !Collection2.nextContentHasIndent(src, offset, indent)) {
                return offset;
              }
              var comment = new Comment();
              offset = comment.parse({
                indent,
                lineStart,
                src
              }, offset);
              this.items.push(comment);
              this.valueRange.end = offset;
              if (offset >= src.length) {
                ch = null;
                break;
              }
            }
            lineStart = offset + 1;
            offset = Node$1.endOfIndent(src, lineStart);
            if (Node$1.atBlank(src, offset)) {
              var wsEnd = Node$1.endOfWhiteSpace(src, offset);
              var next = src[wsEnd];
              if (!next || next === "\n" || next === "#") {
                offset = wsEnd;
              }
            }
            ch = src[offset];
            atLineStart = true;
          }
          if (!ch) {
            break;
          }
          if (offset !== lineStart + indent && (atLineStart || ch !== ":")) {
            if (offset < lineStart + indent) {
              if (lineStart > start) offset = lineStart;
              break;
            } else if (!this.error) {
              var msg = "All collection items must start at the same column";
              this.error = new YAMLSyntaxError(this, msg);
            }
          }
          if (firstItem.type === Type.SEQ_ITEM) {
            if (ch !== "-") {
              if (lineStart > start) offset = lineStart;
              break;
            }
          } else if (ch === "-" && !this.error) {
            var _next = src[offset + 1];
            if (!_next || _next === "\n" || _next === "	" || _next === " ") {
              var _msg = "A collection cannot be both a mapping and a sequence";
              this.error = new YAMLSyntaxError(this, _msg);
            }
          }
          var node = parseNode({
            atLineStart,
            inCollection: true,
            indent,
            lineStart,
            parent: this
          }, offset);
          if (!node) return offset;
          this.items.push(node);
          this.valueRange.end = node.valueRange.end;
          offset = Node$1.normalizeOffset(src, node.range.end);
          ch = src[offset];
          atLineStart = false;
          prevIncludesTrailingLines = node.includesTrailingLines;
          if (ch) {
            var ls = offset - 1;
            var prev = src[ls];
            while (prev === " " || prev === "	") {
              prev = src[--ls];
            }
            if (prev === "\n") {
              lineStart = ls + 1;
              atLineStart = true;
            }
          }
          var ec = grabCollectionEndComments(node);
          if (ec) Array.prototype.push.apply(this.items, ec);
        }
        return offset;
      }
    }, {
      key: "setOrigRanges",
      value: function setOrigRanges(cr, offset) {
        offset = _get(_getPrototypeOf(Collection2.prototype), "setOrigRanges", this).call(this, cr, offset);
        this.items.forEach(function(node) {
          offset = node.setOrigRanges(cr, offset);
        });
        return offset;
      }
    }, {
      key: "toString",
      value: function toString() {
        var src = this.context.src, items = this.items, range = this.range, value = this.value;
        if (value != null) return value;
        var str = src.slice(range.start, items[0].range.start) + String(items[0]);
        for (var i = 1; i < items.length; ++i) {
          var item = items[i];
          var _item$context = item.context, atLineStart = _item$context.atLineStart, indent = _item$context.indent;
          if (atLineStart) for (var _i = 0; _i < indent; ++_i) {
            str += " ";
          }
          str += String(item);
        }
        return Node$1.addStringTerminator(src, range.end, str);
      }
    }], [{
      key: "nextContentHasIndent",
      value: function nextContentHasIndent(src, offset, indent) {
        var lineStart = Node$1.endOfLine(src, offset) + 1;
        offset = Node$1.endOfWhiteSpace(src, lineStart);
        var ch = src[offset];
        if (!ch) return false;
        if (offset >= lineStart + indent) return true;
        if (ch !== "#" && ch !== "\n") return false;
        return Collection2.nextContentHasIndent(src, offset, indent);
      }
    }]);
    return Collection2;
  }(Node$1);
  var Directive = /* @__PURE__ */ function(_Node) {
    _inherits(Directive2, _Node);
    var _super = _createSuper(Directive2);
    function Directive2() {
      var _this;
      _classCallCheck(this, Directive2);
      _this = _super.call(this, Type.DIRECTIVE);
      _this.name = null;
      return _this;
    }
    _createClass(Directive2, [{
      key: "parameters",
      get: function get() {
        var raw = this.rawValue;
        return raw ? raw.trim().split(/[ \t]+/) : [];
      }
    }, {
      key: "parseName",
      value: function parseName(start) {
        var src = this.context.src;
        var offset = start;
        var ch = src[offset];
        while (ch && ch !== "\n" && ch !== "	" && ch !== " ") {
          ch = src[offset += 1];
        }
        this.name = src.slice(start, offset);
        return offset;
      }
    }, {
      key: "parseParameters",
      value: function parseParameters(start) {
        var src = this.context.src;
        var offset = start;
        var ch = src[offset];
        while (ch && ch !== "\n" && ch !== "#") {
          ch = src[offset += 1];
        }
        this.valueRange = new Range(start, offset);
        return offset;
      }
    }, {
      key: "parse",
      value: function parse3(context, start) {
        this.context = context;
        var offset = this.parseName(start + 1);
        offset = this.parseParameters(offset);
        offset = this.parseComment(offset);
        this.range = new Range(start, offset);
        return offset;
      }
    }]);
    return Directive2;
  }(Node$1);
  var Document$2 = /* @__PURE__ */ function(_Node) {
    _inherits(Document2, _Node);
    var _super = _createSuper(Document2);
    function Document2() {
      var _this;
      _classCallCheck(this, Document2);
      _this = _super.call(this, Type.DOCUMENT);
      _this.directives = null;
      _this.contents = null;
      _this.directivesEndMarker = null;
      _this.documentEndMarker = null;
      return _this;
    }
    _createClass(Document2, [{
      key: "parseDirectives",
      value: function parseDirectives2(start) {
        var src = this.context.src;
        this.directives = [];
        var atLineStart = true;
        var hasDirectives = false;
        var offset = start;
        while (!Node$1.atDocumentBoundary(src, offset, Char.DIRECTIVES_END)) {
          offset = Document2.startCommentOrEndBlankLine(src, offset);
          switch (src[offset]) {
            case "\n":
              if (atLineStart) {
                var blankLine = new BlankLine();
                offset = blankLine.parse({
                  src
                }, offset);
                if (offset < src.length) {
                  this.directives.push(blankLine);
                }
              } else {
                offset += 1;
                atLineStart = true;
              }
              break;
            case "#":
              {
                var comment = new Comment();
                offset = comment.parse({
                  src
                }, offset);
                this.directives.push(comment);
                atLineStart = false;
              }
              break;
            case "%":
              {
                var directive = new Directive();
                offset = directive.parse({
                  parent: this,
                  src
                }, offset);
                this.directives.push(directive);
                hasDirectives = true;
                atLineStart = false;
              }
              break;
            default:
              if (hasDirectives) {
                this.error = new YAMLSemanticError(this, "Missing directives-end indicator line");
              } else if (this.directives.length > 0) {
                this.contents = this.directives;
                this.directives = [];
              }
              return offset;
          }
        }
        if (src[offset]) {
          this.directivesEndMarker = new Range(offset, offset + 3);
          return offset + 3;
        }
        if (hasDirectives) {
          this.error = new YAMLSemanticError(this, "Missing directives-end indicator line");
        } else if (this.directives.length > 0) {
          this.contents = this.directives;
          this.directives = [];
        }
        return offset;
      }
    }, {
      key: "parseContents",
      value: function parseContents2(start) {
        var _this$context = this.context, parseNode = _this$context.parseNode, src = _this$context.src;
        if (!this.contents) this.contents = [];
        var lineStart = start;
        while (src[lineStart - 1] === "-") {
          lineStart -= 1;
        }
        var offset = Node$1.endOfWhiteSpace(src, start);
        var atLineStart = lineStart === start;
        this.valueRange = new Range(offset);
        while (!Node$1.atDocumentBoundary(src, offset, Char.DOCUMENT_END)) {
          switch (src[offset]) {
            case "\n":
              if (atLineStart) {
                var blankLine = new BlankLine();
                offset = blankLine.parse({
                  src
                }, offset);
                if (offset < src.length) {
                  this.contents.push(blankLine);
                }
              } else {
                offset += 1;
                atLineStart = true;
              }
              lineStart = offset;
              break;
            case "#":
              {
                var comment = new Comment();
                offset = comment.parse({
                  src
                }, offset);
                this.contents.push(comment);
                atLineStart = false;
              }
              break;
            default: {
              var iEnd = Node$1.endOfIndent(src, offset);
              var context = {
                atLineStart,
                indent: -1,
                inFlow: false,
                inCollection: false,
                lineStart,
                parent: this
              };
              var node = parseNode(context, iEnd);
              if (!node) return this.valueRange.end = iEnd;
              this.contents.push(node);
              offset = node.range.end;
              atLineStart = false;
              var ec = grabCollectionEndComments(node);
              if (ec) Array.prototype.push.apply(this.contents, ec);
            }
          }
          offset = Document2.startCommentOrEndBlankLine(src, offset);
        }
        this.valueRange.end = offset;
        if (src[offset]) {
          this.documentEndMarker = new Range(offset, offset + 3);
          offset += 3;
          if (src[offset]) {
            offset = Node$1.endOfWhiteSpace(src, offset);
            if (src[offset] === "#") {
              var _comment = new Comment();
              offset = _comment.parse({
                src
              }, offset);
              this.contents.push(_comment);
            }
            switch (src[offset]) {
              case "\n":
                offset += 1;
                break;
              case void 0:
                break;
              default:
                this.error = new YAMLSyntaxError(this, "Document end marker line cannot have a non-comment suffix");
            }
          }
        }
        return offset;
      }
      /**
       * @param {ParseContext} context
       * @param {number} start - Index of first character
       * @returns {number} - Index of the character after this
       */
    }, {
      key: "parse",
      value: function parse3(context, start) {
        context.root = this;
        this.context = context;
        var src = context.src;
        var offset = src.charCodeAt(start) === 65279 ? start + 1 : start;
        offset = this.parseDirectives(offset);
        offset = this.parseContents(offset);
        return offset;
      }
    }, {
      key: "setOrigRanges",
      value: function setOrigRanges(cr, offset) {
        offset = _get(_getPrototypeOf(Document2.prototype), "setOrigRanges", this).call(this, cr, offset);
        this.directives.forEach(function(node) {
          offset = node.setOrigRanges(cr, offset);
        });
        if (this.directivesEndMarker) offset = this.directivesEndMarker.setOrigRange(cr, offset);
        this.contents.forEach(function(node) {
          offset = node.setOrigRanges(cr, offset);
        });
        if (this.documentEndMarker) offset = this.documentEndMarker.setOrigRange(cr, offset);
        return offset;
      }
    }, {
      key: "toString",
      value: function toString() {
        var contents = this.contents, directives = this.directives, value = this.value;
        if (value != null) return value;
        var str = directives.join("");
        if (contents.length > 0) {
          if (directives.length > 0 || contents[0].type === Type.COMMENT) str += "---\n";
          str += contents.join("");
        }
        if (str[str.length - 1] !== "\n") str += "\n";
        return str;
      }
    }], [{
      key: "startCommentOrEndBlankLine",
      value: function startCommentOrEndBlankLine(src, start) {
        var offset = Node$1.endOfWhiteSpace(src, start);
        var ch = src[offset];
        return ch === "#" || ch === "\n" ? offset : start;
      }
    }]);
    return Document2;
  }(Node$1);
  var Alias$1 = /* @__PURE__ */ function(_Node) {
    _inherits(Alias2, _Node);
    var _super = _createSuper(Alias2);
    function Alias2() {
      _classCallCheck(this, Alias2);
      return _super.apply(this, arguments);
    }
    _createClass(Alias2, [{
      key: "parse",
      value: (
        /**
         * Parses an *alias from the source
         *
         * @param {ParseContext} context
         * @param {number} start - Index of first character
         * @returns {number} - Index of the character after this scalar
         */
        function parse3(context, start) {
          this.context = context;
          var src = context.src;
          var offset = Node$1.endOfIdentifier(src, start + 1);
          this.valueRange = new Range(start + 1, offset);
          offset = Node$1.endOfWhiteSpace(src, offset);
          offset = this.parseComment(offset);
          return offset;
        }
      )
    }]);
    return Alias2;
  }(Node$1);
  var Chomp = {
    CLIP: "CLIP",
    KEEP: "KEEP",
    STRIP: "STRIP"
  };
  var BlockValue = /* @__PURE__ */ function(_Node) {
    _inherits(BlockValue2, _Node);
    var _super = _createSuper(BlockValue2);
    function BlockValue2(type, props) {
      var _this;
      _classCallCheck(this, BlockValue2);
      _this = _super.call(this, type, props);
      _this.blockIndent = null;
      _this.chomping = Chomp.CLIP;
      _this.header = null;
      return _this;
    }
    _createClass(BlockValue2, [{
      key: "includesTrailingLines",
      get: function get() {
        return this.chomping === Chomp.KEEP;
      }
    }, {
      key: "strValue",
      get: function get() {
        if (!this.valueRange || !this.context) return null;
        var _this$valueRange = this.valueRange, start = _this$valueRange.start, end = _this$valueRange.end;
        var _this$context = this.context, indent = _this$context.indent, src = _this$context.src;
        if (this.valueRange.isEmpty()) return "";
        var lastNewLine = null;
        var ch = src[end - 1];
        while (ch === "\n" || ch === "	" || ch === " ") {
          end -= 1;
          if (end <= start) {
            if (this.chomping === Chomp.KEEP) break;
            else return "";
          }
          if (ch === "\n") lastNewLine = end;
          ch = src[end - 1];
        }
        var keepStart = end + 1;
        if (lastNewLine) {
          if (this.chomping === Chomp.KEEP) {
            keepStart = lastNewLine;
            end = this.valueRange.end;
          } else {
            end = lastNewLine;
          }
        }
        var bi = indent + this.blockIndent;
        var folded = this.type === Type.BLOCK_FOLDED;
        var atStart = true;
        var str = "";
        var sep = "";
        var prevMoreIndented = false;
        for (var i = start; i < end; ++i) {
          for (var j2 = 0; j2 < bi; ++j2) {
            if (src[i] !== " ") break;
            i += 1;
          }
          var _ch = src[i];
          if (_ch === "\n") {
            if (sep === "\n") str += "\n";
            else sep = "\n";
          } else {
            var lineEnd = Node$1.endOfLine(src, i);
            var line = src.slice(i, lineEnd);
            i = lineEnd;
            if (folded && (_ch === " " || _ch === "	") && i < keepStart) {
              if (sep === " ") sep = "\n";
              else if (!prevMoreIndented && !atStart && sep === "\n") sep = "\n\n";
              str += sep + line;
              sep = lineEnd < end && src[lineEnd] || "";
              prevMoreIndented = true;
            } else {
              str += sep + line;
              sep = folded && i < keepStart ? " " : "\n";
              prevMoreIndented = false;
            }
            if (atStart && line !== "") atStart = false;
          }
        }
        return this.chomping === Chomp.STRIP ? str : str + "\n";
      }
    }, {
      key: "parseBlockHeader",
      value: function parseBlockHeader(start) {
        var src = this.context.src;
        var offset = start + 1;
        var bi = "";
        while (true) {
          var ch = src[offset];
          switch (ch) {
            case "-":
              this.chomping = Chomp.STRIP;
              break;
            case "+":
              this.chomping = Chomp.KEEP;
              break;
            case "0":
            case "1":
            case "2":
            case "3":
            case "4":
            case "5":
            case "6":
            case "7":
            case "8":
            case "9":
              bi += ch;
              break;
            default:
              this.blockIndent = Number(bi) || null;
              this.header = new Range(start, offset);
              return offset;
          }
          offset += 1;
        }
      }
    }, {
      key: "parseBlockValue",
      value: function parseBlockValue(start) {
        var _this$context2 = this.context, indent = _this$context2.indent, src = _this$context2.src;
        var explicit = !!this.blockIndent;
        var offset = start;
        var valueEnd = start;
        var minBlockIndent = 1;
        for (var ch = src[offset]; ch === "\n"; ch = src[offset]) {
          offset += 1;
          if (Node$1.atDocumentBoundary(src, offset)) break;
          var end = Node$1.endOfBlockIndent(src, indent, offset);
          if (end === null) break;
          var _ch2 = src[end];
          var lineIndent = end - (offset + indent);
          if (!this.blockIndent) {
            if (src[end] !== "\n") {
              if (lineIndent < minBlockIndent) {
                var msg = "Block scalars with more-indented leading empty lines must use an explicit indentation indicator";
                this.error = new YAMLSemanticError(this, msg);
              }
              this.blockIndent = lineIndent;
            } else if (lineIndent > minBlockIndent) {
              minBlockIndent = lineIndent;
            }
          } else if (_ch2 && _ch2 !== "\n" && lineIndent < this.blockIndent) {
            if (src[end] === "#") break;
            if (!this.error) {
              var _src = explicit ? "explicit indentation indicator" : "first line";
              var _msg = "Block scalars must not be less indented than their ".concat(_src);
              this.error = new YAMLSemanticError(this, _msg);
            }
          }
          if (src[end] === "\n") {
            offset = end;
          } else {
            offset = valueEnd = Node$1.endOfLine(src, end);
          }
        }
        if (this.chomping !== Chomp.KEEP) {
          offset = src[valueEnd] ? valueEnd + 1 : valueEnd;
        }
        this.valueRange = new Range(start + 1, offset);
        return offset;
      }
      /**
       * Parses a block value from the source
       *
       * Accepted forms are:
       * ```
       * BS
       * block
       * lines
       *
       * BS #comment
       * block
       * lines
       * ```
       * where the block style BS matches the regexp `[|>][-+1-9]*` and block lines
       * are empty or have an indent level greater than `indent`.
       *
       * @param {ParseContext} context
       * @param {number} start - Index of first character
       * @returns {number} - Index of the character after this block
       */
    }, {
      key: "parse",
      value: function parse3(context, start) {
        this.context = context;
        var src = context.src;
        var offset = this.parseBlockHeader(start);
        offset = Node$1.endOfWhiteSpace(src, offset);
        offset = this.parseComment(offset);
        offset = this.parseBlockValue(offset);
        return offset;
      }
    }, {
      key: "setOrigRanges",
      value: function setOrigRanges(cr, offset) {
        offset = _get(_getPrototypeOf(BlockValue2.prototype), "setOrigRanges", this).call(this, cr, offset);
        return this.header ? this.header.setOrigRange(cr, offset) : offset;
      }
    }]);
    return BlockValue2;
  }(Node$1);
  var FlowCollection = /* @__PURE__ */ function(_Node) {
    _inherits(FlowCollection2, _Node);
    var _super = _createSuper(FlowCollection2);
    function FlowCollection2(type, props) {
      var _this;
      _classCallCheck(this, FlowCollection2);
      _this = _super.call(this, type, props);
      _this.items = null;
      return _this;
    }
    _createClass(FlowCollection2, [{
      key: "prevNodeIsJsonLike",
      value: function prevNodeIsJsonLike() {
        var idx = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.items.length;
        var node = this.items[idx - 1];
        return !!node && (node.jsonLike || node.type === Type.COMMENT && this.prevNodeIsJsonLike(idx - 1));
      }
      /**
       * @param {ParseContext} context
       * @param {number} start - Index of first character
       * @returns {number} - Index of the character after this
       */
    }, {
      key: "parse",
      value: function parse3(context, start) {
        this.context = context;
        var parseNode = context.parseNode, src = context.src;
        var indent = context.indent, lineStart = context.lineStart;
        var char = src[start];
        this.items = [{
          char,
          offset: start
        }];
        var offset = Node$1.endOfWhiteSpace(src, start + 1);
        char = src[offset];
        while (char && char !== "]" && char !== "}") {
          switch (char) {
            case "\n":
              {
                lineStart = offset + 1;
                var wsEnd = Node$1.endOfWhiteSpace(src, lineStart);
                if (src[wsEnd] === "\n") {
                  var blankLine = new BlankLine();
                  lineStart = blankLine.parse({
                    src
                  }, lineStart);
                  this.items.push(blankLine);
                }
                offset = Node$1.endOfIndent(src, lineStart);
                if (offset <= lineStart + indent) {
                  char = src[offset];
                  if (offset < lineStart + indent || char !== "]" && char !== "}") {
                    var msg = "Insufficient indentation in flow collection";
                    this.error = new YAMLSemanticError(this, msg);
                  }
                }
              }
              break;
            case ",":
              {
                this.items.push({
                  char,
                  offset
                });
                offset += 1;
              }
              break;
            case "#":
              {
                var comment = new Comment();
                offset = comment.parse({
                  src
                }, offset);
                this.items.push(comment);
              }
              break;
            case "?":
            case ":": {
              var next = src[offset + 1];
              if (next === "\n" || next === "	" || next === " " || next === "," || // in-flow : after JSON-like key does not need to be followed by whitespace
              char === ":" && this.prevNodeIsJsonLike()) {
                this.items.push({
                  char,
                  offset
                });
                offset += 1;
                break;
              }
            }
            default: {
              var node = parseNode({
                atLineStart: false,
                inCollection: false,
                inFlow: true,
                indent: -1,
                lineStart,
                parent: this
              }, offset);
              if (!node) {
                this.valueRange = new Range(start, offset);
                return offset;
              }
              this.items.push(node);
              offset = Node$1.normalizeOffset(src, node.range.end);
            }
          }
          offset = Node$1.endOfWhiteSpace(src, offset);
          char = src[offset];
        }
        this.valueRange = new Range(start, offset + 1);
        if (char) {
          this.items.push({
            char,
            offset
          });
          offset = Node$1.endOfWhiteSpace(src, offset + 1);
          offset = this.parseComment(offset);
        }
        return offset;
      }
    }, {
      key: "setOrigRanges",
      value: function setOrigRanges(cr, offset) {
        offset = _get(_getPrototypeOf(FlowCollection2.prototype), "setOrigRanges", this).call(this, cr, offset);
        this.items.forEach(function(node) {
          if (node instanceof Node$1) {
            offset = node.setOrigRanges(cr, offset);
          } else if (cr.length === 0) {
            node.origOffset = node.offset;
          } else {
            var i = offset;
            while (i < cr.length) {
              if (cr[i] > node.offset) break;
              else ++i;
            }
            node.origOffset = node.offset + i;
            offset = i;
          }
        });
        return offset;
      }
    }, {
      key: "toString",
      value: function toString() {
        var src = this.context.src, items = this.items, range = this.range, value = this.value;
        if (value != null) return value;
        var nodes = items.filter(function(item) {
          return item instanceof Node$1;
        });
        var str = "";
        var prevEnd = range.start;
        nodes.forEach(function(node) {
          var prefix = src.slice(prevEnd, node.range.start);
          prevEnd = node.range.end;
          str += prefix + String(node);
          if (str[str.length - 1] === "\n" && src[prevEnd - 1] !== "\n" && src[prevEnd] === "\n") {
            prevEnd += 1;
          }
        });
        str += src.slice(prevEnd, range.end);
        return Node$1.addStringTerminator(src, range.end, str);
      }
    }]);
    return FlowCollection2;
  }(Node$1);
  var QuoteDouble = /* @__PURE__ */ function(_Node) {
    _inherits(QuoteDouble2, _Node);
    var _super = _createSuper(QuoteDouble2);
    function QuoteDouble2() {
      _classCallCheck(this, QuoteDouble2);
      return _super.apply(this, arguments);
    }
    _createClass(QuoteDouble2, [{
      key: "strValue",
      get: (
        /**
         * @returns {string | { str: string, errors: YAMLSyntaxError[] }}
         */
        function get() {
          if (!this.valueRange || !this.context) return null;
          var errors = [];
          var _this$valueRange = this.valueRange, start = _this$valueRange.start, end = _this$valueRange.end;
          var _this$context = this.context, indent = _this$context.indent, src = _this$context.src;
          if (src[end - 1] !== '"') errors.push(new YAMLSyntaxError(this, 'Missing closing "quote'));
          var str = "";
          for (var i = start + 1; i < end - 1; ++i) {
            var ch = src[i];
            if (ch === "\n") {
              if (Node$1.atDocumentBoundary(src, i + 1)) errors.push(new YAMLSemanticError(this, "Document boundary indicators are not allowed within string values"));
              var _Node$foldNewline = Node$1.foldNewline(src, i, indent), fold = _Node$foldNewline.fold, offset = _Node$foldNewline.offset, error = _Node$foldNewline.error;
              str += fold;
              i = offset;
              if (error) errors.push(new YAMLSemanticError(this, "Multi-line double-quoted string needs to be sufficiently indented"));
            } else if (ch === "\\") {
              i += 1;
              switch (src[i]) {
                case "0":
                  str += "\0";
                  break;
                case "a":
                  str += "\x07";
                  break;
                case "b":
                  str += "\b";
                  break;
                case "e":
                  str += "\x1B";
                  break;
                case "f":
                  str += "\f";
                  break;
                case "n":
                  str += "\n";
                  break;
                case "r":
                  str += "\r";
                  break;
                case "t":
                  str += "	";
                  break;
                case "v":
                  str += "\v";
                  break;
                case "N":
                  str += "";
                  break;
                case "_":
                  str += " ";
                  break;
                case "L":
                  str += "\u2028";
                  break;
                case "P":
                  str += "\u2029";
                  break;
                case " ":
                  str += " ";
                  break;
                case '"':
                  str += '"';
                  break;
                case "/":
                  str += "/";
                  break;
                case "\\":
                  str += "\\";
                  break;
                case "	":
                  str += "	";
                  break;
                case "x":
                  str += this.parseCharCode(i + 1, 2, errors);
                  i += 2;
                  break;
                case "u":
                  str += this.parseCharCode(i + 1, 4, errors);
                  i += 4;
                  break;
                case "U":
                  str += this.parseCharCode(i + 1, 8, errors);
                  i += 8;
                  break;
                case "\n":
                  while (src[i + 1] === " " || src[i + 1] === "	") {
                    i += 1;
                  }
                  break;
                default:
                  errors.push(new YAMLSyntaxError(this, "Invalid escape sequence ".concat(src.substr(i - 1, 2))));
                  str += "\\" + src[i];
              }
            } else if (ch === " " || ch === "	") {
              var wsStart = i;
              var next = src[i + 1];
              while (next === " " || next === "	") {
                i += 1;
                next = src[i + 1];
              }
              if (next !== "\n") str += i > wsStart ? src.slice(wsStart, i + 1) : ch;
            } else {
              str += ch;
            }
          }
          return errors.length > 0 ? {
            errors,
            str
          } : str;
        }
      )
    }, {
      key: "parseCharCode",
      value: function parseCharCode(offset, length, errors) {
        var src = this.context.src;
        var cc = src.substr(offset, length);
        var ok = cc.length === length && /^[0-9a-fA-F]+$/.test(cc);
        var code2 = ok ? parseInt(cc, 16) : NaN;
        if (isNaN(code2)) {
          errors.push(new YAMLSyntaxError(this, "Invalid escape sequence ".concat(src.substr(offset - 2, length + 2))));
          return src.substr(offset - 2, length + 2);
        }
        return String.fromCodePoint(code2);
      }
      /**
       * Parses a "double quoted" value from the source
       *
       * @param {ParseContext} context
       * @param {number} start - Index of first character
       * @returns {number} - Index of the character after this scalar
       */
    }, {
      key: "parse",
      value: function parse3(context, start) {
        this.context = context;
        var src = context.src;
        var offset = QuoteDouble2.endOfQuote(src, start + 1);
        this.valueRange = new Range(start, offset);
        offset = Node$1.endOfWhiteSpace(src, offset);
        offset = this.parseComment(offset);
        return offset;
      }
    }], [{
      key: "endOfQuote",
      value: function endOfQuote(src, offset) {
        var ch = src[offset];
        while (ch && ch !== '"') {
          offset += ch === "\\" ? 2 : 1;
          ch = src[offset];
        }
        return offset + 1;
      }
    }]);
    return QuoteDouble2;
  }(Node$1);
  var QuoteSingle = /* @__PURE__ */ function(_Node) {
    _inherits(QuoteSingle2, _Node);
    var _super = _createSuper(QuoteSingle2);
    function QuoteSingle2() {
      _classCallCheck(this, QuoteSingle2);
      return _super.apply(this, arguments);
    }
    _createClass(QuoteSingle2, [{
      key: "strValue",
      get: (
        /**
         * @returns {string | { str: string, errors: YAMLSyntaxError[] }}
         */
        function get() {
          if (!this.valueRange || !this.context) return null;
          var errors = [];
          var _this$valueRange = this.valueRange, start = _this$valueRange.start, end = _this$valueRange.end;
          var _this$context = this.context, indent = _this$context.indent, src = _this$context.src;
          if (src[end - 1] !== "'") errors.push(new YAMLSyntaxError(this, "Missing closing 'quote"));
          var str = "";
          for (var i = start + 1; i < end - 1; ++i) {
            var ch = src[i];
            if (ch === "\n") {
              if (Node$1.atDocumentBoundary(src, i + 1)) errors.push(new YAMLSemanticError(this, "Document boundary indicators are not allowed within string values"));
              var _Node$foldNewline = Node$1.foldNewline(src, i, indent), fold = _Node$foldNewline.fold, offset = _Node$foldNewline.offset, error = _Node$foldNewline.error;
              str += fold;
              i = offset;
              if (error) errors.push(new YAMLSemanticError(this, "Multi-line single-quoted string needs to be sufficiently indented"));
            } else if (ch === "'") {
              str += ch;
              i += 1;
              if (src[i] !== "'") errors.push(new YAMLSyntaxError(this, "Unescaped single quote? This should not happen."));
            } else if (ch === " " || ch === "	") {
              var wsStart = i;
              var next = src[i + 1];
              while (next === " " || next === "	") {
                i += 1;
                next = src[i + 1];
              }
              if (next !== "\n") str += i > wsStart ? src.slice(wsStart, i + 1) : ch;
            } else {
              str += ch;
            }
          }
          return errors.length > 0 ? {
            errors,
            str
          } : str;
        }
      )
      /**
       * Parses a 'single quoted' value from the source
       *
       * @param {ParseContext} context
       * @param {number} start - Index of first character
       * @returns {number} - Index of the character after this scalar
       */
    }, {
      key: "parse",
      value: function parse3(context, start) {
        this.context = context;
        var src = context.src;
        var offset = QuoteSingle2.endOfQuote(src, start + 1);
        this.valueRange = new Range(start, offset);
        offset = Node$1.endOfWhiteSpace(src, offset);
        offset = this.parseComment(offset);
        return offset;
      }
    }], [{
      key: "endOfQuote",
      value: function endOfQuote(src, offset) {
        var ch = src[offset];
        while (ch) {
          if (ch === "'") {
            if (src[offset + 1] !== "'") break;
            ch = src[offset += 2];
          } else {
            ch = src[offset += 1];
          }
        }
        return offset + 1;
      }
    }]);
    return QuoteSingle2;
  }(Node$1);
  function createNewNode(type, props) {
    switch (type) {
      case Type.ALIAS:
        return new Alias$1(type, props);
      case Type.BLOCK_FOLDED:
      case Type.BLOCK_LITERAL:
        return new BlockValue(type, props);
      case Type.FLOW_MAP:
      case Type.FLOW_SEQ:
        return new FlowCollection(type, props);
      case Type.MAP_KEY:
      case Type.MAP_VALUE:
      case Type.SEQ_ITEM:
        return new CollectionItem(type, props);
      case Type.COMMENT:
      case Type.PLAIN:
        return new PlainValue(type, props);
      case Type.QUOTE_DOUBLE:
        return new QuoteDouble(type, props);
      case Type.QUOTE_SINGLE:
        return new QuoteSingle(type, props);
      default:
        return null;
    }
  }
  var ParseContext = /* @__PURE__ */ function() {
    function ParseContext2() {
      var _this = this;
      var orig = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      var _ref = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, atLineStart = _ref.atLineStart, inCollection = _ref.inCollection, inFlow = _ref.inFlow, indent = _ref.indent, lineStart = _ref.lineStart, parent = _ref.parent;
      _classCallCheck(this, ParseContext2);
      _defineProperty(this, "parseNode", function(overlay, start) {
        if (Node$1.atDocumentBoundary(_this.src, start)) return null;
        var context = new ParseContext2(_this, overlay);
        var _context$parseProps = context.parseProps(start), props = _context$parseProps.props, type = _context$parseProps.type, valueStart = _context$parseProps.valueStart;
        var node = createNewNode(type, props);
        var offset = node.parse(context, valueStart);
        node.range = new Range(start, offset);
        if (offset <= start) {
          node.error = new Error("Node#parse consumed no characters");
          node.error.parseEnd = offset;
          node.error.source = node;
          node.range.end = start + 1;
        }
        if (context.nodeStartsCollection(node)) {
          if (!node.error && !context.atLineStart && context.parent.type === Type.DOCUMENT) {
            node.error = new YAMLSyntaxError(node, "Block collection must not have preceding content here (e.g. directives-end indicator)");
          }
          var collection = new Collection$1(node);
          offset = collection.parse(new ParseContext2(context), offset);
          collection.range = new Range(start, offset);
          return collection;
        }
        return node;
      });
      this.atLineStart = atLineStart != null ? atLineStart : orig.atLineStart || false;
      this.inCollection = inCollection != null ? inCollection : orig.inCollection || false;
      this.inFlow = inFlow != null ? inFlow : orig.inFlow || false;
      this.indent = indent != null ? indent : orig.indent;
      this.lineStart = lineStart != null ? lineStart : orig.lineStart;
      this.parent = parent != null ? parent : orig.parent || {};
      this.root = orig.root;
      this.src = orig.src;
    }
    _createClass(ParseContext2, [{
      key: "nodeStartsCollection",
      value: function nodeStartsCollection(node) {
        var inCollection = this.inCollection, inFlow = this.inFlow, src = this.src;
        if (inCollection || inFlow) return false;
        if (node instanceof CollectionItem) return true;
        var offset = node.range.end;
        if (src[offset] === "\n" || src[offset - 1] === "\n") return false;
        offset = Node$1.endOfWhiteSpace(src, offset);
        return src[offset] === ":";
      }
      // Anchor and tag are before type, which determines the node implementation
      // class; hence this intermediate step.
    }, {
      key: "parseProps",
      value: function parseProps(offset) {
        var inFlow = this.inFlow, parent = this.parent, src = this.src;
        var props = [];
        var lineHasProps = false;
        offset = this.atLineStart ? Node$1.endOfIndent(src, offset) : Node$1.endOfWhiteSpace(src, offset);
        var ch = src[offset];
        while (ch === Char.ANCHOR || ch === Char.COMMENT || ch === Char.TAG || ch === "\n") {
          if (ch === "\n") {
            var inEnd = offset;
            var lineStart = void 0;
            do {
              lineStart = inEnd + 1;
              inEnd = Node$1.endOfIndent(src, lineStart);
            } while (src[inEnd] === "\n");
            var indentDiff = inEnd - (lineStart + this.indent);
            var noIndicatorAsIndent = parent.type === Type.SEQ_ITEM && parent.context.atLineStart;
            if (src[inEnd] !== "#" && !Node$1.nextNodeIsIndented(src[inEnd], indentDiff, !noIndicatorAsIndent)) break;
            this.atLineStart = true;
            this.lineStart = lineStart;
            lineHasProps = false;
            offset = inEnd;
          } else if (ch === Char.COMMENT) {
            var end = Node$1.endOfLine(src, offset + 1);
            props.push(new Range(offset, end));
            offset = end;
          } else {
            var _end = Node$1.endOfIdentifier(src, offset + 1);
            if (ch === Char.TAG && src[_end] === "," && /^[a-zA-Z0-9-]+\.[a-zA-Z0-9-]+,\d\d\d\d(-\d\d){0,2}\/\S/.test(src.slice(offset + 1, _end + 13))) {
              _end = Node$1.endOfIdentifier(src, _end + 5);
            }
            props.push(new Range(offset, _end));
            lineHasProps = true;
            offset = Node$1.endOfWhiteSpace(src, _end);
          }
          ch = src[offset];
        }
        if (lineHasProps && ch === ":" && Node$1.atBlank(src, offset + 1, true)) offset -= 1;
        var type = ParseContext2.parseType(src, offset, inFlow);
        return {
          props,
          type,
          valueStart: offset
        };
      }
      /**
       * Parses a node from the source
       * @param {ParseContext} overlay
       * @param {number} start - Index of first non-whitespace character for the node
       * @returns {?Node} - null if at a document boundary
       */
    }], [{
      key: "parseType",
      value: function parseType(src, offset, inFlow) {
        switch (src[offset]) {
          case "*":
            return Type.ALIAS;
          case ">":
            return Type.BLOCK_FOLDED;
          case "|":
            return Type.BLOCK_LITERAL;
          case "{":
            return Type.FLOW_MAP;
          case "[":
            return Type.FLOW_SEQ;
          case "?":
            return !inFlow && Node$1.atBlank(src, offset + 1, true) ? Type.MAP_KEY : Type.PLAIN;
          case ":":
            return !inFlow && Node$1.atBlank(src, offset + 1, true) ? Type.MAP_VALUE : Type.PLAIN;
          case "-":
            return !inFlow && Node$1.atBlank(src, offset + 1, true) ? Type.SEQ_ITEM : Type.PLAIN;
          case '"':
            return Type.QUOTE_DOUBLE;
          case "'":
            return Type.QUOTE_SINGLE;
          default:
            return Type.PLAIN;
        }
      }
    }]);
    return ParseContext2;
  }();
  function parse$1(src) {
    var cr = [];
    if (src.indexOf("\r") !== -1) {
      src = src.replace(/\r\n?/g, function(match, offset2) {
        if (match.length > 1) cr.push(offset2);
        return "\n";
      });
    }
    var documents = [];
    var offset = 0;
    do {
      var doc = new Document$2();
      var context = new ParseContext({
        src
      });
      offset = doc.parse(context, offset);
      documents.push(doc);
    } while (offset < src.length);
    documents.setOrigRanges = function() {
      if (cr.length === 0) return false;
      for (var i = 1; i < cr.length; ++i) {
        cr[i] -= i;
      }
      var crOffset = 0;
      for (var _i = 0; _i < documents.length; ++_i) {
        crOffset = documents[_i].setOrigRanges(cr, crOffset);
      }
      cr.splice(0, cr.length);
      return true;
    };
    documents.toString = function() {
      return documents.join("...\n");
    };
    return documents;
  }
  function addCommentBefore(str, indent, comment) {
    if (!comment) return str;
    var cc = comment.replace(/[\s\S]^/gm, "$&".concat(indent, "#"));
    return "#".concat(cc, "\n").concat(indent).concat(str);
  }
  function addComment(str, indent, comment) {
    return !comment ? str : comment.indexOf("\n") === -1 ? "".concat(str, " #").concat(comment) : "".concat(str, "\n") + comment.replace(/^/gm, "".concat(indent || "", "#"));
  }
  var Node = function Node2() {
    _classCallCheck(this, Node2);
  };
  function toJSON(value, arg, ctx) {
    if (Array.isArray(value)) return value.map(function(v2, i) {
      return toJSON(v2, String(i), ctx);
    });
    if (value && typeof value.toJSON === "function") {
      var anchor = ctx && ctx.anchors && ctx.anchors.get(value);
      if (anchor) ctx.onCreate = function(res2) {
        anchor.res = res2;
        delete ctx.onCreate;
      };
      var res = value.toJSON(arg, ctx);
      if (anchor && ctx.onCreate) ctx.onCreate(res);
      return res;
    }
    if ((!ctx || !ctx.keep) && typeof value === "bigint") return Number(value);
    return value;
  }
  var Scalar = /* @__PURE__ */ function(_Node) {
    _inherits(Scalar2, _Node);
    var _super = _createSuper(Scalar2);
    function Scalar2(value) {
      var _this;
      _classCallCheck(this, Scalar2);
      _this = _super.call(this);
      _this.value = value;
      return _this;
    }
    _createClass(Scalar2, [{
      key: "toJSON",
      value: function toJSON$1(arg, ctx) {
        return ctx && ctx.keep ? this.value : toJSON(this.value, arg, ctx);
      }
    }, {
      key: "toString",
      value: function toString() {
        return String(this.value);
      }
    }]);
    return Scalar2;
  }(Node);
  function collectionFromPath(schema, path2, value) {
    var v2 = value;
    for (var i = path2.length - 1; i >= 0; --i) {
      var k2 = path2[i];
      if (Number.isInteger(k2) && k2 >= 0) {
        var a2 = [];
        a2[k2] = v2;
        v2 = a2;
      } else {
        var o2 = {};
        Object.defineProperty(o2, k2, {
          value: v2,
          writable: true,
          enumerable: true,
          configurable: true
        });
        v2 = o2;
      }
    }
    return schema.createNode(v2, false);
  }
  var isEmptyPath = function isEmptyPath2(path2) {
    return path2 == null || _typeof(path2) === "object" && path2[Symbol.iterator]().next().done;
  };
  var Collection = /* @__PURE__ */ function(_Node) {
    _inherits(Collection2, _Node);
    var _super = _createSuper(Collection2);
    function Collection2(schema) {
      var _this;
      _classCallCheck(this, Collection2);
      _this = _super.call(this);
      _defineProperty(_assertThisInitialized(_this), "items", []);
      _this.schema = schema;
      return _this;
    }
    _createClass(Collection2, [{
      key: "addIn",
      value: function addIn(path2, value) {
        if (isEmptyPath(path2)) this.add(value);
        else {
          var _path = _toArray(path2), key = _path[0], rest = _path.slice(1);
          var node = this.get(key, true);
          if (node instanceof Collection2) node.addIn(rest, value);
          else if (node === void 0 && this.schema) this.set(key, collectionFromPath(this.schema, rest, value));
          else throw new Error("Expected YAML collection at ".concat(key, ". Remaining path: ").concat(rest));
        }
      }
    }, {
      key: "deleteIn",
      value: function deleteIn(_ref) {
        var _ref2 = _toArray(_ref), key = _ref2[0], rest = _ref2.slice(1);
        if (rest.length === 0) return this.delete(key);
        var node = this.get(key, true);
        if (node instanceof Collection2) return node.deleteIn(rest);
        else throw new Error("Expected YAML collection at ".concat(key, ". Remaining path: ").concat(rest));
      }
    }, {
      key: "getIn",
      value: function getIn(_ref3, keepScalar) {
        var _ref4 = _toArray(_ref3), key = _ref4[0], rest = _ref4.slice(1);
        var node = this.get(key, true);
        if (rest.length === 0) return !keepScalar && node instanceof Scalar ? node.value : node;
        else return node instanceof Collection2 ? node.getIn(rest, keepScalar) : void 0;
      }
    }, {
      key: "hasAllNullValues",
      value: function hasAllNullValues() {
        return this.items.every(function(node) {
          if (!node || node.type !== "PAIR") return false;
          var n = node.value;
          return n == null || n instanceof Scalar && n.value == null && !n.commentBefore && !n.comment && !n.tag;
        });
      }
    }, {
      key: "hasIn",
      value: function hasIn(_ref5) {
        var _ref6 = _toArray(_ref5), key = _ref6[0], rest = _ref6.slice(1);
        if (rest.length === 0) return this.has(key);
        var node = this.get(key, true);
        return node instanceof Collection2 ? node.hasIn(rest) : false;
      }
    }, {
      key: "setIn",
      value: function setIn(_ref7, value) {
        var _ref8 = _toArray(_ref7), key = _ref8[0], rest = _ref8.slice(1);
        if (rest.length === 0) {
          this.set(key, value);
        } else {
          var node = this.get(key, true);
          if (node instanceof Collection2) node.setIn(rest, value);
          else if (node === void 0 && this.schema) this.set(key, collectionFromPath(this.schema, rest, value));
          else throw new Error("Expected YAML collection at ".concat(key, ". Remaining path: ").concat(rest));
        }
      }
      // overridden in implementations
      /* istanbul ignore next */
    }, {
      key: "toJSON",
      value: function toJSON2() {
        return null;
      }
    }, {
      key: "toString",
      value: function toString(ctx, _ref9, onComment, onChompKeep) {
        var _this2 = this;
        var blockItem = _ref9.blockItem, flowChars = _ref9.flowChars, isMap = _ref9.isMap, itemIndent = _ref9.itemIndent;
        var _ctx = ctx, indent = _ctx.indent, indentStep = _ctx.indentStep, stringify16 = _ctx.stringify;
        var inFlow = this.type === Type.FLOW_MAP || this.type === Type.FLOW_SEQ || ctx.inFlow;
        if (inFlow) itemIndent += indentStep;
        var allNullValues = isMap && this.hasAllNullValues();
        ctx = Object.assign({}, ctx, {
          allNullValues,
          indent: itemIndent,
          inFlow,
          type: null
        });
        var chompKeep = false;
        var hasItemWithNewLine = false;
        var nodes = this.items.reduce(function(nodes2, item, i) {
          var comment;
          if (item) {
            if (!chompKeep && item.spaceBefore) nodes2.push({
              type: "comment",
              str: ""
            });
            if (item.commentBefore) item.commentBefore.match(/^.*$/gm).forEach(function(line) {
              nodes2.push({
                type: "comment",
                str: "#".concat(line)
              });
            });
            if (item.comment) comment = item.comment;
            if (inFlow && (!chompKeep && item.spaceBefore || item.commentBefore || item.comment || item.key && (item.key.commentBefore || item.key.comment) || item.value && (item.value.commentBefore || item.value.comment))) hasItemWithNewLine = true;
          }
          chompKeep = false;
          var str2 = stringify16(item, ctx, function() {
            return comment = null;
          }, function() {
            return chompKeep = true;
          });
          if (inFlow && !hasItemWithNewLine && str2.includes("\n")) hasItemWithNewLine = true;
          if (inFlow && i < _this2.items.length - 1) str2 += ",";
          str2 = addComment(str2, itemIndent, comment);
          if (chompKeep && (comment || inFlow)) chompKeep = false;
          nodes2.push({
            type: "item",
            str: str2
          });
          return nodes2;
        }, []);
        var str;
        if (nodes.length === 0) {
          str = flowChars.start + flowChars.end;
        } else if (inFlow) {
          var start = flowChars.start, end = flowChars.end;
          var strings = nodes.map(function(n) {
            return n.str;
          });
          if (hasItemWithNewLine || strings.reduce(function(sum, str2) {
            return sum + str2.length + 2;
          }, 2) > Collection2.maxFlowStringSingleLineLength) {
            str = start;
            var _iterator = _createForOfIteratorHelper(strings), _step;
            try {
              for (_iterator.s(); !(_step = _iterator.n()).done; ) {
                var s2 = _step.value;
                str += s2 ? "\n".concat(indentStep).concat(indent).concat(s2) : "\n";
              }
            } catch (err) {
              _iterator.e(err);
            } finally {
              _iterator.f();
            }
            str += "\n".concat(indent).concat(end);
          } else {
            str = "".concat(start, " ").concat(strings.join(" "), " ").concat(end);
          }
        } else {
          var _strings = nodes.map(blockItem);
          str = _strings.shift();
          var _iterator2 = _createForOfIteratorHelper(_strings), _step2;
          try {
            for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
              var _s = _step2.value;
              str += _s ? "\n".concat(indent).concat(_s) : "\n";
            }
          } catch (err) {
            _iterator2.e(err);
          } finally {
            _iterator2.f();
          }
        }
        if (this.comment) {
          str += "\n" + this.comment.replace(/^/gm, "".concat(indent, "#"));
          if (onComment) onComment();
        } else if (chompKeep && onChompKeep) onChompKeep();
        return str;
      }
    }]);
    return Collection2;
  }(Node);
  _defineProperty(Collection, "maxFlowStringSingleLineLength", 60);
  function asItemIndex(key) {
    var idx = key instanceof Scalar ? key.value : key;
    if (idx && typeof idx === "string") idx = Number(idx);
    return Number.isInteger(idx) && idx >= 0 ? idx : null;
  }
  var YAMLSeq = /* @__PURE__ */ function(_Collection) {
    _inherits(YAMLSeq2, _Collection);
    var _super = _createSuper(YAMLSeq2);
    function YAMLSeq2() {
      _classCallCheck(this, YAMLSeq2);
      return _super.apply(this, arguments);
    }
    _createClass(YAMLSeq2, [{
      key: "add",
      value: function add(value) {
        this.items.push(value);
      }
    }, {
      key: "delete",
      value: function _delete(key) {
        var idx = asItemIndex(key);
        if (typeof idx !== "number") return false;
        var del = this.items.splice(idx, 1);
        return del.length > 0;
      }
    }, {
      key: "get",
      value: function get(key, keepScalar) {
        var idx = asItemIndex(key);
        if (typeof idx !== "number") return void 0;
        var it = this.items[idx];
        return !keepScalar && it instanceof Scalar ? it.value : it;
      }
    }, {
      key: "has",
      value: function has(key) {
        var idx = asItemIndex(key);
        return typeof idx === "number" && idx < this.items.length;
      }
    }, {
      key: "set",
      value: function set2(key, value) {
        var idx = asItemIndex(key);
        if (typeof idx !== "number") throw new Error("Expected a valid index, not ".concat(key, "."));
        this.items[idx] = value;
      }
    }, {
      key: "toJSON",
      value: function toJSON$1(_2, ctx) {
        var seq2 = [];
        if (ctx && ctx.onCreate) ctx.onCreate(seq2);
        var i = 0;
        var _iterator = _createForOfIteratorHelper(this.items), _step;
        try {
          for (_iterator.s(); !(_step = _iterator.n()).done; ) {
            var item = _step.value;
            seq2.push(toJSON(item, String(i++), ctx));
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
        return seq2;
      }
    }, {
      key: "toString",
      value: function toString(ctx, onComment, onChompKeep) {
        if (!ctx) return JSON.stringify(this);
        return _get(_getPrototypeOf(YAMLSeq2.prototype), "toString", this).call(this, ctx, {
          blockItem: function blockItem(n) {
            return n.type === "comment" ? n.str : "- ".concat(n.str);
          },
          flowChars: {
            start: "[",
            end: "]"
          },
          isMap: false,
          itemIndent: (ctx.indent || "") + "  "
        }, onComment, onChompKeep);
      }
    }]);
    return YAMLSeq2;
  }(Collection);
  var stringifyKey = function stringifyKey2(key, jsKey, ctx) {
    if (jsKey === null) return "";
    if (_typeof(jsKey) !== "object") return String(jsKey);
    if (key instanceof Node && ctx && ctx.doc) return key.toString({
      anchors: /* @__PURE__ */ Object.create(null),
      doc: ctx.doc,
      indent: "",
      indentStep: ctx.indentStep,
      inFlow: true,
      inStringifyKey: true,
      stringify: ctx.stringify
    });
    return JSON.stringify(jsKey);
  };
  var Pair = /* @__PURE__ */ function(_Node) {
    _inherits(Pair2, _Node);
    var _super = _createSuper(Pair2);
    function Pair2(key) {
      var _this;
      var value = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
      _classCallCheck(this, Pair2);
      _this = _super.call(this);
      _this.key = key;
      _this.value = value;
      _this.type = Pair2.Type.PAIR;
      return _this;
    }
    _createClass(Pair2, [{
      key: "commentBefore",
      get: function get() {
        return this.key instanceof Node ? this.key.commentBefore : void 0;
      },
      set: function set2(cb) {
        if (this.key == null) this.key = new Scalar(null);
        if (this.key instanceof Node) this.key.commentBefore = cb;
        else {
          var msg = "Pair.commentBefore is an alias for Pair.key.commentBefore. To set it, the key must be a Node.";
          throw new Error(msg);
        }
      }
    }, {
      key: "addToJSMap",
      value: function addToJSMap(ctx, map2) {
        var key = toJSON(this.key, "", ctx);
        if (map2 instanceof Map) {
          var value = toJSON(this.value, key, ctx);
          map2.set(key, value);
        } else if (map2 instanceof Set) {
          map2.add(key);
        } else {
          var stringKey = stringifyKey(this.key, key, ctx);
          var _value = toJSON(this.value, stringKey, ctx);
          if (stringKey in map2) Object.defineProperty(map2, stringKey, {
            value: _value,
            writable: true,
            enumerable: true,
            configurable: true
          });
          else map2[stringKey] = _value;
        }
        return map2;
      }
    }, {
      key: "toJSON",
      value: function toJSON2(_2, ctx) {
        var pair = ctx && ctx.mapAsMap ? /* @__PURE__ */ new Map() : {};
        return this.addToJSMap(ctx, pair);
      }
    }, {
      key: "toString",
      value: function toString(ctx, onComment, onChompKeep) {
        if (!ctx || !ctx.doc) return JSON.stringify(this);
        var _ctx$doc$options = ctx.doc.options, indentSize = _ctx$doc$options.indent, indentSeq = _ctx$doc$options.indentSeq, simpleKeys = _ctx$doc$options.simpleKeys;
        var key = this.key, value = this.value;
        var keyComment = key instanceof Node && key.comment;
        if (simpleKeys) {
          if (keyComment) {
            throw new Error("With simple keys, key nodes cannot have comments");
          }
          if (key instanceof Collection) {
            var msg = "With simple keys, collection cannot be used as a key value";
            throw new Error(msg);
          }
        }
        var explicitKey = !simpleKeys && (!key || keyComment || (key instanceof Node ? key instanceof Collection || key.type === Type.BLOCK_FOLDED || key.type === Type.BLOCK_LITERAL : _typeof(key) === "object"));
        var _ctx = ctx, doc = _ctx.doc, indent = _ctx.indent, indentStep = _ctx.indentStep, stringify16 = _ctx.stringify;
        ctx = Object.assign({}, ctx, {
          implicitKey: !explicitKey,
          indent: indent + indentStep
        });
        var chompKeep = false;
        var str = stringify16(key, ctx, function() {
          return keyComment = null;
        }, function() {
          return chompKeep = true;
        });
        str = addComment(str, ctx.indent, keyComment);
        if (!explicitKey && str.length > 1024) {
          if (simpleKeys) throw new Error("With simple keys, single line scalar must not span more than 1024 characters");
          explicitKey = true;
        }
        if (ctx.allNullValues && !simpleKeys) {
          if (this.comment) {
            str = addComment(str, ctx.indent, this.comment);
            if (onComment) onComment();
          } else if (chompKeep && !keyComment && onChompKeep) onChompKeep();
          return ctx.inFlow && !explicitKey ? str : "? ".concat(str);
        }
        str = explicitKey ? "? ".concat(str, "\n").concat(indent, ":") : "".concat(str, ":");
        if (this.comment) {
          str = addComment(str, ctx.indent, this.comment);
          if (onComment) onComment();
        }
        var vcb = "";
        var valueComment = null;
        if (value instanceof Node) {
          if (value.spaceBefore) vcb = "\n";
          if (value.commentBefore) {
            var cs = value.commentBefore.replace(/^/gm, "".concat(ctx.indent, "#"));
            vcb += "\n".concat(cs);
          }
          valueComment = value.comment;
        } else if (value && _typeof(value) === "object") {
          value = doc.schema.createNode(value, true);
        }
        ctx.implicitKey = false;
        if (!explicitKey && !this.comment && value instanceof Scalar) ctx.indentAtStart = str.length + 1;
        chompKeep = false;
        if (!indentSeq && indentSize >= 2 && !ctx.inFlow && !explicitKey && value instanceof YAMLSeq && value.type !== Type.FLOW_SEQ && !value.tag && !doc.anchors.getName(value)) {
          ctx.indent = ctx.indent.substr(2);
        }
        var valueStr = stringify16(value, ctx, function() {
          return valueComment = null;
        }, function() {
          return chompKeep = true;
        });
        var ws = " ";
        if (vcb || this.comment) {
          ws = "".concat(vcb, "\n").concat(ctx.indent);
        } else if (!explicitKey && value instanceof Collection) {
          var flow = valueStr[0] === "[" || valueStr[0] === "{";
          if (!flow || valueStr.includes("\n")) ws = "\n".concat(ctx.indent);
        } else if (valueStr[0] === "\n") ws = "";
        if (chompKeep && !valueComment && onChompKeep) onChompKeep();
        return addComment(str + ws + valueStr, ctx.indent, valueComment);
      }
    }]);
    return Pair2;
  }(Node);
  _defineProperty(Pair, "Type", {
    PAIR: "PAIR",
    MERGE_PAIR: "MERGE_PAIR"
  });
  var getAliasCount = function getAliasCount2(node, anchors) {
    if (node instanceof Alias) {
      var anchor = anchors.get(node.source);
      return anchor.count * anchor.aliasCount;
    } else if (node instanceof Collection) {
      var count = 0;
      var _iterator = _createForOfIteratorHelper(node.items), _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done; ) {
          var item = _step.value;
          var c2 = getAliasCount2(item, anchors);
          if (c2 > count) count = c2;
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
      return count;
    } else if (node instanceof Pair) {
      var kc = getAliasCount2(node.key, anchors);
      var vc = getAliasCount2(node.value, anchors);
      return Math.max(kc, vc);
    }
    return 1;
  };
  var Alias = /* @__PURE__ */ function(_Node) {
    _inherits(Alias2, _Node);
    var _super = _createSuper(Alias2);
    function Alias2(source) {
      var _this;
      _classCallCheck(this, Alias2);
      _this = _super.call(this);
      _this.source = source;
      _this.type = Type.ALIAS;
      return _this;
    }
    _createClass(Alias2, [{
      key: "tag",
      set: function set2(t2) {
        throw new Error("Alias nodes cannot have tags");
      }
    }, {
      key: "toJSON",
      value: function toJSON$1(arg, ctx) {
        if (!ctx) return toJSON(this.source, arg, ctx);
        var anchors = ctx.anchors, maxAliasCount = ctx.maxAliasCount;
        var anchor = anchors.get(this.source);
        if (!anchor || anchor.res === void 0) {
          var msg = "This should not happen: Alias anchor was not resolved?";
          if (this.cstNode) throw new YAMLReferenceError(this.cstNode, msg);
          else throw new ReferenceError(msg);
        }
        if (maxAliasCount >= 0) {
          anchor.count += 1;
          if (anchor.aliasCount === 0) anchor.aliasCount = getAliasCount(this.source, anchors);
          if (anchor.count * anchor.aliasCount > maxAliasCount) {
            var _msg = "Excessive alias count indicates a resource exhaustion attack";
            if (this.cstNode) throw new YAMLReferenceError(this.cstNode, _msg);
            else throw new ReferenceError(_msg);
          }
        }
        return anchor.res;
      }
      // Only called when stringifying an alias mapping key while constructing
      // Object output.
    }, {
      key: "toString",
      value: function toString(ctx) {
        return Alias2.stringify(this, ctx);
      }
    }], [{
      key: "stringify",
      value: function stringify16(_ref, _ref2) {
        var range = _ref.range, source = _ref.source;
        var anchors = _ref2.anchors, doc = _ref2.doc, implicitKey = _ref2.implicitKey, inStringifyKey = _ref2.inStringifyKey;
        var anchor = Object.keys(anchors).find(function(a2) {
          return anchors[a2] === source;
        });
        if (!anchor && inStringifyKey) anchor = doc.anchors.getName(source) || doc.anchors.newName();
        if (anchor) return "*".concat(anchor).concat(implicitKey ? " " : "");
        var msg = doc.anchors.getName(source) ? "Alias node must be after source node" : "Source node not found for alias node";
        throw new Error("".concat(msg, " [").concat(range, "]"));
      }
    }]);
    return Alias2;
  }(Node);
  _defineProperty(Alias, "default", true);
  function findPair(items, key) {
    var k2 = key instanceof Scalar ? key.value : key;
    var _iterator = _createForOfIteratorHelper(items), _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done; ) {
        var it = _step.value;
        if (it instanceof Pair) {
          if (it.key === key || it.key === k2) return it;
          if (it.key && it.key.value === k2) return it;
        }
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
    return void 0;
  }
  var YAMLMap = /* @__PURE__ */ function(_Collection) {
    _inherits(YAMLMap2, _Collection);
    var _super = _createSuper(YAMLMap2);
    function YAMLMap2() {
      _classCallCheck(this, YAMLMap2);
      return _super.apply(this, arguments);
    }
    _createClass(YAMLMap2, [{
      key: "add",
      value: function add(pair, overwrite) {
        if (!pair) pair = new Pair(pair);
        else if (!(pair instanceof Pair)) pair = new Pair(pair.key || pair, pair.value);
        var prev = findPair(this.items, pair.key);
        var sortEntries = this.schema && this.schema.sortMapEntries;
        if (prev) {
          if (overwrite) prev.value = pair.value;
          else throw new Error("Key ".concat(pair.key, " already set"));
        } else if (sortEntries) {
          var i = this.items.findIndex(function(item) {
            return sortEntries(pair, item) < 0;
          });
          if (i === -1) this.items.push(pair);
          else this.items.splice(i, 0, pair);
        } else {
          this.items.push(pair);
        }
      }
    }, {
      key: "delete",
      value: function _delete(key) {
        var it = findPair(this.items, key);
        if (!it) return false;
        var del = this.items.splice(this.items.indexOf(it), 1);
        return del.length > 0;
      }
    }, {
      key: "get",
      value: function get(key, keepScalar) {
        var it = findPair(this.items, key);
        var node = it && it.value;
        return !keepScalar && node instanceof Scalar ? node.value : node;
      }
    }, {
      key: "has",
      value: function has(key) {
        return !!findPair(this.items, key);
      }
    }, {
      key: "set",
      value: function set2(key, value) {
        this.add(new Pair(key, value), true);
      }
      /**
       * @param {*} arg ignored
       * @param {*} ctx Conversion context, originally set in Document#toJSON()
       * @param {Class} Type If set, forces the returned collection type
       * @returns {*} Instance of Type, Map, or Object
       */
    }, {
      key: "toJSON",
      value: function toJSON2(_2, ctx, Type2) {
        var map2 = Type2 ? new Type2() : ctx && ctx.mapAsMap ? /* @__PURE__ */ new Map() : {};
        if (ctx && ctx.onCreate) ctx.onCreate(map2);
        var _iterator2 = _createForOfIteratorHelper(this.items), _step2;
        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
            var item = _step2.value;
            item.addToJSMap(ctx, map2);
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }
        return map2;
      }
    }, {
      key: "toString",
      value: function toString(ctx, onComment, onChompKeep) {
        if (!ctx) return JSON.stringify(this);
        var _iterator3 = _createForOfIteratorHelper(this.items), _step3;
        try {
          for (_iterator3.s(); !(_step3 = _iterator3.n()).done; ) {
            var item = _step3.value;
            if (!(item instanceof Pair)) throw new Error("Map items must all be pairs; found ".concat(JSON.stringify(item), " instead"));
          }
        } catch (err) {
          _iterator3.e(err);
        } finally {
          _iterator3.f();
        }
        return _get(_getPrototypeOf(YAMLMap2.prototype), "toString", this).call(this, ctx, {
          blockItem: function blockItem(n) {
            return n.str;
          },
          flowChars: {
            start: "{",
            end: "}"
          },
          isMap: true,
          itemIndent: ctx.indent || ""
        }, onComment, onChompKeep);
      }
    }]);
    return YAMLMap2;
  }(Collection);
  var MERGE_KEY = "<<";
  var Merge = /* @__PURE__ */ function(_Pair) {
    _inherits(Merge2, _Pair);
    var _super = _createSuper(Merge2);
    function Merge2(pair) {
      var _this;
      _classCallCheck(this, Merge2);
      if (pair instanceof Pair) {
        var seq2 = pair.value;
        if (!(seq2 instanceof YAMLSeq)) {
          seq2 = new YAMLSeq();
          seq2.items.push(pair.value);
          seq2.range = pair.value.range;
        }
        _this = _super.call(this, pair.key, seq2);
        _this.range = pair.range;
      } else {
        _this = _super.call(this, new Scalar(MERGE_KEY), new YAMLSeq());
      }
      _this.type = Pair.Type.MERGE_PAIR;
      return _possibleConstructorReturn(_this);
    }
    _createClass(Merge2, [{
      key: "addToJSMap",
      value: function addToJSMap(ctx, map2) {
        var _iterator = _createForOfIteratorHelper(this.value.items), _step;
        try {
          for (_iterator.s(); !(_step = _iterator.n()).done; ) {
            var source = _step.value.source;
            if (!(source instanceof YAMLMap)) throw new Error("Merge sources must be maps");
            var srcMap = source.toJSON(null, ctx, Map);
            var _iterator2 = _createForOfIteratorHelper(srcMap), _step2;
            try {
              for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
                var _step2$value = _slicedToArray(_step2.value, 2), key = _step2$value[0], value = _step2$value[1];
                if (map2 instanceof Map) {
                  if (!map2.has(key)) map2.set(key, value);
                } else if (map2 instanceof Set) {
                  map2.add(key);
                } else if (!Object.prototype.hasOwnProperty.call(map2, key)) {
                  Object.defineProperty(map2, key, {
                    value,
                    writable: true,
                    enumerable: true,
                    configurable: true
                  });
                }
              }
            } catch (err) {
              _iterator2.e(err);
            } finally {
              _iterator2.f();
            }
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
        return map2;
      }
    }, {
      key: "toString",
      value: function toString(ctx, onComment) {
        var seq2 = this.value;
        if (seq2.items.length > 1) return _get(_getPrototypeOf(Merge2.prototype), "toString", this).call(this, ctx, onComment);
        this.value = seq2.items[0];
        var str = _get(_getPrototypeOf(Merge2.prototype), "toString", this).call(this, ctx, onComment);
        this.value = seq2;
        return str;
      }
    }]);
    return Merge2;
  }(Pair);
  var binaryOptions = {
    defaultType: Type.BLOCK_LITERAL,
    lineWidth: 76
  };
  var boolOptions = {
    trueStr: "true",
    falseStr: "false"
  };
  var intOptions = {
    asBigInt: false
  };
  var nullOptions = {
    nullStr: "null"
  };
  var strOptions = {
    defaultType: Type.PLAIN,
    doubleQuoted: {
      jsonEncoding: false,
      minMultiLineLength: 40
    },
    fold: {
      lineWidth: 80,
      minContentWidth: 20
    }
  };
  function resolveScalar(str, tags2, scalarFallback) {
    var _iterator = _createForOfIteratorHelper(tags2), _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done; ) {
        var _step$value = _step.value, format2 = _step$value.format, test = _step$value.test, resolve28 = _step$value.resolve;
        if (test) {
          var match = str.match(test);
          if (match) {
            var res = resolve28.apply(null, match);
            if (!(res instanceof Scalar)) res = new Scalar(res);
            if (format2) res.format = format2;
            return res;
          }
        }
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
    if (scalarFallback) str = scalarFallback(str);
    return new Scalar(str);
  }
  var FOLD_FLOW = "flow";
  var FOLD_BLOCK = "block";
  var FOLD_QUOTED = "quoted";
  var consumeMoreIndentedLines = function consumeMoreIndentedLines2(text2, i) {
    var ch = text2[i + 1];
    while (ch === " " || ch === "	") {
      do {
        ch = text2[i += 1];
      } while (ch && ch !== "\n");
      ch = text2[i + 1];
    }
    return i;
  };
  function foldFlowLines(text2, indent, mode, _ref) {
    var indentAtStart = _ref.indentAtStart, _ref$lineWidth = _ref.lineWidth, lineWidth = _ref$lineWidth === void 0 ? 80 : _ref$lineWidth, _ref$minContentWidth = _ref.minContentWidth, minContentWidth = _ref$minContentWidth === void 0 ? 20 : _ref$minContentWidth, onFold = _ref.onFold, onOverflow = _ref.onOverflow;
    if (!lineWidth || lineWidth < 0) return text2;
    var endStep = Math.max(1 + minContentWidth, 1 + lineWidth - indent.length);
    if (text2.length <= endStep) return text2;
    var folds = [];
    var escapedFolds = {};
    var end = lineWidth - indent.length;
    if (typeof indentAtStart === "number") {
      if (indentAtStart > lineWidth - Math.max(2, minContentWidth)) folds.push(0);
      else end = lineWidth - indentAtStart;
    }
    var split = void 0;
    var prev = void 0;
    var overflow = false;
    var i = -1;
    var escStart = -1;
    var escEnd = -1;
    if (mode === FOLD_BLOCK) {
      i = consumeMoreIndentedLines(text2, i);
      if (i !== -1) end = i + endStep;
    }
    for (var ch; ch = text2[i += 1]; ) {
      if (mode === FOLD_QUOTED && ch === "\\") {
        escStart = i;
        switch (text2[i + 1]) {
          case "x":
            i += 3;
            break;
          case "u":
            i += 5;
            break;
          case "U":
            i += 9;
            break;
          default:
            i += 1;
        }
        escEnd = i;
      }
      if (ch === "\n") {
        if (mode === FOLD_BLOCK) i = consumeMoreIndentedLines(text2, i);
        end = i + endStep;
        split = void 0;
      } else {
        if (ch === " " && prev && prev !== " " && prev !== "\n" && prev !== "	") {
          var next = text2[i + 1];
          if (next && next !== " " && next !== "\n" && next !== "	") split = i;
        }
        if (i >= end) {
          if (split) {
            folds.push(split);
            end = split + endStep;
            split = void 0;
          } else if (mode === FOLD_QUOTED) {
            while (prev === " " || prev === "	") {
              prev = ch;
              ch = text2[i += 1];
              overflow = true;
            }
            var j2 = i > escEnd + 1 ? i - 2 : escStart - 1;
            if (escapedFolds[j2]) return text2;
            folds.push(j2);
            escapedFolds[j2] = true;
            end = j2 + endStep;
            split = void 0;
          } else {
            overflow = true;
          }
        }
      }
      prev = ch;
    }
    if (overflow && onOverflow) onOverflow();
    if (folds.length === 0) return text2;
    if (onFold) onFold();
    var res = text2.slice(0, folds[0]);
    for (var _i = 0; _i < folds.length; ++_i) {
      var fold = folds[_i];
      var _end = folds[_i + 1] || text2.length;
      if (fold === 0) res = "\n".concat(indent).concat(text2.slice(0, _end));
      else {
        if (mode === FOLD_QUOTED && escapedFolds[fold]) res += "".concat(text2[fold], "\\");
        res += "\n".concat(indent).concat(text2.slice(fold + 1, _end));
      }
    }
    return res;
  }
  var getFoldOptions = function getFoldOptions2(_ref) {
    var indentAtStart = _ref.indentAtStart;
    return indentAtStart ? Object.assign({
      indentAtStart
    }, strOptions.fold) : strOptions.fold;
  };
  var containsDocumentMarker = function containsDocumentMarker2(str) {
    return /^(%|---|\.\.\.)/m.test(str);
  };
  function lineLengthOverLimit(str, lineWidth, indentLength) {
    if (!lineWidth || lineWidth < 0) return false;
    var limit = lineWidth - indentLength;
    var strLen = str.length;
    if (strLen <= limit) return false;
    for (var i = 0, start = 0; i < strLen; ++i) {
      if (str[i] === "\n") {
        if (i - start > limit) return true;
        start = i + 1;
        if (strLen - start <= limit) return false;
      }
    }
    return true;
  }
  function doubleQuotedString(value, ctx) {
    var implicitKey = ctx.implicitKey;
    var _strOptions$doubleQuo = strOptions.doubleQuoted, jsonEncoding = _strOptions$doubleQuo.jsonEncoding, minMultiLineLength = _strOptions$doubleQuo.minMultiLineLength;
    var json2 = JSON.stringify(value);
    if (jsonEncoding) return json2;
    var indent = ctx.indent || (containsDocumentMarker(value) ? "  " : "");
    var str = "";
    var start = 0;
    for (var i = 0, ch = json2[i]; ch; ch = json2[++i]) {
      if (ch === " " && json2[i + 1] === "\\" && json2[i + 2] === "n") {
        str += json2.slice(start, i) + "\\ ";
        i += 1;
        start = i;
        ch = "\\";
      }
      if (ch === "\\") switch (json2[i + 1]) {
        case "u":
          {
            str += json2.slice(start, i);
            var code2 = json2.substr(i + 2, 4);
            switch (code2) {
              case "0000":
                str += "\\0";
                break;
              case "0007":
                str += "\\a";
                break;
              case "000b":
                str += "\\v";
                break;
              case "001b":
                str += "\\e";
                break;
              case "0085":
                str += "\\N";
                break;
              case "00a0":
                str += "\\_";
                break;
              case "2028":
                str += "\\L";
                break;
              case "2029":
                str += "\\P";
                break;
              default:
                if (code2.substr(0, 2) === "00") str += "\\x" + code2.substr(2);
                else str += json2.substr(i, 6);
            }
            i += 5;
            start = i + 1;
          }
          break;
        case "n":
          if (implicitKey || json2[i + 2] === '"' || json2.length < minMultiLineLength) {
            i += 1;
          } else {
            str += json2.slice(start, i) + "\n\n";
            while (json2[i + 2] === "\\" && json2[i + 3] === "n" && json2[i + 4] !== '"') {
              str += "\n";
              i += 2;
            }
            str += indent;
            if (json2[i + 2] === " ") str += "\\";
            i += 1;
            start = i + 1;
          }
          break;
        default:
          i += 1;
      }
    }
    str = start ? str + json2.slice(start) : json2;
    return implicitKey ? str : foldFlowLines(str, indent, FOLD_QUOTED, getFoldOptions(ctx));
  }
  function singleQuotedString(value, ctx) {
    if (ctx.implicitKey) {
      if (/\n/.test(value)) return doubleQuotedString(value, ctx);
    } else {
      if (/[ \t]\n|\n[ \t]/.test(value)) return doubleQuotedString(value, ctx);
    }
    var indent = ctx.indent || (containsDocumentMarker(value) ? "  " : "");
    var res = "'" + value.replace(/'/g, "''").replace(/\n+/g, "$&\n".concat(indent)) + "'";
    return ctx.implicitKey ? res : foldFlowLines(res, indent, FOLD_FLOW, getFoldOptions(ctx));
  }
  function blockString(_ref2, ctx, onComment, onChompKeep) {
    var comment = _ref2.comment, type = _ref2.type, value = _ref2.value;
    if (/\n[\t ]+$/.test(value) || /^\s*$/.test(value)) {
      return doubleQuotedString(value, ctx);
    }
    var indent = ctx.indent || (ctx.forceBlockIndent || containsDocumentMarker(value) ? "  " : "");
    var indentSize = indent ? "2" : "1";
    var literal = type === Type.BLOCK_FOLDED ? false : type === Type.BLOCK_LITERAL ? true : !lineLengthOverLimit(value, strOptions.fold.lineWidth, indent.length);
    var header = literal ? "|" : ">";
    if (!value) return header + "\n";
    var wsStart = "";
    var wsEnd = "";
    value = value.replace(/[\n\t ]*$/, function(ws) {
      var n = ws.indexOf("\n");
      if (n === -1) {
        header += "-";
      } else if (value === ws || n !== ws.length - 1) {
        header += "+";
        if (onChompKeep) onChompKeep();
      }
      wsEnd = ws.replace(/\n$/, "");
      return "";
    }).replace(/^[\n ]*/, function(ws) {
      if (ws.indexOf(" ") !== -1) header += indentSize;
      var m2 = ws.match(/ +$/);
      if (m2) {
        wsStart = ws.slice(0, -m2[0].length);
        return m2[0];
      } else {
        wsStart = ws;
        return "";
      }
    });
    if (wsEnd) wsEnd = wsEnd.replace(/\n+(?!\n|$)/g, "$&".concat(indent));
    if (wsStart) wsStart = wsStart.replace(/\n+/g, "$&".concat(indent));
    if (comment) {
      header += " #" + comment.replace(/ ?[\r\n]+/g, " ");
      if (onComment) onComment();
    }
    if (!value) return "".concat(header).concat(indentSize, "\n").concat(indent).concat(wsEnd);
    if (literal) {
      value = value.replace(/\n+/g, "$&".concat(indent));
      return "".concat(header, "\n").concat(indent).concat(wsStart).concat(value).concat(wsEnd);
    }
    value = value.replace(/\n+/g, "\n$&").replace(/(?:^|\n)([\t ].*)(?:([\n\t ]*)\n(?![\n\t ]))?/g, "$1$2").replace(/\n+/g, "$&".concat(indent));
    var body = foldFlowLines("".concat(wsStart).concat(value).concat(wsEnd), indent, FOLD_BLOCK, strOptions.fold);
    return "".concat(header, "\n").concat(indent).concat(body);
  }
  function plainString(item, ctx, onComment, onChompKeep) {
    var comment = item.comment, type = item.type, value = item.value;
    var actualString = ctx.actualString, implicitKey = ctx.implicitKey, indent = ctx.indent, inFlow = ctx.inFlow;
    if (implicitKey && /[\n[\]{},]/.test(value) || inFlow && /[[\]{},]/.test(value)) {
      return doubleQuotedString(value, ctx);
    }
    if (!value || /^[\n\t ,[\]{}#&*!|>'"%@`]|^[?-]$|^[?-][ \t]|[\n:][ \t]|[ \t]\n|[\n\t ]#|[\n\t :]$/.test(value)) {
      return implicitKey || inFlow || value.indexOf("\n") === -1 ? value.indexOf('"') !== -1 && value.indexOf("'") === -1 ? singleQuotedString(value, ctx) : doubleQuotedString(value, ctx) : blockString(item, ctx, onComment, onChompKeep);
    }
    if (!implicitKey && !inFlow && type !== Type.PLAIN && value.indexOf("\n") !== -1) {
      return blockString(item, ctx, onComment, onChompKeep);
    }
    if (indent === "" && containsDocumentMarker(value)) {
      ctx.forceBlockIndent = true;
      return blockString(item, ctx, onComment, onChompKeep);
    }
    var str = value.replace(/\n+/g, "$&\n".concat(indent));
    if (actualString) {
      var tags2 = ctx.doc.schema.tags;
      var resolved = resolveScalar(str, tags2, tags2.scalarFallback).value;
      if (typeof resolved !== "string") return doubleQuotedString(value, ctx);
    }
    var body = implicitKey ? str : foldFlowLines(str, indent, FOLD_FLOW, getFoldOptions(ctx));
    if (comment && !inFlow && (body.indexOf("\n") !== -1 || comment.indexOf("\n") !== -1)) {
      if (onComment) onComment();
      return addCommentBefore(body, indent, comment);
    }
    return body;
  }
  function stringifyString(item, ctx, onComment, onChompKeep) {
    var defaultType = strOptions.defaultType;
    var implicitKey = ctx.implicitKey, inFlow = ctx.inFlow;
    var _item = item, type = _item.type, value = _item.value;
    if (typeof value !== "string") {
      value = String(value);
      item = Object.assign({}, item, {
        value
      });
    }
    var _stringify = function _stringify2(_type) {
      switch (_type) {
        case Type.BLOCK_FOLDED:
        case Type.BLOCK_LITERAL:
          return blockString(item, ctx, onComment, onChompKeep);
        case Type.QUOTE_DOUBLE:
          return doubleQuotedString(value, ctx);
        case Type.QUOTE_SINGLE:
          return singleQuotedString(value, ctx);
        case Type.PLAIN:
          return plainString(item, ctx, onComment, onChompKeep);
        default:
          return null;
      }
    };
    if (type !== Type.QUOTE_DOUBLE && /[\x00-\x08\x0b-\x1f\x7f-\x9f]/.test(value)) {
      type = Type.QUOTE_DOUBLE;
    } else if ((implicitKey || inFlow) && (type === Type.BLOCK_FOLDED || type === Type.BLOCK_LITERAL)) {
      type = Type.QUOTE_DOUBLE;
    }
    var res = _stringify(type);
    if (res === null) {
      res = _stringify(defaultType);
      if (res === null) throw new Error("Unsupported default string type ".concat(defaultType));
    }
    return res;
  }
  function stringifyNumber(_ref) {
    var format2 = _ref.format, minFractionDigits = _ref.minFractionDigits, tag = _ref.tag, value = _ref.value;
    if (typeof value === "bigint") return String(value);
    if (!isFinite(value)) return isNaN(value) ? ".nan" : value < 0 ? "-.inf" : ".inf";
    var n = JSON.stringify(value);
    if (!format2 && minFractionDigits && (!tag || tag === "tag:yaml.org,2002:float") && /^\d/.test(n)) {
      var i = n.indexOf(".");
      if (i < 0) {
        i = n.length;
        n += ".";
      }
      var d2 = minFractionDigits - (n.length - i - 1);
      while (d2-- > 0) {
        n += "0";
      }
    }
    return n;
  }
  function checkFlowCollectionEnd(errors, cst) {
    var char, name;
    switch (cst.type) {
      case Type.FLOW_MAP:
        char = "}";
        name = "flow map";
        break;
      case Type.FLOW_SEQ:
        char = "]";
        name = "flow sequence";
        break;
      default:
        errors.push(new YAMLSemanticError(cst, "Not a flow collection!?"));
        return;
    }
    var lastItem;
    for (var i = cst.items.length - 1; i >= 0; --i) {
      var item = cst.items[i];
      if (!item || item.type !== Type.COMMENT) {
        lastItem = item;
        break;
      }
    }
    if (lastItem && lastItem.char !== char) {
      var msg = "Expected ".concat(name, " to end with ").concat(char);
      var err;
      if (typeof lastItem.offset === "number") {
        err = new YAMLSemanticError(cst, msg);
        err.offset = lastItem.offset + 1;
      } else {
        err = new YAMLSemanticError(lastItem, msg);
        if (lastItem.range && lastItem.range.end) err.offset = lastItem.range.end - lastItem.range.start;
      }
      errors.push(err);
    }
  }
  function checkFlowCommentSpace(errors, comment) {
    var prev = comment.context.src[comment.range.start - 1];
    if (prev !== "\n" && prev !== "	" && prev !== " ") {
      var msg = "Comments must be separated from other tokens by white space characters";
      errors.push(new YAMLSemanticError(comment, msg));
    }
  }
  function getLongKeyError(source, key) {
    var sk = String(key);
    var k2 = sk.substr(0, 8) + "..." + sk.substr(-8);
    return new YAMLSemanticError(source, 'The "'.concat(k2, '" key is too long'));
  }
  function resolveComments(collection, comments) {
    var _iterator = _createForOfIteratorHelper(comments), _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done; ) {
        var _step$value = _step.value, afterKey = _step$value.afterKey, before = _step$value.before, comment = _step$value.comment;
        var item = collection.items[before];
        if (!item) {
          if (comment !== void 0) {
            if (collection.comment) collection.comment += "\n" + comment;
            else collection.comment = comment;
          }
        } else {
          if (afterKey && item.value) item = item.value;
          if (comment === void 0) {
            if (afterKey || !item.commentBefore) item.spaceBefore = true;
          } else {
            if (item.commentBefore) item.commentBefore += "\n" + comment;
            else item.commentBefore = comment;
          }
        }
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
  }
  function resolveString(doc, node) {
    var res = node.strValue;
    if (!res) return "";
    if (typeof res === "string") return res;
    res.errors.forEach(function(error) {
      if (!error.source) error.source = node;
      doc.errors.push(error);
    });
    return res.str;
  }
  function resolveTagHandle(doc, node) {
    var _node$tag = node.tag, handle = _node$tag.handle, suffix = _node$tag.suffix;
    var prefix = doc.tagPrefixes.find(function(p2) {
      return p2.handle === handle;
    });
    if (!prefix) {
      var dtp = doc.getDefaults().tagPrefixes;
      if (dtp) prefix = dtp.find(function(p2) {
        return p2.handle === handle;
      });
      if (!prefix) throw new YAMLSemanticError(node, "The ".concat(handle, " tag handle is non-default and was not declared."));
    }
    if (!suffix) throw new YAMLSemanticError(node, "The ".concat(handle, " tag has no suffix."));
    if (handle === "!" && (doc.version || doc.options.version) === "1.0") {
      if (suffix[0] === "^") {
        doc.warnings.push(new YAMLWarning(node, "YAML 1.0 ^ tag expansion is not supported"));
        return suffix;
      }
      if (/[:/]/.test(suffix)) {
        var vocab = suffix.match(/^([a-z0-9-]+)\/(.*)/i);
        return vocab ? "tag:".concat(vocab[1], ".yaml.org,2002:").concat(vocab[2]) : "tag:".concat(suffix);
      }
    }
    return prefix.prefix + decodeURIComponent(suffix);
  }
  function resolveTagName(doc, node) {
    var tag = node.tag, type = node.type;
    var nonSpecific = false;
    if (tag) {
      var handle = tag.handle, suffix = tag.suffix, verbatim = tag.verbatim;
      if (verbatim) {
        if (verbatim !== "!" && verbatim !== "!!") return verbatim;
        var msg = "Verbatim tags aren't resolved, so ".concat(verbatim, " is invalid.");
        doc.errors.push(new YAMLSemanticError(node, msg));
      } else if (handle === "!" && !suffix) {
        nonSpecific = true;
      } else {
        try {
          return resolveTagHandle(doc, node);
        } catch (error) {
          doc.errors.push(error);
        }
      }
    }
    switch (type) {
      case Type.BLOCK_FOLDED:
      case Type.BLOCK_LITERAL:
      case Type.QUOTE_DOUBLE:
      case Type.QUOTE_SINGLE:
        return defaultTags.STR;
      case Type.FLOW_MAP:
      case Type.MAP:
        return defaultTags.MAP;
      case Type.FLOW_SEQ:
      case Type.SEQ:
        return defaultTags.SEQ;
      case Type.PLAIN:
        return nonSpecific ? defaultTags.STR : null;
      default:
        return null;
    }
  }
  function resolveByTagName(doc, node, tagName) {
    var tags2 = doc.schema.tags;
    var matchWithTest = [];
    var _iterator = _createForOfIteratorHelper(tags2), _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done; ) {
        var tag = _step.value;
        if (tag.tag === tagName) {
          if (tag.test) matchWithTest.push(tag);
          else {
            var res = tag.resolve(doc, node);
            return res instanceof Collection ? res : new Scalar(res);
          }
        }
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
    var str = resolveString(doc, node);
    if (typeof str === "string" && matchWithTest.length > 0) return resolveScalar(str, matchWithTest, tags2.scalarFallback);
    return null;
  }
  function getFallbackTagName(_ref) {
    var type = _ref.type;
    switch (type) {
      case Type.FLOW_MAP:
      case Type.MAP:
        return defaultTags.MAP;
      case Type.FLOW_SEQ:
      case Type.SEQ:
        return defaultTags.SEQ;
      default:
        return defaultTags.STR;
    }
  }
  function resolveTag(doc, node, tagName) {
    try {
      var res = resolveByTagName(doc, node, tagName);
      if (res) {
        if (tagName && node.tag) res.tag = tagName;
        return res;
      }
    } catch (error) {
      if (!error.source) error.source = node;
      doc.errors.push(error);
      return null;
    }
    try {
      var fallback = getFallbackTagName(node);
      if (!fallback) throw new Error("The tag ".concat(tagName, " is unavailable"));
      var msg = "The tag ".concat(tagName, " is unavailable, falling back to ").concat(fallback);
      doc.warnings.push(new YAMLWarning(node, msg));
      var _res = resolveByTagName(doc, node, fallback);
      _res.tag = tagName;
      return _res;
    } catch (error) {
      var refError = new YAMLReferenceError(node, error.message);
      refError.stack = error.stack;
      doc.errors.push(refError);
      return null;
    }
  }
  var isCollectionItem = function isCollectionItem2(node) {
    if (!node) return false;
    var type = node.type;
    return type === Type.MAP_KEY || type === Type.MAP_VALUE || type === Type.SEQ_ITEM;
  };
  function resolveNodeProps(errors, node) {
    var comments = {
      before: [],
      after: []
    };
    var hasAnchor = false;
    var hasTag = false;
    var props = isCollectionItem(node.context.parent) ? node.context.parent.props.concat(node.props) : node.props;
    var _iterator = _createForOfIteratorHelper(props), _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done; ) {
        var _step$value = _step.value, start = _step$value.start, end = _step$value.end;
        switch (node.context.src[start]) {
          case Char.COMMENT: {
            if (!node.commentHasRequiredWhitespace(start)) {
              var msg = "Comments must be separated from other tokens by white space characters";
              errors.push(new YAMLSemanticError(node, msg));
            }
            var header = node.header, valueRange = node.valueRange;
            var cc = valueRange && (start > valueRange.start || header && start > header.start) ? comments.after : comments.before;
            cc.push(node.context.src.slice(start + 1, end));
            break;
          }
          case Char.ANCHOR:
            if (hasAnchor) {
              var _msg = "A node can have at most one anchor";
              errors.push(new YAMLSemanticError(node, _msg));
            }
            hasAnchor = true;
            break;
          case Char.TAG:
            if (hasTag) {
              var _msg2 = "A node can have at most one tag";
              errors.push(new YAMLSemanticError(node, _msg2));
            }
            hasTag = true;
            break;
        }
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
    return {
      comments,
      hasAnchor,
      hasTag
    };
  }
  function resolveNodeValue(doc, node) {
    var anchors = doc.anchors, errors = doc.errors, schema = doc.schema;
    if (node.type === Type.ALIAS) {
      var name = node.rawValue;
      var src = anchors.getNode(name);
      if (!src) {
        var msg = "Aliased anchor not found: ".concat(name);
        errors.push(new YAMLReferenceError(node, msg));
        return null;
      }
      var res = new Alias(src);
      anchors._cstAliases.push(res);
      return res;
    }
    var tagName = resolveTagName(doc, node);
    if (tagName) return resolveTag(doc, node, tagName);
    if (node.type !== Type.PLAIN) {
      var _msg3 = "Failed to resolve ".concat(node.type, " node here");
      errors.push(new YAMLSyntaxError(node, _msg3));
      return null;
    }
    try {
      var str = resolveString(doc, node);
      return resolveScalar(str, schema.tags, schema.tags.scalarFallback);
    } catch (error) {
      if (!error.source) error.source = node;
      errors.push(error);
      return null;
    }
  }
  function resolveNode(doc, node) {
    if (!node) return null;
    if (node.error) doc.errors.push(node.error);
    var _resolveNodeProps = resolveNodeProps(doc.errors, node), comments = _resolveNodeProps.comments, hasAnchor = _resolveNodeProps.hasAnchor, hasTag = _resolveNodeProps.hasTag;
    if (hasAnchor) {
      var anchors = doc.anchors;
      var name = node.anchor;
      var prev = anchors.getNode(name);
      if (prev) anchors.map[anchors.newName(name)] = prev;
      anchors.map[name] = node;
    }
    if (node.type === Type.ALIAS && (hasAnchor || hasTag)) {
      var msg = "An alias node must not specify any properties";
      doc.errors.push(new YAMLSemanticError(node, msg));
    }
    var res = resolveNodeValue(doc, node);
    if (res) {
      res.range = [node.range.start, node.range.end];
      if (doc.options.keepCstNodes) res.cstNode = node;
      if (doc.options.keepNodeTypes) res.type = node.type;
      var cb = comments.before.join("\n");
      if (cb) {
        res.commentBefore = res.commentBefore ? "".concat(res.commentBefore, "\n").concat(cb) : cb;
      }
      var ca = comments.after.join("\n");
      if (ca) res.comment = res.comment ? "".concat(res.comment, "\n").concat(ca) : ca;
    }
    return node.resolved = res;
  }
  function resolveMap(doc, cst) {
    if (cst.type !== Type.MAP && cst.type !== Type.FLOW_MAP) {
      var msg = "A ".concat(cst.type, " node cannot be resolved as a mapping");
      doc.errors.push(new YAMLSyntaxError(cst, msg));
      return null;
    }
    var _ref = cst.type === Type.FLOW_MAP ? resolveFlowMapItems(doc, cst) : resolveBlockMapItems(doc, cst), comments = _ref.comments, items = _ref.items;
    var map2 = new YAMLMap();
    map2.items = items;
    resolveComments(map2, comments);
    var hasCollectionKey = false;
    for (var i = 0; i < items.length; ++i) {
      var iKey = items[i].key;
      if (iKey instanceof Collection) hasCollectionKey = true;
      if (doc.schema.merge && iKey && iKey.value === MERGE_KEY) {
        items[i] = new Merge(items[i]);
        var sources = items[i].value.items;
        var error = null;
        sources.some(function(node) {
          if (node instanceof Alias) {
            var type = node.source.type;
            if (type === Type.MAP || type === Type.FLOW_MAP) return false;
            return error = "Merge nodes aliases can only point to maps";
          }
          return error = "Merge nodes can only have Alias nodes as values";
        });
        if (error) doc.errors.push(new YAMLSemanticError(cst, error));
      } else {
        for (var j2 = i + 1; j2 < items.length; ++j2) {
          var jKey = items[j2].key;
          if (iKey === jKey || iKey && jKey && Object.prototype.hasOwnProperty.call(iKey, "value") && iKey.value === jKey.value) {
            var _msg = 'Map keys must be unique; "'.concat(iKey, '" is repeated');
            doc.errors.push(new YAMLSemanticError(cst, _msg));
            break;
          }
        }
      }
    }
    if (hasCollectionKey && !doc.options.mapAsMap) {
      var warn2 = "Keys with collection values will be stringified as YAML due to JS Object restrictions. Use mapAsMap: true to avoid this.";
      doc.warnings.push(new YAMLWarning(cst, warn2));
    }
    cst.resolved = map2;
    return map2;
  }
  var valueHasPairComment = function valueHasPairComment2(_ref2) {
    var _ref2$context = _ref2.context, lineStart = _ref2$context.lineStart, node = _ref2$context.node, src = _ref2$context.src, props = _ref2.props;
    if (props.length === 0) return false;
    var start = props[0].start;
    if (node && start > node.valueRange.start) return false;
    if (src[start] !== Char.COMMENT) return false;
    for (var i = lineStart; i < start; ++i) {
      if (src[i] === "\n") return false;
    }
    return true;
  };
  function resolvePairComment(item, pair) {
    if (!valueHasPairComment(item)) return;
    var comment = item.getPropValue(0, Char.COMMENT, true);
    var found = false;
    var cb = pair.value.commentBefore;
    if (cb && cb.startsWith(comment)) {
      pair.value.commentBefore = cb.substr(comment.length + 1);
      found = true;
    } else {
      var cc = pair.value.comment;
      if (!item.node && cc && cc.startsWith(comment)) {
        pair.value.comment = cc.substr(comment.length + 1);
        found = true;
      }
    }
    if (found) pair.comment = comment;
  }
  function resolveBlockMapItems(doc, cst) {
    var comments = [];
    var items = [];
    var key = void 0;
    var keyStart = null;
    for (var i = 0; i < cst.items.length; ++i) {
      var item = cst.items[i];
      switch (item.type) {
        case Type.BLANK_LINE:
          comments.push({
            afterKey: !!key,
            before: items.length
          });
          break;
        case Type.COMMENT:
          comments.push({
            afterKey: !!key,
            before: items.length,
            comment: item.comment
          });
          break;
        case Type.MAP_KEY:
          if (key !== void 0) items.push(new Pair(key));
          if (item.error) doc.errors.push(item.error);
          key = resolveNode(doc, item.node);
          keyStart = null;
          break;
        case Type.MAP_VALUE:
          {
            if (key === void 0) key = null;
            if (item.error) doc.errors.push(item.error);
            if (!item.context.atLineStart && item.node && item.node.type === Type.MAP && !item.node.context.atLineStart) {
              var msg = "Nested mappings are not allowed in compact mappings";
              doc.errors.push(new YAMLSemanticError(item.node, msg));
            }
            var valueNode = item.node;
            if (!valueNode && item.props.length > 0) {
              valueNode = new PlainValue(Type.PLAIN, []);
              valueNode.context = {
                parent: item,
                src: item.context.src
              };
              var pos = item.range.start + 1;
              valueNode.range = {
                start: pos,
                end: pos
              };
              valueNode.valueRange = {
                start: pos,
                end: pos
              };
              if (typeof item.range.origStart === "number") {
                var origPos = item.range.origStart + 1;
                valueNode.range.origStart = valueNode.range.origEnd = origPos;
                valueNode.valueRange.origStart = valueNode.valueRange.origEnd = origPos;
              }
            }
            var pair = new Pair(key, resolveNode(doc, valueNode));
            resolvePairComment(item, pair);
            items.push(pair);
            if (key && typeof keyStart === "number") {
              if (item.range.start > keyStart + 1024) doc.errors.push(getLongKeyError(cst, key));
            }
            key = void 0;
            keyStart = null;
          }
          break;
        default:
          if (key !== void 0) items.push(new Pair(key));
          key = resolveNode(doc, item);
          keyStart = item.range.start;
          if (item.error) doc.errors.push(item.error);
          next: for (var j2 = i + 1; ; ++j2) {
            var nextItem = cst.items[j2];
            switch (nextItem && nextItem.type) {
              case Type.BLANK_LINE:
              case Type.COMMENT:
                continue next;
              case Type.MAP_VALUE:
                break next;
              default: {
                var _msg2 = "Implicit map keys need to be followed by map values";
                doc.errors.push(new YAMLSemanticError(item, _msg2));
                break next;
              }
            }
          }
          if (item.valueRangeContainsNewline) {
            var _msg3 = "Implicit map keys need to be on a single line";
            doc.errors.push(new YAMLSemanticError(item, _msg3));
          }
      }
    }
    if (key !== void 0) items.push(new Pair(key));
    return {
      comments,
      items
    };
  }
  function resolveFlowMapItems(doc, cst) {
    var comments = [];
    var items = [];
    var key = void 0;
    var explicitKey = false;
    var next = "{";
    for (var i = 0; i < cst.items.length; ++i) {
      var item = cst.items[i];
      if (typeof item.char === "string") {
        var char = item.char, offset = item.offset;
        if (char === "?" && key === void 0 && !explicitKey) {
          explicitKey = true;
          next = ":";
          continue;
        }
        if (char === ":") {
          if (key === void 0) key = null;
          if (next === ":") {
            next = ",";
            continue;
          }
        } else {
          if (explicitKey) {
            if (key === void 0 && char !== ",") key = null;
            explicitKey = false;
          }
          if (key !== void 0) {
            items.push(new Pair(key));
            key = void 0;
            if (char === ",") {
              next = ":";
              continue;
            }
          }
        }
        if (char === "}") {
          if (i === cst.items.length - 1) continue;
        } else if (char === next) {
          next = ":";
          continue;
        }
        var msg = "Flow map contains an unexpected ".concat(char);
        var err = new YAMLSyntaxError(cst, msg);
        err.offset = offset;
        doc.errors.push(err);
      } else if (item.type === Type.BLANK_LINE) {
        comments.push({
          afterKey: !!key,
          before: items.length
        });
      } else if (item.type === Type.COMMENT) {
        checkFlowCommentSpace(doc.errors, item);
        comments.push({
          afterKey: !!key,
          before: items.length,
          comment: item.comment
        });
      } else if (key === void 0) {
        if (next === ",") doc.errors.push(new YAMLSemanticError(item, "Separator , missing in flow map"));
        key = resolveNode(doc, item);
      } else {
        if (next !== ",") doc.errors.push(new YAMLSemanticError(item, "Indicator : missing in flow map entry"));
        items.push(new Pair(key, resolveNode(doc, item)));
        key = void 0;
        explicitKey = false;
      }
    }
    checkFlowCollectionEnd(doc.errors, cst);
    if (key !== void 0) items.push(new Pair(key));
    return {
      comments,
      items
    };
  }
  function resolveSeq(doc, cst) {
    if (cst.type !== Type.SEQ && cst.type !== Type.FLOW_SEQ) {
      var msg = "A ".concat(cst.type, " node cannot be resolved as a sequence");
      doc.errors.push(new YAMLSyntaxError(cst, msg));
      return null;
    }
    var _ref = cst.type === Type.FLOW_SEQ ? resolveFlowSeqItems(doc, cst) : resolveBlockSeqItems(doc, cst), comments = _ref.comments, items = _ref.items;
    var seq2 = new YAMLSeq();
    seq2.items = items;
    resolveComments(seq2, comments);
    if (!doc.options.mapAsMap && items.some(function(it) {
      return it instanceof Pair && it.key instanceof Collection;
    })) {
      var warn2 = "Keys with collection values will be stringified as YAML due to JS Object restrictions. Use mapAsMap: true to avoid this.";
      doc.warnings.push(new YAMLWarning(cst, warn2));
    }
    cst.resolved = seq2;
    return seq2;
  }
  function resolveBlockSeqItems(doc, cst) {
    var comments = [];
    var items = [];
    for (var i = 0; i < cst.items.length; ++i) {
      var item = cst.items[i];
      switch (item.type) {
        case Type.BLANK_LINE:
          comments.push({
            before: items.length
          });
          break;
        case Type.COMMENT:
          comments.push({
            comment: item.comment,
            before: items.length
          });
          break;
        case Type.SEQ_ITEM:
          if (item.error) doc.errors.push(item.error);
          items.push(resolveNode(doc, item.node));
          if (item.hasProps) {
            var msg = "Sequence items cannot have tags or anchors before the - indicator";
            doc.errors.push(new YAMLSemanticError(item, msg));
          }
          break;
        default:
          if (item.error) doc.errors.push(item.error);
          doc.errors.push(new YAMLSyntaxError(item, "Unexpected ".concat(item.type, " node in sequence")));
      }
    }
    return {
      comments,
      items
    };
  }
  function resolveFlowSeqItems(doc, cst) {
    var comments = [];
    var items = [];
    var explicitKey = false;
    var key = void 0;
    var keyStart = null;
    var next = "[";
    var prevItem = null;
    for (var i = 0; i < cst.items.length; ++i) {
      var item = cst.items[i];
      if (typeof item.char === "string") {
        var char = item.char, offset = item.offset;
        if (char !== ":" && (explicitKey || key !== void 0)) {
          if (explicitKey && key === void 0) key = next ? items.pop() : null;
          items.push(new Pair(key));
          explicitKey = false;
          key = void 0;
          keyStart = null;
        }
        if (char === next) {
          next = null;
        } else if (!next && char === "?") {
          explicitKey = true;
        } else if (next !== "[" && char === ":" && key === void 0) {
          if (next === ",") {
            key = items.pop();
            if (key instanceof Pair) {
              var msg = "Chaining flow sequence pairs is invalid";
              var err = new YAMLSemanticError(cst, msg);
              err.offset = offset;
              doc.errors.push(err);
            }
            if (!explicitKey && typeof keyStart === "number") {
              var keyEnd = item.range ? item.range.start : item.offset;
              if (keyEnd > keyStart + 1024) doc.errors.push(getLongKeyError(cst, key));
              var src = prevItem.context.src;
              for (var _i = keyStart; _i < keyEnd; ++_i) {
                if (src[_i] === "\n") {
                  var _msg = "Implicit keys of flow sequence pairs need to be on a single line";
                  doc.errors.push(new YAMLSemanticError(prevItem, _msg));
                  break;
                }
              }
            }
          } else {
            key = null;
          }
          keyStart = null;
          explicitKey = false;
          next = null;
        } else if (next === "[" || char !== "]" || i < cst.items.length - 1) {
          var _msg2 = "Flow sequence contains an unexpected ".concat(char);
          var _err = new YAMLSyntaxError(cst, _msg2);
          _err.offset = offset;
          doc.errors.push(_err);
        }
      } else if (item.type === Type.BLANK_LINE) {
        comments.push({
          before: items.length
        });
      } else if (item.type === Type.COMMENT) {
        checkFlowCommentSpace(doc.errors, item);
        comments.push({
          comment: item.comment,
          before: items.length
        });
      } else {
        if (next) {
          var _msg3 = "Expected a ".concat(next, " in flow sequence");
          doc.errors.push(new YAMLSemanticError(item, _msg3));
        }
        var value = resolveNode(doc, item);
        if (key === void 0) {
          items.push(value);
          prevItem = item;
        } else {
          items.push(new Pair(key, value));
          key = void 0;
        }
        keyStart = item.range.start;
        next = ",";
      }
    }
    checkFlowCollectionEnd(doc.errors, cst);
    if (key !== void 0) items.push(new Pair(key));
    return {
      comments,
      items
    };
  }
  var define_process_env_default = {};
  var binary = {
    identify: function identify(value) {
      return value instanceof Uint8Array;
    },
    // Buffer inherits from Uint8Array
    default: false,
    tag: "tag:yaml.org,2002:binary",
    /**
     * Returns a Buffer in node and an Uint8Array in browsers
     *
     * To use the resulting buffer as an image, you'll want to do something like:
     *
     *   const blob = new Blob([buffer], { type: 'image/jpeg' })
     *   document.querySelector('#photo').src = URL.createObjectURL(blob)
     */
    resolve: function resolve(doc, node) {
      var src = resolveString(doc, node);
      if (typeof Buffer === "function") {
        return Buffer.from(src, "base64");
      } else if (typeof atob === "function") {
        var str = atob(src.replace(/[\n\r]/g, ""));
        var buffer2 = new Uint8Array(str.length);
        for (var i = 0; i < str.length; ++i) {
          buffer2[i] = str.charCodeAt(i);
        }
        return buffer2;
      } else {
        var msg = "This environment does not support reading binary tags; either Buffer or atob is required";
        doc.errors.push(new YAMLReferenceError(node, msg));
        return null;
      }
    },
    options: binaryOptions,
    stringify: function stringify(_ref, ctx, onComment, onChompKeep) {
      var comment = _ref.comment, type = _ref.type, value = _ref.value;
      var src;
      if (typeof Buffer === "function") {
        src = value instanceof Buffer ? value.toString("base64") : Buffer.from(value.buffer).toString("base64");
      } else if (typeof btoa === "function") {
        var s2 = "";
        for (var i = 0; i < value.length; ++i) {
          s2 += String.fromCharCode(value[i]);
        }
        src = btoa(s2);
      } else {
        throw new Error("This environment does not support writing binary tags; either Buffer or btoa is required");
      }
      if (!type) type = binaryOptions.defaultType;
      if (type === Type.QUOTE_DOUBLE) {
        value = src;
      } else {
        var lineWidth = binaryOptions.lineWidth;
        var n = Math.ceil(src.length / lineWidth);
        var lines = new Array(n);
        for (var _i = 0, o2 = 0; _i < n; ++_i, o2 += lineWidth) {
          lines[_i] = src.substr(o2, lineWidth);
        }
        value = lines.join(type === Type.BLOCK_LITERAL ? "\n" : " ");
      }
      return stringifyString({
        comment,
        type,
        value
      }, ctx, onComment, onChompKeep);
    }
  };
  function parsePairs(doc, cst) {
    var seq2 = resolveSeq(doc, cst);
    for (var i = 0; i < seq2.items.length; ++i) {
      var item = seq2.items[i];
      if (item instanceof Pair) continue;
      else if (item instanceof YAMLMap) {
        if (item.items.length > 1) {
          var msg = "Each pair must have its own sequence indicator";
          throw new YAMLSemanticError(cst, msg);
        }
        var pair = item.items[0] || new Pair();
        if (item.commentBefore) pair.commentBefore = pair.commentBefore ? "".concat(item.commentBefore, "\n").concat(pair.commentBefore) : item.commentBefore;
        if (item.comment) pair.comment = pair.comment ? "".concat(item.comment, "\n").concat(pair.comment) : item.comment;
        item = pair;
      }
      seq2.items[i] = item instanceof Pair ? item : new Pair(item);
    }
    return seq2;
  }
  function createPairs(schema, iterable, ctx) {
    var pairs2 = new YAMLSeq(schema);
    pairs2.tag = "tag:yaml.org,2002:pairs";
    var _iterator = _createForOfIteratorHelper(iterable), _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done; ) {
        var it = _step.value;
        var key = void 0, value = void 0;
        if (Array.isArray(it)) {
          if (it.length === 2) {
            key = it[0];
            value = it[1];
          } else throw new TypeError("Expected [key, value] tuple: ".concat(it));
        } else if (it && it instanceof Object) {
          var keys = Object.keys(it);
          if (keys.length === 1) {
            key = keys[0];
            value = it[key];
          } else throw new TypeError("Expected { key: value } tuple: ".concat(it));
        } else {
          key = it;
        }
        var pair = schema.createPair(key, value, ctx);
        pairs2.items.push(pair);
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
    return pairs2;
  }
  var pairs = {
    default: false,
    tag: "tag:yaml.org,2002:pairs",
    resolve: parsePairs,
    createNode: createPairs
  };
  var YAMLOMap = /* @__PURE__ */ function(_YAMLSeq) {
    _inherits(YAMLOMap2, _YAMLSeq);
    var _super = _createSuper(YAMLOMap2);
    function YAMLOMap2() {
      var _this;
      _classCallCheck(this, YAMLOMap2);
      _this = _super.call(this);
      _defineProperty(_assertThisInitialized(_this), "add", YAMLMap.prototype.add.bind(_assertThisInitialized(_this)));
      _defineProperty(_assertThisInitialized(_this), "delete", YAMLMap.prototype.delete.bind(_assertThisInitialized(_this)));
      _defineProperty(_assertThisInitialized(_this), "get", YAMLMap.prototype.get.bind(_assertThisInitialized(_this)));
      _defineProperty(_assertThisInitialized(_this), "has", YAMLMap.prototype.has.bind(_assertThisInitialized(_this)));
      _defineProperty(_assertThisInitialized(_this), "set", YAMLMap.prototype.set.bind(_assertThisInitialized(_this)));
      _this.tag = YAMLOMap2.tag;
      return _this;
    }
    _createClass(YAMLOMap2, [{
      key: "toJSON",
      value: function toJSON$1(_2, ctx) {
        var map2 = /* @__PURE__ */ new Map();
        if (ctx && ctx.onCreate) ctx.onCreate(map2);
        var _iterator = _createForOfIteratorHelper(this.items), _step;
        try {
          for (_iterator.s(); !(_step = _iterator.n()).done; ) {
            var pair = _step.value;
            var key = void 0, value = void 0;
            if (pair instanceof Pair) {
              key = toJSON(pair.key, "", ctx);
              value = toJSON(pair.value, key, ctx);
            } else {
              key = toJSON(pair, "", ctx);
            }
            if (map2.has(key)) throw new Error("Ordered maps must not include duplicate keys");
            map2.set(key, value);
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
        return map2;
      }
    }]);
    return YAMLOMap2;
  }(YAMLSeq);
  _defineProperty(YAMLOMap, "tag", "tag:yaml.org,2002:omap");
  function parseOMap(doc, cst) {
    var pairs2 = parsePairs(doc, cst);
    var seenKeys = [];
    var _iterator2 = _createForOfIteratorHelper(pairs2.items), _step2;
    try {
      for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
        var key = _step2.value.key;
        if (key instanceof Scalar) {
          if (seenKeys.includes(key.value)) {
            var msg = "Ordered maps must not include duplicate keys";
            throw new YAMLSemanticError(cst, msg);
          } else {
            seenKeys.push(key.value);
          }
        }
      }
    } catch (err) {
      _iterator2.e(err);
    } finally {
      _iterator2.f();
    }
    return Object.assign(new YAMLOMap(), pairs2);
  }
  function createOMap(schema, iterable, ctx) {
    var pairs2 = createPairs(schema, iterable, ctx);
    var omap2 = new YAMLOMap();
    omap2.items = pairs2.items;
    return omap2;
  }
  var omap = {
    identify: function identify2(value) {
      return value instanceof Map;
    },
    nodeClass: YAMLOMap,
    default: false,
    tag: "tag:yaml.org,2002:omap",
    resolve: parseOMap,
    createNode: createOMap
  };
  var YAMLSet = /* @__PURE__ */ function(_YAMLMap) {
    _inherits(YAMLSet2, _YAMLMap);
    var _super = _createSuper(YAMLSet2);
    function YAMLSet2() {
      var _this;
      _classCallCheck(this, YAMLSet2);
      _this = _super.call(this);
      _this.tag = YAMLSet2.tag;
      return _this;
    }
    _createClass(YAMLSet2, [{
      key: "add",
      value: function add(key) {
        var pair = key instanceof Pair ? key : new Pair(key);
        var prev = findPair(this.items, pair.key);
        if (!prev) this.items.push(pair);
      }
    }, {
      key: "get",
      value: function get(key, keepPair) {
        var pair = findPair(this.items, key);
        return !keepPair && pair instanceof Pair ? pair.key instanceof Scalar ? pair.key.value : pair.key : pair;
      }
    }, {
      key: "set",
      value: function set2(key, value) {
        if (typeof value !== "boolean") throw new Error("Expected boolean value for set(key, value) in a YAML set, not ".concat(_typeof(value)));
        var prev = findPair(this.items, key);
        if (prev && !value) {
          this.items.splice(this.items.indexOf(prev), 1);
        } else if (!prev && value) {
          this.items.push(new Pair(key));
        }
      }
    }, {
      key: "toJSON",
      value: function toJSON2(_2, ctx) {
        return _get(_getPrototypeOf(YAMLSet2.prototype), "toJSON", this).call(this, _2, ctx, Set);
      }
    }, {
      key: "toString",
      value: function toString(ctx, onComment, onChompKeep) {
        if (!ctx) return JSON.stringify(this);
        if (this.hasAllNullValues()) return _get(_getPrototypeOf(YAMLSet2.prototype), "toString", this).call(this, ctx, onComment, onChompKeep);
        else throw new Error("Set items must all have null values");
      }
    }]);
    return YAMLSet2;
  }(YAMLMap);
  _defineProperty(YAMLSet, "tag", "tag:yaml.org,2002:set");
  function parseSet(doc, cst) {
    var map2 = resolveMap(doc, cst);
    if (!map2.hasAllNullValues()) throw new YAMLSemanticError(cst, "Set items must all have null values");
    return Object.assign(new YAMLSet(), map2);
  }
  function createSet(schema, iterable, ctx) {
    var set2 = new YAMLSet();
    var _iterator = _createForOfIteratorHelper(iterable), _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done; ) {
        var value = _step.value;
        set2.items.push(schema.createPair(value, null, ctx));
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
    return set2;
  }
  var set = {
    identify: function identify3(value) {
      return value instanceof Set;
    },
    nodeClass: YAMLSet,
    default: false,
    tag: "tag:yaml.org,2002:set",
    resolve: parseSet,
    createNode: createSet
  };
  var parseSexagesimal = function parseSexagesimal2(sign, parts) {
    var n = parts.split(":").reduce(function(n2, p2) {
      return n2 * 60 + Number(p2);
    }, 0);
    return sign === "-" ? -n : n;
  };
  var stringifySexagesimal = function stringifySexagesimal2(_ref) {
    var value = _ref.value;
    if (isNaN(value) || !isFinite(value)) return stringifyNumber(value);
    var sign = "";
    if (value < 0) {
      sign = "-";
      value = Math.abs(value);
    }
    var parts = [value % 60];
    if (value < 60) {
      parts.unshift(0);
    } else {
      value = Math.round((value - parts[0]) / 60);
      parts.unshift(value % 60);
      if (value >= 60) {
        value = Math.round((value - parts[0]) / 60);
        parts.unshift(value);
      }
    }
    return sign + parts.map(function(n) {
      return n < 10 ? "0" + String(n) : String(n);
    }).join(":").replace(/000000\d*$/, "");
  };
  var intTime = {
    identify: function identify4(value) {
      return typeof value === "number";
    },
    default: true,
    tag: "tag:yaml.org,2002:int",
    format: "TIME",
    test: /^([-+]?)([0-9][0-9_]*(?::[0-5]?[0-9])+)$/,
    resolve: function resolve2(str, sign, parts) {
      return parseSexagesimal(sign, parts.replace(/_/g, ""));
    },
    stringify: stringifySexagesimal
  };
  var floatTime = {
    identify: function identify5(value) {
      return typeof value === "number";
    },
    default: true,
    tag: "tag:yaml.org,2002:float",
    format: "TIME",
    test: /^([-+]?)([0-9][0-9_]*(?::[0-5]?[0-9])+\.[0-9_]*)$/,
    resolve: function resolve3(str, sign, parts) {
      return parseSexagesimal(sign, parts.replace(/_/g, ""));
    },
    stringify: stringifySexagesimal
  };
  var timestamp = {
    identify: function identify6(value) {
      return value instanceof Date;
    },
    default: true,
    tag: "tag:yaml.org,2002:timestamp",
    // If the time zone is omitted, the timestamp is assumed to be specified in UTC. The time part
    // may be omitted altogether, resulting in a date format. In such a case, the time part is
    // assumed to be 00:00:00Z (start of day, UTC).
    test: RegExp("^(?:([0-9]{4})-([0-9]{1,2})-([0-9]{1,2})(?:(?:t|T|[ \\t]+)([0-9]{1,2}):([0-9]{1,2}):([0-9]{1,2}(\\.[0-9]+)?)(?:[ \\t]*(Z|[-+][012]?[0-9](?::[0-9]{2})?))?)?)$"),
    resolve: function resolve4(str, year, month, day, hour, minute, second, millisec, tz) {
      if (millisec) millisec = (millisec + "00").substr(1, 3);
      var date = Date.UTC(year, month - 1, day, hour || 0, minute || 0, second || 0, millisec || 0);
      if (tz && tz !== "Z") {
        var d2 = parseSexagesimal(tz[0], tz.slice(1));
        if (Math.abs(d2) < 30) d2 *= 60;
        date -= 6e4 * d2;
      }
      return new Date(date);
    },
    stringify: function stringify2(_ref2) {
      var value = _ref2.value;
      return value.toISOString().replace(/((T00:00)?:00)?\.000Z$/, "");
    }
  };
  function shouldWarn(deprecation) {
    var env = typeof process !== "undefined" && define_process_env_default || {};
    if (deprecation) {
      if (typeof YAML_SILENCE_DEPRECATION_WARNINGS !== "undefined") return !YAML_SILENCE_DEPRECATION_WARNINGS;
      return !env.YAML_SILENCE_DEPRECATION_WARNINGS;
    }
    if (typeof YAML_SILENCE_WARNINGS !== "undefined") return !YAML_SILENCE_WARNINGS;
    return !env.YAML_SILENCE_WARNINGS;
  }
  function warn(warning, type) {
    if (shouldWarn(false)) {
      var emit = typeof process !== "undefined" && process.emitWarning;
      if (emit) emit(warning, type);
      else {
        console.warn(type ? "".concat(type, ": ").concat(warning) : warning);
      }
    }
  }
  var warned = {};
  function warnOptionDeprecation(name, alternative) {
    if (!warned[name] && shouldWarn(true)) {
      warned[name] = true;
      var msg = "The option '".concat(name, "' will be removed in a future release");
      msg += ", use '".concat(alternative, "' instead.");
      warn(msg, "DeprecationWarning");
    }
  }
  function createMap(schema, obj, ctx) {
    var map2 = new YAMLMap(schema);
    if (obj instanceof Map) {
      var _iterator = _createForOfIteratorHelper(obj), _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done; ) {
          var _step$value = _slicedToArray(_step.value, 2), key = _step$value[0], value = _step$value[1];
          map2.items.push(schema.createPair(key, value, ctx));
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    } else if (obj && _typeof(obj) === "object") {
      for (var _i = 0, _Object$keys = Object.keys(obj); _i < _Object$keys.length; _i++) {
        var _key = _Object$keys[_i];
        map2.items.push(schema.createPair(_key, obj[_key], ctx));
      }
    }
    if (typeof schema.sortMapEntries === "function") {
      map2.items.sort(schema.sortMapEntries);
    }
    return map2;
  }
  var map = {
    createNode: createMap,
    default: true,
    nodeClass: YAMLMap,
    tag: "tag:yaml.org,2002:map",
    resolve: resolveMap
  };
  function createSeq(schema, obj, ctx) {
    var seq2 = new YAMLSeq(schema);
    if (obj && obj[Symbol.iterator]) {
      var _iterator = _createForOfIteratorHelper(obj), _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done; ) {
          var it = _step.value;
          var v2 = schema.createNode(it, ctx.wrapScalars, null, ctx);
          seq2.items.push(v2);
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    }
    return seq2;
  }
  var seq = {
    createNode: createSeq,
    default: true,
    nodeClass: YAMLSeq,
    tag: "tag:yaml.org,2002:seq",
    resolve: resolveSeq
  };
  var string = {
    identify: function identify7(value) {
      return typeof value === "string";
    },
    default: true,
    tag: "tag:yaml.org,2002:str",
    resolve: resolveString,
    stringify: function stringify3(item, ctx, onComment, onChompKeep) {
      ctx = Object.assign({
        actualString: true
      }, ctx);
      return stringifyString(item, ctx, onComment, onChompKeep);
    },
    options: strOptions
  };
  var failsafe = [map, seq, string];
  var intIdentify$2 = function intIdentify(value) {
    return typeof value === "bigint" || Number.isInteger(value);
  };
  var intResolve$1 = function intResolve(src, part, radix) {
    return intOptions.asBigInt ? BigInt(src) : parseInt(part, radix);
  };
  function intStringify$1(node, radix, prefix) {
    var value = node.value;
    if (intIdentify$2(value) && value >= 0) return prefix + value.toString(radix);
    return stringifyNumber(node);
  }
  var nullObj = {
    identify: function identify8(value) {
      return value == null;
    },
    createNode: function createNode(schema, value, ctx) {
      return ctx.wrapScalars ? new Scalar(null) : null;
    },
    default: true,
    tag: "tag:yaml.org,2002:null",
    test: /^(?:~|[Nn]ull|NULL)?$/,
    resolve: function resolve5() {
      return null;
    },
    options: nullOptions,
    stringify: function stringify4() {
      return nullOptions.nullStr;
    }
  };
  var boolObj = {
    identify: function identify9(value) {
      return typeof value === "boolean";
    },
    default: true,
    tag: "tag:yaml.org,2002:bool",
    test: /^(?:[Tt]rue|TRUE|[Ff]alse|FALSE)$/,
    resolve: function resolve6(str) {
      return str[0] === "t" || str[0] === "T";
    },
    options: boolOptions,
    stringify: function stringify5(_ref) {
      var value = _ref.value;
      return value ? boolOptions.trueStr : boolOptions.falseStr;
    }
  };
  var octObj = {
    identify: function identify10(value) {
      return intIdentify$2(value) && value >= 0;
    },
    default: true,
    tag: "tag:yaml.org,2002:int",
    format: "OCT",
    test: /^0o([0-7]+)$/,
    resolve: function resolve7(str, oct) {
      return intResolve$1(str, oct, 8);
    },
    options: intOptions,
    stringify: function stringify6(node) {
      return intStringify$1(node, 8, "0o");
    }
  };
  var intObj = {
    identify: intIdentify$2,
    default: true,
    tag: "tag:yaml.org,2002:int",
    test: /^[-+]?[0-9]+$/,
    resolve: function resolve8(str) {
      return intResolve$1(str, str, 10);
    },
    options: intOptions,
    stringify: stringifyNumber
  };
  var hexObj = {
    identify: function identify11(value) {
      return intIdentify$2(value) && value >= 0;
    },
    default: true,
    tag: "tag:yaml.org,2002:int",
    format: "HEX",
    test: /^0x([0-9a-fA-F]+)$/,
    resolve: function resolve9(str, hex) {
      return intResolve$1(str, hex, 16);
    },
    options: intOptions,
    stringify: function stringify7(node) {
      return intStringify$1(node, 16, "0x");
    }
  };
  var nanObj = {
    identify: function identify12(value) {
      return typeof value === "number";
    },
    default: true,
    tag: "tag:yaml.org,2002:float",
    test: /^(?:[-+]?\.inf|(\.nan))$/i,
    resolve: function resolve10(str, nan) {
      return nan ? NaN : str[0] === "-" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY;
    },
    stringify: stringifyNumber
  };
  var expObj = {
    identify: function identify13(value) {
      return typeof value === "number";
    },
    default: true,
    tag: "tag:yaml.org,2002:float",
    format: "EXP",
    test: /^[-+]?(?:\.[0-9]+|[0-9]+(?:\.[0-9]*)?)[eE][-+]?[0-9]+$/,
    resolve: function resolve11(str) {
      return parseFloat(str);
    },
    stringify: function stringify8(_ref2) {
      var value = _ref2.value;
      return Number(value).toExponential();
    }
  };
  var floatObj = {
    identify: function identify14(value) {
      return typeof value === "number";
    },
    default: true,
    tag: "tag:yaml.org,2002:float",
    test: /^[-+]?(?:\.([0-9]+)|[0-9]+\.([0-9]*))$/,
    resolve: function resolve12(str, frac1, frac2) {
      var frac = frac1 || frac2;
      var node = new Scalar(parseFloat(str));
      if (frac && frac[frac.length - 1] === "0") node.minFractionDigits = frac.length;
      return node;
    },
    stringify: stringifyNumber
  };
  var core = failsafe.concat([nullObj, boolObj, octObj, intObj, hexObj, nanObj, expObj, floatObj]);
  var intIdentify$1 = function intIdentify2(value) {
    return typeof value === "bigint" || Number.isInteger(value);
  };
  var stringifyJSON = function stringifyJSON2(_ref) {
    var value = _ref.value;
    return JSON.stringify(value);
  };
  var json = [map, seq, {
    identify: function identify15(value) {
      return typeof value === "string";
    },
    default: true,
    tag: "tag:yaml.org,2002:str",
    resolve: resolveString,
    stringify: stringifyJSON
  }, {
    identify: function identify16(value) {
      return value == null;
    },
    createNode: function createNode2(schema, value, ctx) {
      return ctx.wrapScalars ? new Scalar(null) : null;
    },
    default: true,
    tag: "tag:yaml.org,2002:null",
    test: /^null$/,
    resolve: function resolve13() {
      return null;
    },
    stringify: stringifyJSON
  }, {
    identify: function identify17(value) {
      return typeof value === "boolean";
    },
    default: true,
    tag: "tag:yaml.org,2002:bool",
    test: /^true|false$/,
    resolve: function resolve14(str) {
      return str === "true";
    },
    stringify: stringifyJSON
  }, {
    identify: intIdentify$1,
    default: true,
    tag: "tag:yaml.org,2002:int",
    test: /^-?(?:0|[1-9][0-9]*)$/,
    resolve: function resolve15(str) {
      return intOptions.asBigInt ? BigInt(str) : parseInt(str, 10);
    },
    stringify: function stringify9(_ref2) {
      var value = _ref2.value;
      return intIdentify$1(value) ? value.toString() : JSON.stringify(value);
    }
  }, {
    identify: function identify18(value) {
      return typeof value === "number";
    },
    default: true,
    tag: "tag:yaml.org,2002:float",
    test: /^-?(?:0|[1-9][0-9]*)(?:\.[0-9]*)?(?:[eE][-+]?[0-9]+)?$/,
    resolve: function resolve16(str) {
      return parseFloat(str);
    },
    stringify: stringifyJSON
  }];
  json.scalarFallback = function(str) {
    throw new SyntaxError("Unresolved plain scalar ".concat(JSON.stringify(str)));
  };
  var boolStringify = function boolStringify2(_ref) {
    var value = _ref.value;
    return value ? boolOptions.trueStr : boolOptions.falseStr;
  };
  var intIdentify3 = function intIdentify4(value) {
    return typeof value === "bigint" || Number.isInteger(value);
  };
  function intResolve2(sign, src, radix) {
    var str = src.replace(/_/g, "");
    if (intOptions.asBigInt) {
      switch (radix) {
        case 2:
          str = "0b".concat(str);
          break;
        case 8:
          str = "0o".concat(str);
          break;
        case 16:
          str = "0x".concat(str);
          break;
      }
      var _n2 = BigInt(str);
      return sign === "-" ? BigInt(-1) * _n2 : _n2;
    }
    var n = parseInt(str, radix);
    return sign === "-" ? -1 * n : n;
  }
  function intStringify(node, radix, prefix) {
    var value = node.value;
    if (intIdentify3(value)) {
      var str = value.toString(radix);
      return value < 0 ? "-" + prefix + str.substr(1) : prefix + str;
    }
    return stringifyNumber(node);
  }
  var yaml11 = failsafe.concat([{
    identify: function identify19(value) {
      return value == null;
    },
    createNode: function createNode3(schema, value, ctx) {
      return ctx.wrapScalars ? new Scalar(null) : null;
    },
    default: true,
    tag: "tag:yaml.org,2002:null",
    test: /^(?:~|[Nn]ull|NULL)?$/,
    resolve: function resolve17() {
      return null;
    },
    options: nullOptions,
    stringify: function stringify10() {
      return nullOptions.nullStr;
    }
  }, {
    identify: function identify20(value) {
      return typeof value === "boolean";
    },
    default: true,
    tag: "tag:yaml.org,2002:bool",
    test: /^(?:Y|y|[Yy]es|YES|[Tt]rue|TRUE|[Oo]n|ON)$/,
    resolve: function resolve18() {
      return true;
    },
    options: boolOptions,
    stringify: boolStringify
  }, {
    identify: function identify21(value) {
      return typeof value === "boolean";
    },
    default: true,
    tag: "tag:yaml.org,2002:bool",
    test: /^(?:N|n|[Nn]o|NO|[Ff]alse|FALSE|[Oo]ff|OFF)$/i,
    resolve: function resolve19() {
      return false;
    },
    options: boolOptions,
    stringify: boolStringify
  }, {
    identify: intIdentify3,
    default: true,
    tag: "tag:yaml.org,2002:int",
    format: "BIN",
    test: /^([-+]?)0b([0-1_]+)$/,
    resolve: function resolve20(str, sign, bin) {
      return intResolve2(sign, bin, 2);
    },
    stringify: function stringify11(node) {
      return intStringify(node, 2, "0b");
    }
  }, {
    identify: intIdentify3,
    default: true,
    tag: "tag:yaml.org,2002:int",
    format: "OCT",
    test: /^([-+]?)0([0-7_]+)$/,
    resolve: function resolve21(str, sign, oct) {
      return intResolve2(sign, oct, 8);
    },
    stringify: function stringify12(node) {
      return intStringify(node, 8, "0");
    }
  }, {
    identify: intIdentify3,
    default: true,
    tag: "tag:yaml.org,2002:int",
    test: /^([-+]?)([0-9][0-9_]*)$/,
    resolve: function resolve22(str, sign, abs) {
      return intResolve2(sign, abs, 10);
    },
    stringify: stringifyNumber
  }, {
    identify: intIdentify3,
    default: true,
    tag: "tag:yaml.org,2002:int",
    format: "HEX",
    test: /^([-+]?)0x([0-9a-fA-F_]+)$/,
    resolve: function resolve23(str, sign, hex) {
      return intResolve2(sign, hex, 16);
    },
    stringify: function stringify13(node) {
      return intStringify(node, 16, "0x");
    }
  }, {
    identify: function identify22(value) {
      return typeof value === "number";
    },
    default: true,
    tag: "tag:yaml.org,2002:float",
    test: /^(?:[-+]?\.inf|(\.nan))$/i,
    resolve: function resolve24(str, nan) {
      return nan ? NaN : str[0] === "-" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY;
    },
    stringify: stringifyNumber
  }, {
    identify: function identify23(value) {
      return typeof value === "number";
    },
    default: true,
    tag: "tag:yaml.org,2002:float",
    format: "EXP",
    test: /^[-+]?([0-9][0-9_]*)?(\.[0-9_]*)?[eE][-+]?[0-9]+$/,
    resolve: function resolve25(str) {
      return parseFloat(str.replace(/_/g, ""));
    },
    stringify: function stringify14(_ref2) {
      var value = _ref2.value;
      return Number(value).toExponential();
    }
  }, {
    identify: function identify24(value) {
      return typeof value === "number";
    },
    default: true,
    tag: "tag:yaml.org,2002:float",
    test: /^[-+]?(?:[0-9][0-9_]*)?\.([0-9_]*)$/,
    resolve: function resolve26(str, frac) {
      var node = new Scalar(parseFloat(str.replace(/_/g, "")));
      if (frac) {
        var f2 = frac.replace(/_/g, "");
        if (f2[f2.length - 1] === "0") node.minFractionDigits = f2.length;
      }
      return node;
    },
    stringify: stringifyNumber
  }], binary, omap, pairs, set, intTime, floatTime, timestamp);
  var schemas = {
    core,
    failsafe,
    json,
    yaml11
  };
  var tags = {
    binary,
    bool: boolObj,
    float: floatObj,
    floatExp: expObj,
    floatNaN: nanObj,
    floatTime,
    int: intObj,
    intHex: hexObj,
    intOct: octObj,
    intTime,
    map,
    null: nullObj,
    omap,
    pairs,
    seq,
    set,
    timestamp
  };
  function findTagObject(value, tagName, tags2) {
    if (tagName) {
      var match = tags2.filter(function(t2) {
        return t2.tag === tagName;
      });
      var tagObj = match.find(function(t2) {
        return !t2.format;
      }) || match[0];
      if (!tagObj) throw new Error("Tag ".concat(tagName, " not found"));
      return tagObj;
    }
    return tags2.find(function(t2) {
      return (t2.identify && t2.identify(value) || t2.class && value instanceof t2.class) && !t2.format;
    });
  }
  function createNode$1(value, tagName, ctx) {
    if (value instanceof Node) return value;
    var defaultPrefix = ctx.defaultPrefix, onTagObj = ctx.onTagObj, prevObjects = ctx.prevObjects, schema = ctx.schema, wrapScalars = ctx.wrapScalars;
    if (tagName && tagName.startsWith("!!")) tagName = defaultPrefix + tagName.slice(2);
    var tagObj = findTagObject(value, tagName, schema.tags);
    if (!tagObj) {
      if (typeof value.toJSON === "function") value = value.toJSON();
      if (!value || _typeof(value) !== "object") return wrapScalars ? new Scalar(value) : value;
      tagObj = value instanceof Map ? map : value[Symbol.iterator] ? seq : map;
    }
    if (onTagObj) {
      onTagObj(tagObj);
      delete ctx.onTagObj;
    }
    var obj = {
      value: void 0,
      node: void 0
    };
    if (value && _typeof(value) === "object" && prevObjects) {
      var prev = prevObjects.get(value);
      if (prev) {
        var alias = new Alias(prev);
        ctx.aliasNodes.push(alias);
        return alias;
      }
      obj.value = value;
      prevObjects.set(value, obj);
    }
    obj.node = tagObj.createNode ? tagObj.createNode(ctx.schema, value, ctx) : wrapScalars ? new Scalar(value) : value;
    if (tagName && obj.node instanceof Node) obj.node.tag = tagName;
    return obj.node;
  }
  function getSchemaTags(schemas2, knownTags, customTags, schemaId) {
    var tags2 = schemas2[schemaId.replace(/\W/g, "")];
    if (!tags2) {
      var keys = Object.keys(schemas2).map(function(key) {
        return JSON.stringify(key);
      }).join(", ");
      throw new Error('Unknown schema "'.concat(schemaId, '"; use one of ').concat(keys));
    }
    if (Array.isArray(customTags)) {
      var _iterator = _createForOfIteratorHelper(customTags), _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done; ) {
          var tag = _step.value;
          tags2 = tags2.concat(tag);
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    } else if (typeof customTags === "function") {
      tags2 = customTags(tags2.slice());
    }
    for (var i = 0; i < tags2.length; ++i) {
      var _tag = tags2[i];
      if (typeof _tag === "string") {
        var tagObj = knownTags[_tag];
        if (!tagObj) {
          var _keys = Object.keys(knownTags).map(function(key) {
            return JSON.stringify(key);
          }).join(", ");
          throw new Error('Unknown custom tag "'.concat(_tag, '"; use one of ').concat(_keys));
        }
        tags2[i] = tagObj;
      }
    }
    return tags2;
  }
  var sortMapEntriesByKey = function sortMapEntriesByKey2(a2, b) {
    return a2.key < b.key ? -1 : a2.key > b.key ? 1 : 0;
  };
  var Schema = /* @__PURE__ */ function() {
    function Schema2(_ref) {
      var customTags = _ref.customTags, merge = _ref.merge, schema = _ref.schema, sortMapEntries = _ref.sortMapEntries, deprecatedCustomTags = _ref.tags;
      _classCallCheck(this, Schema2);
      this.merge = !!merge;
      this.name = schema;
      this.sortMapEntries = sortMapEntries === true ? sortMapEntriesByKey : sortMapEntries || null;
      if (!customTags && deprecatedCustomTags) warnOptionDeprecation("tags", "customTags");
      this.tags = getSchemaTags(schemas, tags, customTags || deprecatedCustomTags, schema);
    }
    _createClass(Schema2, [{
      key: "createNode",
      value: function createNode$1$1(value, wrapScalars, tagName, ctx) {
        var baseCtx = {
          defaultPrefix: Schema2.defaultPrefix,
          schema: this,
          wrapScalars
        };
        var createCtx = ctx ? Object.assign(ctx, baseCtx) : baseCtx;
        return createNode$1(value, tagName, createCtx);
      }
    }, {
      key: "createPair",
      value: function createPair(key, value, ctx) {
        if (!ctx) ctx = {
          wrapScalars: true
        };
        var k2 = this.createNode(key, ctx.wrapScalars, null, ctx);
        var v2 = this.createNode(value, ctx.wrapScalars, null, ctx);
        return new Pair(k2, v2);
      }
    }]);
    return Schema2;
  }();
  _defineProperty(Schema, "defaultPrefix", defaultTagPrefix);
  _defineProperty(Schema, "defaultTags", defaultTags);
  var defaultOptions = {
    anchorPrefix: "a",
    customTags: null,
    indent: 2,
    indentSeq: true,
    keepCstNodes: false,
    keepNodeTypes: true,
    keepBlobsInJSON: true,
    mapAsMap: false,
    maxAliasCount: 100,
    prettyErrors: false,
    // TODO Set true in v2
    simpleKeys: false,
    version: "1.2"
  };
  var scalarOptions = {
    get binary() {
      return binaryOptions;
    },
    set binary(opt) {
      Object.assign(binaryOptions, opt);
    },
    get bool() {
      return boolOptions;
    },
    set bool(opt) {
      Object.assign(boolOptions, opt);
    },
    get int() {
      return intOptions;
    },
    set int(opt) {
      Object.assign(intOptions, opt);
    },
    get null() {
      return nullOptions;
    },
    set null(opt) {
      Object.assign(nullOptions, opt);
    },
    get str() {
      return strOptions;
    },
    set str(opt) {
      Object.assign(strOptions, opt);
    }
  };
  var documentOptions = {
    "1.0": {
      schema: "yaml-1.1",
      merge: true,
      tagPrefixes: [{
        handle: "!",
        prefix: defaultTagPrefix
      }, {
        handle: "!!",
        prefix: "tag:private.yaml.org,2002:"
      }]
    },
    1.1: {
      schema: "yaml-1.1",
      merge: true,
      tagPrefixes: [{
        handle: "!",
        prefix: "!"
      }, {
        handle: "!!",
        prefix: defaultTagPrefix
      }]
    },
    1.2: {
      schema: "core",
      merge: false,
      tagPrefixes: [{
        handle: "!",
        prefix: "!"
      }, {
        handle: "!!",
        prefix: defaultTagPrefix
      }]
    }
  };
  function stringifyTag(doc, tag) {
    if ((doc.version || doc.options.version) === "1.0") {
      var priv = tag.match(/^tag:private\.yaml\.org,2002:([^:/]+)$/);
      if (priv) return "!" + priv[1];
      var vocab = tag.match(/^tag:([a-zA-Z0-9-]+)\.yaml\.org,2002:(.*)/);
      return vocab ? "!".concat(vocab[1], "/").concat(vocab[2]) : "!".concat(tag.replace(/^tag:/, ""));
    }
    var p2 = doc.tagPrefixes.find(function(p3) {
      return tag.indexOf(p3.prefix) === 0;
    });
    if (!p2) {
      var dtp = doc.getDefaults().tagPrefixes;
      p2 = dtp && dtp.find(function(p3) {
        return tag.indexOf(p3.prefix) === 0;
      });
    }
    if (!p2) return tag[0] === "!" ? tag : "!<".concat(tag, ">");
    var suffix = tag.substr(p2.prefix.length).replace(/[!,[\]{}]/g, function(ch) {
      return {
        "!": "%21",
        ",": "%2C",
        "[": "%5B",
        "]": "%5D",
        "{": "%7B",
        "}": "%7D"
      }[ch];
    });
    return p2.handle + suffix;
  }
  function getTagObject(tags2, item) {
    if (item instanceof Alias) return Alias;
    if (item.tag) {
      var match = tags2.filter(function(t2) {
        return t2.tag === item.tag;
      });
      if (match.length > 0) return match.find(function(t2) {
        return t2.format === item.format;
      }) || match[0];
    }
    var tagObj, obj;
    if (item instanceof Scalar) {
      obj = item.value;
      var _match = tags2.filter(function(t2) {
        return t2.identify && t2.identify(obj) || t2.class && obj instanceof t2.class;
      });
      tagObj = _match.find(function(t2) {
        return t2.format === item.format;
      }) || _match.find(function(t2) {
        return !t2.format;
      });
    } else {
      obj = item;
      tagObj = tags2.find(function(t2) {
        return t2.nodeClass && obj instanceof t2.nodeClass;
      });
    }
    if (!tagObj) {
      var name = obj && obj.constructor ? obj.constructor.name : _typeof(obj);
      throw new Error("Tag not resolved for ".concat(name, " value"));
    }
    return tagObj;
  }
  function stringifyProps(node, tagObj, _ref) {
    var anchors = _ref.anchors, doc = _ref.doc;
    var props = [];
    var anchor = doc.anchors.getName(node);
    if (anchor) {
      anchors[anchor] = node;
      props.push("&".concat(anchor));
    }
    if (node.tag) {
      props.push(stringifyTag(doc, node.tag));
    } else if (!tagObj.default) {
      props.push(stringifyTag(doc, tagObj.tag));
    }
    return props.join(" ");
  }
  function stringify$1(item, ctx, onComment, onChompKeep) {
    var _ctx$doc = ctx.doc, anchors = _ctx$doc.anchors, schema = _ctx$doc.schema;
    var tagObj;
    if (!(item instanceof Node)) {
      var createCtx = {
        aliasNodes: [],
        onTagObj: function onTagObj(o2) {
          return tagObj = o2;
        },
        prevObjects: /* @__PURE__ */ new Map()
      };
      item = schema.createNode(item, true, null, createCtx);
      var _iterator = _createForOfIteratorHelper(createCtx.aliasNodes), _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done; ) {
          var alias = _step.value;
          alias.source = alias.source.node;
          var name = anchors.getName(alias.source);
          if (!name) {
            name = anchors.newName();
            anchors.map[name] = alias.source;
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    }
    if (item instanceof Pair) return item.toString(ctx, onComment, onChompKeep);
    if (!tagObj) tagObj = getTagObject(schema.tags, item);
    var props = stringifyProps(item, tagObj, ctx);
    if (props.length > 0) ctx.indentAtStart = (ctx.indentAtStart || 0) + props.length + 1;
    var str = typeof tagObj.stringify === "function" ? tagObj.stringify(item, ctx, onComment, onChompKeep) : item instanceof Scalar ? stringifyString(item, ctx, onComment, onChompKeep) : item.toString(ctx, onComment, onChompKeep);
    if (!props) return str;
    return item instanceof Scalar || str[0] === "{" || str[0] === "[" ? "".concat(props, " ").concat(str) : "".concat(props, "\n").concat(ctx.indent).concat(str);
  }
  var Anchors = /* @__PURE__ */ function() {
    function Anchors2(prefix) {
      _classCallCheck(this, Anchors2);
      _defineProperty(this, "map", /* @__PURE__ */ Object.create(null));
      this.prefix = prefix;
    }
    _createClass(Anchors2, [{
      key: "createAlias",
      value: function createAlias(node, name) {
        this.setAnchor(node, name);
        return new Alias(node);
      }
    }, {
      key: "createMergePair",
      value: function createMergePair() {
        var _this = this;
        var merge = new Merge();
        for (var _len = arguments.length, sources = new Array(_len), _key = 0; _key < _len; _key++) {
          sources[_key] = arguments[_key];
        }
        merge.value.items = sources.map(function(s2) {
          if (s2 instanceof Alias) {
            if (s2.source instanceof YAMLMap) return s2;
          } else if (s2 instanceof YAMLMap) {
            return _this.createAlias(s2);
          }
          throw new Error("Merge sources must be Map nodes or their Aliases");
        });
        return merge;
      }
    }, {
      key: "getName",
      value: function getName(node) {
        var map2 = this.map;
        return Object.keys(map2).find(function(a2) {
          return map2[a2] === node;
        });
      }
    }, {
      key: "getNames",
      value: function getNames() {
        return Object.keys(this.map);
      }
    }, {
      key: "getNode",
      value: function getNode(name) {
        return this.map[name];
      }
    }, {
      key: "newName",
      value: function newName(prefix) {
        if (!prefix) prefix = this.prefix;
        var names = Object.keys(this.map);
        for (var i = 1; true; ++i) {
          var name = "".concat(prefix).concat(i);
          if (!names.includes(name)) return name;
        }
      }
      // During parsing, map & aliases contain CST nodes
    }, {
      key: "resolveNodes",
      value: function resolveNodes() {
        var map2 = this.map, _cstAliases = this._cstAliases;
        Object.keys(map2).forEach(function(a2) {
          map2[a2] = map2[a2].resolved;
        });
        _cstAliases.forEach(function(a2) {
          a2.source = a2.source.resolved;
        });
        delete this._cstAliases;
      }
    }, {
      key: "setAnchor",
      value: function setAnchor(node, name) {
        if (node != null && !Anchors2.validAnchorNode(node)) {
          throw new Error("Anchors may only be set for Scalar, Seq and Map nodes");
        }
        if (name && /[\x00-\x19\s,[\]{}]/.test(name)) {
          throw new Error("Anchor names must not contain whitespace or control characters");
        }
        var map2 = this.map;
        var prev = node && Object.keys(map2).find(function(a2) {
          return map2[a2] === node;
        });
        if (prev) {
          if (!name) {
            return prev;
          } else if (prev !== name) {
            delete map2[prev];
            map2[name] = node;
          }
        } else {
          if (!name) {
            if (!node) return null;
            name = this.newName();
          }
          map2[name] = node;
        }
        return name;
      }
    }], [{
      key: "validAnchorNode",
      value: function validAnchorNode(node) {
        return node instanceof Scalar || node instanceof YAMLSeq || node instanceof YAMLMap;
      }
    }]);
    return Anchors2;
  }();
  var visit = function visit2(node, tags2) {
    if (node && _typeof(node) === "object") {
      var tag = node.tag;
      if (node instanceof Collection) {
        if (tag) tags2[tag] = true;
        node.items.forEach(function(n) {
          return visit2(n, tags2);
        });
      } else if (node instanceof Pair) {
        visit2(node.key, tags2);
        visit2(node.value, tags2);
      } else if (node instanceof Scalar) {
        if (tag) tags2[tag] = true;
      }
    }
    return tags2;
  };
  var listTagNames = function listTagNames2(node) {
    return Object.keys(visit(node, {}));
  };
  function parseContents(doc, contents) {
    var comments = {
      before: [],
      after: []
    };
    var body = void 0;
    var spaceBefore = false;
    var _iterator = _createForOfIteratorHelper(contents), _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done; ) {
        var node = _step.value;
        if (node.valueRange) {
          if (body !== void 0) {
            var msg = "Document contains trailing content not separated by a ... or --- line";
            doc.errors.push(new YAMLSyntaxError(node, msg));
            break;
          }
          var res = resolveNode(doc, node);
          if (spaceBefore) {
            res.spaceBefore = true;
            spaceBefore = false;
          }
          body = res;
        } else if (node.comment !== null) {
          var cc = body === void 0 ? comments.before : comments.after;
          cc.push(node.comment);
        } else if (node.type === Type.BLANK_LINE) {
          spaceBefore = true;
          if (body === void 0 && comments.before.length > 0 && !doc.commentBefore) {
            doc.commentBefore = comments.before.join("\n");
            comments.before = [];
          }
        }
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
    doc.contents = body || null;
    if (!body) {
      doc.comment = comments.before.concat(comments.after).join("\n") || null;
    } else {
      var cb = comments.before.join("\n");
      if (cb) {
        var cbNode = body instanceof Collection && body.items[0] ? body.items[0] : body;
        cbNode.commentBefore = cbNode.commentBefore ? "".concat(cb, "\n").concat(cbNode.commentBefore) : cb;
      }
      doc.comment = comments.after.join("\n") || null;
    }
  }
  function resolveTagDirective(_ref, directive) {
    var tagPrefixes = _ref.tagPrefixes;
    var _directive$parameters = _slicedToArray(directive.parameters, 2), handle = _directive$parameters[0], prefix = _directive$parameters[1];
    if (!handle || !prefix) {
      var msg = "Insufficient parameters given for %TAG directive";
      throw new YAMLSemanticError(directive, msg);
    }
    if (tagPrefixes.some(function(p2) {
      return p2.handle === handle;
    })) {
      var _msg = "The %TAG directive must only be given at most once per handle in the same document.";
      throw new YAMLSemanticError(directive, _msg);
    }
    return {
      handle,
      prefix
    };
  }
  function resolveYamlDirective(doc, directive) {
    var _directive$parameters2 = _slicedToArray(directive.parameters, 1), version = _directive$parameters2[0];
    if (directive.name === "YAML:1.0") version = "1.0";
    if (!version) {
      var msg = "Insufficient parameters given for %YAML directive";
      throw new YAMLSemanticError(directive, msg);
    }
    if (!documentOptions[version]) {
      var v0 = doc.version || doc.options.version;
      var _msg2 = "Document will be parsed as YAML ".concat(v0, " rather than YAML ").concat(version);
      doc.warnings.push(new YAMLWarning(directive, _msg2));
    }
    return version;
  }
  function parseDirectives(doc, directives, prevDoc) {
    var directiveComments = [];
    var hasDirectives = false;
    var _iterator = _createForOfIteratorHelper(directives), _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done; ) {
        var directive = _step.value;
        var comment = directive.comment, name = directive.name;
        switch (name) {
          case "TAG":
            try {
              doc.tagPrefixes.push(resolveTagDirective(doc, directive));
            } catch (error) {
              doc.errors.push(error);
            }
            hasDirectives = true;
            break;
          case "YAML":
          case "YAML:1.0":
            if (doc.version) {
              var msg = "The %YAML directive must only be given at most once per document.";
              doc.errors.push(new YAMLSemanticError(directive, msg));
            }
            try {
              doc.version = resolveYamlDirective(doc, directive);
            } catch (error) {
              doc.errors.push(error);
            }
            hasDirectives = true;
            break;
          default:
            if (name) {
              var _msg3 = "YAML only supports %TAG and %YAML directives, and not %".concat(name);
              doc.warnings.push(new YAMLWarning(directive, _msg3));
            }
        }
        if (comment) directiveComments.push(comment);
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
    if (prevDoc && !hasDirectives && "1.1" === (doc.version || prevDoc.version || doc.options.version)) {
      var copyTagPrefix = function copyTagPrefix2(_ref2) {
        var handle = _ref2.handle, prefix = _ref2.prefix;
        return {
          handle,
          prefix
        };
      };
      doc.tagPrefixes = prevDoc.tagPrefixes.map(copyTagPrefix);
      doc.version = prevDoc.version;
    }
    doc.commentBefore = directiveComments.join("\n") || null;
  }
  function assertCollection(contents) {
    if (contents instanceof Collection) return true;
    throw new Error("Expected a YAML collection as document contents");
  }
  var Document$1 = /* @__PURE__ */ function() {
    function Document2(options2) {
      _classCallCheck(this, Document2);
      this.anchors = new Anchors(options2.anchorPrefix);
      this.commentBefore = null;
      this.comment = null;
      this.contents = null;
      this.directivesEndMarker = null;
      this.errors = [];
      this.options = options2;
      this.schema = null;
      this.tagPrefixes = [];
      this.version = null;
      this.warnings = [];
    }
    _createClass(Document2, [{
      key: "add",
      value: function add(value) {
        assertCollection(this.contents);
        return this.contents.add(value);
      }
    }, {
      key: "addIn",
      value: function addIn(path2, value) {
        assertCollection(this.contents);
        this.contents.addIn(path2, value);
      }
    }, {
      key: "delete",
      value: function _delete(key) {
        assertCollection(this.contents);
        return this.contents.delete(key);
      }
    }, {
      key: "deleteIn",
      value: function deleteIn(path2) {
        if (isEmptyPath(path2)) {
          if (this.contents == null) return false;
          this.contents = null;
          return true;
        }
        assertCollection(this.contents);
        return this.contents.deleteIn(path2);
      }
    }, {
      key: "getDefaults",
      value: function getDefaults() {
        return Document2.defaults[this.version] || Document2.defaults[this.options.version] || {};
      }
    }, {
      key: "get",
      value: function get(key, keepScalar) {
        return this.contents instanceof Collection ? this.contents.get(key, keepScalar) : void 0;
      }
    }, {
      key: "getIn",
      value: function getIn(path2, keepScalar) {
        if (isEmptyPath(path2)) return !keepScalar && this.contents instanceof Scalar ? this.contents.value : this.contents;
        return this.contents instanceof Collection ? this.contents.getIn(path2, keepScalar) : void 0;
      }
    }, {
      key: "has",
      value: function has(key) {
        return this.contents instanceof Collection ? this.contents.has(key) : false;
      }
    }, {
      key: "hasIn",
      value: function hasIn(path2) {
        if (isEmptyPath(path2)) return this.contents !== void 0;
        return this.contents instanceof Collection ? this.contents.hasIn(path2) : false;
      }
    }, {
      key: "set",
      value: function set2(key, value) {
        assertCollection(this.contents);
        this.contents.set(key, value);
      }
    }, {
      key: "setIn",
      value: function setIn(path2, value) {
        if (isEmptyPath(path2)) this.contents = value;
        else {
          assertCollection(this.contents);
          this.contents.setIn(path2, value);
        }
      }
    }, {
      key: "setSchema",
      value: function setSchema(id, customTags) {
        if (!id && !customTags && this.schema) return;
        if (typeof id === "number") id = id.toFixed(1);
        if (id === "1.0" || id === "1.1" || id === "1.2") {
          if (this.version) this.version = id;
          else this.options.version = id;
          delete this.options.schema;
        } else if (id && typeof id === "string") {
          this.options.schema = id;
        }
        if (Array.isArray(customTags)) this.options.customTags = customTags;
        var opt = Object.assign({}, this.getDefaults(), this.options);
        this.schema = new Schema(opt);
      }
    }, {
      key: "parse",
      value: function parse3(node, prevDoc) {
        if (this.options.keepCstNodes) this.cstNode = node;
        if (this.options.keepNodeTypes) this.type = "DOCUMENT";
        var _node$directives = node.directives, directives = _node$directives === void 0 ? [] : _node$directives, _node$contents = node.contents, contents = _node$contents === void 0 ? [] : _node$contents, directivesEndMarker = node.directivesEndMarker, error = node.error, valueRange = node.valueRange;
        if (error) {
          if (!error.source) error.source = this;
          this.errors.push(error);
        }
        parseDirectives(this, directives, prevDoc);
        if (directivesEndMarker) this.directivesEndMarker = true;
        this.range = valueRange ? [valueRange.start, valueRange.end] : null;
        this.setSchema();
        this.anchors._cstAliases = [];
        parseContents(this, contents);
        this.anchors.resolveNodes();
        if (this.options.prettyErrors) {
          var _iterator = _createForOfIteratorHelper(this.errors), _step;
          try {
            for (_iterator.s(); !(_step = _iterator.n()).done; ) {
              var _error = _step.value;
              if (_error instanceof YAMLError) _error.makePretty();
            }
          } catch (err) {
            _iterator.e(err);
          } finally {
            _iterator.f();
          }
          var _iterator2 = _createForOfIteratorHelper(this.warnings), _step2;
          try {
            for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
              var warn2 = _step2.value;
              if (warn2 instanceof YAMLError) warn2.makePretty();
            }
          } catch (err) {
            _iterator2.e(err);
          } finally {
            _iterator2.f();
          }
        }
        return this;
      }
    }, {
      key: "listNonDefaultTags",
      value: function listNonDefaultTags() {
        return listTagNames(this.contents).filter(function(t2) {
          return t2.indexOf(Schema.defaultPrefix) !== 0;
        });
      }
    }, {
      key: "setTagPrefix",
      value: function setTagPrefix(handle, prefix) {
        if (handle[0] !== "!" || handle[handle.length - 1] !== "!") throw new Error("Handle must start and end with !");
        if (prefix) {
          var prev = this.tagPrefixes.find(function(p2) {
            return p2.handle === handle;
          });
          if (prev) prev.prefix = prefix;
          else this.tagPrefixes.push({
            handle,
            prefix
          });
        } else {
          this.tagPrefixes = this.tagPrefixes.filter(function(p2) {
            return p2.handle !== handle;
          });
        }
      }
    }, {
      key: "toJSON",
      value: function toJSON$1(arg, onAnchor) {
        var _this = this;
        var _this$options = this.options, keepBlobsInJSON = _this$options.keepBlobsInJSON, mapAsMap = _this$options.mapAsMap, maxAliasCount = _this$options.maxAliasCount;
        var keep = keepBlobsInJSON && (typeof arg !== "string" || !(this.contents instanceof Scalar));
        var ctx = {
          doc: this,
          indentStep: "  ",
          keep,
          mapAsMap: keep && !!mapAsMap,
          maxAliasCount,
          stringify: stringify$1
          // Requiring directly in Pair would create circular dependencies
        };
        var anchorNames = Object.keys(this.anchors.map);
        if (anchorNames.length > 0) ctx.anchors = new Map(anchorNames.map(function(name) {
          return [_this.anchors.map[name], {
            alias: [],
            aliasCount: 0,
            count: 1
          }];
        }));
        var res = toJSON(this.contents, arg, ctx);
        if (typeof onAnchor === "function" && ctx.anchors) {
          var _iterator3 = _createForOfIteratorHelper(ctx.anchors.values()), _step3;
          try {
            for (_iterator3.s(); !(_step3 = _iterator3.n()).done; ) {
              var _step3$value = _step3.value, count = _step3$value.count, _res = _step3$value.res;
              onAnchor(_res, count);
            }
          } catch (err) {
            _iterator3.e(err);
          } finally {
            _iterator3.f();
          }
        }
        return res;
      }
    }, {
      key: "toString",
      value: function toString() {
        if (this.errors.length > 0) throw new Error("Document with errors cannot be stringified");
        var indentSize = this.options.indent;
        if (!Number.isInteger(indentSize) || indentSize <= 0) {
          var s2 = JSON.stringify(indentSize);
          throw new Error('"indent" option must be a positive integer, not '.concat(s2));
        }
        this.setSchema();
        var lines = [];
        var hasDirectives = false;
        if (this.version) {
          var vd = "%YAML 1.2";
          if (this.schema.name === "yaml-1.1") {
            if (this.version === "1.0") vd = "%YAML:1.0";
            else if (this.version === "1.1") vd = "%YAML 1.1";
          }
          lines.push(vd);
          hasDirectives = true;
        }
        var tagNames = this.listNonDefaultTags();
        this.tagPrefixes.forEach(function(_ref) {
          var handle = _ref.handle, prefix = _ref.prefix;
          if (tagNames.some(function(t2) {
            return t2.indexOf(prefix) === 0;
          })) {
            lines.push("%TAG ".concat(handle, " ").concat(prefix));
            hasDirectives = true;
          }
        });
        if (hasDirectives || this.directivesEndMarker) lines.push("---");
        if (this.commentBefore) {
          if (hasDirectives || !this.directivesEndMarker) lines.unshift("");
          lines.unshift(this.commentBefore.replace(/^/gm, "#"));
        }
        var ctx = {
          anchors: /* @__PURE__ */ Object.create(null),
          doc: this,
          indent: "",
          indentStep: " ".repeat(indentSize),
          stringify: stringify$1
          // Requiring directly in nodes would create circular dependencies
        };
        var chompKeep = false;
        var contentComment = null;
        if (this.contents) {
          if (this.contents instanceof Node) {
            if (this.contents.spaceBefore && (hasDirectives || this.directivesEndMarker)) lines.push("");
            if (this.contents.commentBefore) lines.push(this.contents.commentBefore.replace(/^/gm, "#"));
            ctx.forceBlockIndent = !!this.comment;
            contentComment = this.contents.comment;
          }
          var onChompKeep = contentComment ? null : function() {
            return chompKeep = true;
          };
          var body = stringify$1(this.contents, ctx, function() {
            return contentComment = null;
          }, onChompKeep);
          lines.push(addComment(body, "", contentComment));
        } else if (this.contents !== void 0) {
          lines.push(stringify$1(this.contents, ctx));
        }
        if (this.comment) {
          if ((!chompKeep || contentComment) && lines[lines.length - 1] !== "") lines.push("");
          lines.push(this.comment.replace(/^/gm, "#"));
        }
        return lines.join("\n") + "\n";
      }
    }]);
    return Document2;
  }();
  _defineProperty(Document$1, "defaults", documentOptions);
  function createNode4(value) {
    var wrapScalars = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
    var tag = arguments.length > 2 ? arguments[2] : void 0;
    if (tag === void 0 && typeof wrapScalars === "string") {
      tag = wrapScalars;
      wrapScalars = true;
    }
    var options2 = Object.assign({}, Document$1.defaults[defaultOptions.version], defaultOptions);
    var schema = new Schema(options2);
    return schema.createNode(value, wrapScalars, tag);
  }
  var Document = /* @__PURE__ */ function(_YAMLDocument) {
    _inherits(Document2, _YAMLDocument);
    var _super = _createSuper(Document2);
    function Document2(options2) {
      _classCallCheck(this, Document2);
      return _super.call(this, Object.assign({}, defaultOptions, options2));
    }
    return Document2;
  }(Document$1);
  function parseAllDocuments(src, options2) {
    var stream = [];
    var prev;
    var _iterator = _createForOfIteratorHelper(parse$1(src)), _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done; ) {
        var cstDoc = _step.value;
        var doc = new Document(options2);
        doc.parse(cstDoc, prev);
        stream.push(doc);
        prev = doc;
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
    return stream;
  }
  function parseDocument(src, options2) {
    var cst = parse$1(src);
    var doc = new Document(options2).parse(cst[0]);
    if (cst.length > 1) {
      var errMsg = "Source contains multiple documents; please use YAML.parseAllDocuments()";
      doc.errors.unshift(new YAMLSemanticError(cst[1], errMsg));
    }
    return doc;
  }
  function parse(src, options2) {
    var doc = parseDocument(src, options2);
    doc.warnings.forEach(function(warning) {
      return warn(warning);
    });
    if (doc.errors.length > 0) throw doc.errors[0];
    return doc.toJSON();
  }
  function stringify15(value, options2) {
    var doc = new Document(options2);
    doc.contents = value;
    return String(doc);
  }
  var YAML$1 = {
    createNode: createNode4,
    defaultOptions,
    Document,
    parse,
    parseAllDocuments,
    parseCST: parse$1,
    parseDocument,
    scalarOptions,
    stringify: stringify15
  };
  const dist = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    YAML: YAML$1
  }, Symbol.toStringTag, { value: "Module" }));
  const require$$0 = /* @__PURE__ */ getAugmentedNamespace(dist);
  var browser = require$$0.YAML;
  const YAML = /* @__PURE__ */ getDefaultExportFromCjs(browser);
  const AnalyzeUploadPage = () => {
    const analyzeForm = () => {
      const baseUrl = window.location.origin;
      const host = window.location.host;
      const baseConfig = {
        url: baseUrl,
        host,
        uploadPath: window.location.pathname
      };
      const formElements = document.querySelectorAll("input, select, textarea");
      const formConfig = {};
      formElements.forEach((element) => {
        var _a2, _b;
        const name = element.getAttribute("name");
        if (!name) return;
        if (element instanceof HTMLSelectElement) {
          const options2 = Array.from(element.options).map((opt) => ({
            text: opt.text,
            value: opt.value
          }));
          formConfig[name] = {
            selector: `select[name="${name}"]`,
            options: options2
          };
        } else if (element instanceof HTMLInputElement) {
          formConfig[name] = {
            selector: `input[name="${name}"]`,
            type: element.type,
            label: (_b = (_a2 = element.labels) == null ? void 0 : _a2[0]) == null ? void 0 : _b.textContent
          };
        } else if (element instanceof HTMLTextAreaElement) {
          formConfig[name] = {
            selector: `textarea[name="${name}"]`
          };
        }
      });
      const yamlContent = YAML.stringify(__spreadValues(__spreadValues({}, formConfig), baseConfig));
      navigator.clipboard.writeText(`\`\`\`yaml
${yamlContent}\`\`\``).then(() => {
        Jt.success($t$1("配置已复制到剪贴板,请黏贴到创建的Github Issue中"));
      });
    };
    return /* @__PURE__ */ u$1(preact.Fragment, { children: [
      /* @__PURE__ */ u$1(Te, { position: "top-right", richColors: true }),
      /* @__PURE__ */ u$1(
        "button",
        {
          onClick: analyzeForm,
          style: {
            position: "fixed",
            bottom: "20px",
            right: "20px",
            zIndex: 9999,
            padding: "8px 16px",
            backgroundColor: "#4CAF50",
            color: "white",
            border: "none",
            borderRadius: "4px",
            cursor: "pointer"
          },
          children: `[EASY-UPLOAD]${$t$1("获取页面配置")}`
        }
      )
    ] });
  };
  if (location.pathname.includes("upload") && !(CURRENT_SITE_INFO == null ? void 0 : CURRENT_SITE_INFO.asTarget) && window.self === window.top) {
    const div = document.createElement("div");
    preact.render(/* @__PURE__ */ u$1(AnalyzeUploadPage, {}), div);
    document.body.appendChild(div);
  }
  const useSiteConfig = () => {
    return T$1(() => {
      let siteType = "default";
      if (CURRENT_SITE_NAME === "HH") {
        siteType = "HH";
      } else if (CURRENT_SITE_NAME === "MTeam") {
        siteType = "MTeam";
      } else if (CURRENT_SITE_INFO.siteType === "gazelle") {
        siteType = "Gazelle";
      } else if (CURRENT_SITE_NAME === "Cinematik") {
        siteType = "Cinematik";
      } else if (CURRENT_SITE_NAME === "SpeedApp") {
        siteType = "SpeedApp";
      } else if (CURRENT_SITE_NAME === "HDBits") {
        siteType = "HDBits";
      } else if (CURRENT_SITE_INFO.siteType.match(/NexusPHP|AvistaZ/) || (CURRENT_SITE_NAME == null ? void 0 : CURRENT_SITE_NAME.match(
        /BeyondHD|TTG|Blutopia|HDPOST|Aither|ACM|KG|iTS|MDU|LST|fearnopeer/
      ))) {
        siteType = "NexusPHP";
      }
      return siteType;
    }, []);
  };
  const SPECIAL_SITE_TYPES = {
    NO_IMDB_SITES: /(nzbs.in|HDF|TMDB|豆瓣读书|TeamHD|NPUBits)$/,
    MUSIC_SITES: /RED|DicMusic|Orpheus/,
    NAME_REPLACE_SITES: /nzb|TMDB|豆瓣读书|SubHD|OpenSub/,
    AVISTAZ_SITES: "AvistaZ",
    ZHUQUE: /ZHUQUE/
  };
  function determineSearchKeyword({
    siteName,
    siteInfo,
    torrentInfo
  }) {
    var _a2;
    const { imdbUrl, movieAkaName, movieName, title, musicJson } = torrentInfo;
    const imdbId = imdbUrl ? getIdByIMDbUrl(imdbUrl) : "";
    let searchKeyWord = "";
    let useImdb = false;
    if (CURRENT_SITE_NAME.match(SPECIAL_SITE_TYPES.MUSIC_SITES)) {
      const { year = "", name = "" } = (_a2 = musicJson == null ? void 0 : musicJson.group) != null ? _a2 : {};
      searchKeyWord = `${name} ${year}`.trim();
    } else if (imdbId && !siteName.match(SPECIAL_SITE_TYPES.NO_IMDB_SITES) && siteInfo.siteType !== SPECIAL_SITE_TYPES.AVISTAZ_SITES) {
      if (siteInfo.search.replaceKey && siteInfo.search.replaceKey.length === 2) {
        const [pattern, replacement] = siteInfo.search.replaceKey;
        searchKeyWord = imdbId.replace(new RegExp(pattern), replacement);
      } else {
        searchKeyWord = imdbId;
      }
      useImdb = true;
    } else {
      searchKeyWord = movieAkaName || movieName || title || "";
      useImdb = false;
    }
    return { searchKeyWord, useImdb };
  }
  function buildSearchParams({
    siteName,
    params,
    useImdb,
    searchKeyWord,
    imdbOptionKey,
    nameOptionKey
  }) {
    let paramsArray = Object.entries(params).map(
      ([key, value]) => `${key}=${value}`
    );
    if (useImdb) {
      paramsArray = paramsArray.filter(
        (param) => !param.match(/\w+={name}&{0,1}?/)
      );
      paramsArray = paramsArray.map(
        (param) => param.replace(/{imdb}/g, searchKeyWord).replace(/{optionKey}/g, imdbOptionKey)
      );
    } else {
      paramsArray = paramsArray.filter(
        (param) => !param.match(/\w+={imdb}&{0,1}?/)
      );
      paramsArray = paramsArray.map((param) => {
        if (param.includes("{name}")) {
          return param.replace(/{name}/g, searchKeyWord);
        } else if (param.includes("{imdb}")) {
          return param.replace(/{imdb}/g, searchKeyWord);
        }
        return param.replace(/{optionKey}/g, nameOptionKey);
      });
    }
    if (siteName.match(SPECIAL_SITE_TYPES.ZHUQUE)) {
      const queryParams = {};
      paramsArray.forEach((param) => {
        const [key, value] = param.split("=");
        queryParams[key] = value;
      });
      return `/${window.btoa(encodeURIComponent(JSON.stringify(queryParams)))}`;
    }
    return `?${paramsArray.join("&")}`;
  }
  const getQuickSearchUrl = (siteName) => {
    const siteInfo = PT_SITE[siteName];
    const torrentInfo = GM_getValue("cachedTorrentInfo") || {};
    if (!siteInfo.search) {
      return siteInfo.url;
    }
    const {
      params = {},
      imdbOptionKey = "",
      nameOptionKey = "",
      path: path2 = ""
    } = siteInfo.search;
    const { searchKeyWord, useImdb } = determineSearchKeyword({
      siteName,
      siteInfo,
      torrentInfo
    });
    const searchParams = buildSearchParams({
      siteName,
      params,
      useImdb,
      searchKeyWord,
      imdbOptionKey,
      nameOptionKey
    });
    let url = `${siteInfo.url}${path2}${searchParams ? `${searchParams}` : ""}`;
    if (siteName.match(SPECIAL_SITE_TYPES.NAME_REPLACE_SITES)) {
      url = url.replace(/{name}/g, encodeURIComponent(searchKeyWord));
    }
    return url;
  };
  const useQuickSearch = () => {
    const checkQuickResult = q$1(async () => {
      try {
        let searchListSetting = GM_getValue(
          "easy-upload.enabled-search-site-list",
          []
        );
        if (searchListSetting.length === 0) {
          searchListSetting = SORTED_SITE_KEYS;
        }
        searchListSetting.map(async (site) => {
          var _a2;
          const siteInfo = PT_SITE[site];
          const resultConfig = (_a2 = siteInfo.search) == null ? void 0 : _a2.result;
          const siteUrl = siteInfo.url;
          if (!resultConfig) return;
          try {
            const url = getQuickSearchUrl(site);
            const domString = await GMFetch(url);
            const dom = new DOMParser().parseFromString(domString, "text/html");
            const { list, name, size, url: urlDom } = resultConfig;
            const { title, size: searchSize } = GM_getValue("cachedTorrentInfo");
            const torrentList = $$2(list, dom);
            const sameTorrent = Array.prototype.find.call(torrentList, (item) => {
              var _a3, _b, _c, _d, _e;
              let torrentName;
              if (site === "TTG") {
                torrentName = (_c = (_b = (_a3 = $$2(item).find(name).prop("firstChild")) == null ? void 0 : _a3.textContent) == null ? void 0 : _b.trim()) != null ? _c : "";
              } else {
                torrentName = $$2(item).find(name).attr("title") || $$2(item).find(name).text();
              }
              if (site === "TJUPT") {
                const matchArray = torrentName.match(/\[[^\]]+(\.|\s)+[^\]]+\]/g) || [];
                const realTitle = (_e = (_d = matchArray.filter((item2) => item2.match(/\.| /))) == null ? void 0 : _d[0]) != null ? _e : "";
                torrentName = realTitle.replace(/\[|\]/g, "");
              }
              torrentName = torrentName == null ? void 0 : torrentName.replace(/\s|\./g, "");
              const sizeBytes = convertSizeStringToBytes(
                $$2(item).find(size).text()
              );
              return torrentName === (title == null ? void 0 : title.replace(/\s|\./g, "")) && Math.abs(sizeBytes - searchSize) < Math.pow(1024, 2) * 1e3;
            });
            if (sameTorrent) {
              const url2 = `${siteUrl}/${$$2(sameTorrent).find(urlDom).attr("href")}`;
              $$2(`.search-list li>a[data-site=${site}]`).attr("data-url", url2).css("color", "#218380");
            } else {
              $$2(`.search-list li>a[data-site=${site}]`).css("color", "#D81159");
            }
          } catch (error) {
            console.error(`Error checking ${site}:`, error);
          }
        });
      } catch (error) {
        console.error("Quick search error:", error);
      }
    }, []);
    return { checkQuickResult };
  };
  const useTorrentInfo = () => {
    const [torrentInfo, setTorrentInfo] = h(
      () => torrentInfoStore.getInfo()
    );
    y(() => {
      const unsubscribe = torrentInfoStore.subscribe(setTorrentInfo);
      return unsubscribe;
    }, []);
    const updateTorrentInfo = (updater) => {
      torrentInfoStore.updateInfo(updater);
    };
    return {
      torrentInfo,
      updateTorrentInfo,
      setTorrentInfo: (info) => torrentInfoStore.setInfo(info)
    };
  };
  const Douban = () => {
    const { torrentInfo, updateTorrentInfo } = useTorrentInfo();
    const [btnText, setBtnText] = h("获取豆瓣简介");
    const [bookBtnText, setBookBtnText] = h("获取豆瓣读书简介");
    const [btnDisable, setBtnDisable] = h(false);
    const [searchValue, setSearchValue] = h("");
    const doubanClosed = GM_getValue("easy-upload.douban-closed");
    const { needDoubanBookInfo, needDoubanInfo } = CURRENT_SITE_INFO;
    const showSearch = (needDoubanBookInfo || needDoubanInfo || !torrentInfo.doubanUrl) && !doubanClosed;
    const handleDoubanInfoUpdate = q$1(
      (formatDoubanInfo) => {
        updateTorrentInfo((prevInfo) => {
          var _a2, _b;
          const areaMatch = (_b = (_a2 = formatDoubanInfo == null ? void 0 : formatDoubanInfo.match(/(产\s+地|国\s+家)\s+(.+)/)) == null ? void 0 : _a2[2]) != null ? _b : "";
          const area = areaMatch ? getAreaCode(areaMatch) : prevInfo.area;
          return __spreadProps(__spreadValues({}, prevInfo), {
            doubanInfo: formatDoubanInfo,
            area,
            category: refineCategory(__spreadProps(__spreadValues({}, prevInfo), { area }), prevInfo.category)
          });
        });
      },
      [updateTorrentInfo]
    );
    const getDoubanData = q$1(async () => {
      if (btnDisable) return;
      try {
        setBtnText("获取中...");
        setBtnDisable(true);
        const scriptDoubanLink = $$2(".douban-dom").attr("douban-link");
        const doubanLink = $$2(".page__title>a").attr("href") || scriptDoubanLink || torrentInfo.doubanUrl || searchValue;
        let doubanUrl = "";
        if (doubanLink && doubanLink.match(/movie\.douban\.com/)) {
          doubanUrl = doubanLink;
        } else {
          const { imdbUrl, movieName } = torrentInfo;
          const doubanData = await getDoubanBasicDataByQuery(
            imdbUrl || movieName
          );
          if (doubanData) {
            let { id, season = "" } = doubanData;
            if (season) {
              const tvData = await getDoubanTVItemData(
                doubanData,
                torrentInfo.title
              );
              if (tvData) {
                id = tvData.id;
              }
            }
            doubanUrl = `https://movie.douban.com/subject/${id}`;
          }
        }
        if (doubanUrl) {
          updateTorrentInfo({ doubanUrl });
          setSearchValue(doubanUrl);
          if (!torrentInfo.description.match(/(片|译)\s*名/)) {
            const isTVCategory = !!torrentInfo.category.match(/tv/);
            const formatDoubanInfo = await getDoubanInfoByIdOrDoubanUrl(
              doubanUrl,
              isTVCategory ? "tv" : "movie"
            );
            if (formatDoubanInfo.format) {
              Jt.success($t$1("获取成功"));
              handleDoubanInfoUpdate(formatDoubanInfo.format);
              const subtitle = getSubTitleFromDoubanInfo(
                formatDoubanInfo,
                torrentInfo
              );
              updateTorrentInfo({
                subtitle
              });
            }
          } else {
            Jt.success($t$1("获取成功"));
          }
        }
      } catch (error) {
        console.error("获取豆瓣数据失败:", error);
        Jt.error($t$1("获取失败"));
      } finally {
        setBtnText("获取豆瓣简介");
        setBtnDisable(false);
      }
    }, [
      btnDisable,
      searchValue,
      torrentInfo,
      updateTorrentInfo,
      handleDoubanInfoUpdate
    ]);
    const getBookData = q$1(async () => {
      if (btnDisable) return;
      const doubanUrl = torrentInfo.doubanUrl || searchValue;
      if (!doubanUrl) {
        Jt.error($t$1("缺少豆瓣链接"));
        return;
      }
      try {
        setBookBtnText("获取中...");
        setBtnDisable(true);
        setSearchValue(doubanUrl);
        const data = await getDoubanBookInfo(doubanUrl);
        if (data) {
          updateTorrentInfo({
            title: data.chinese_title || data.foreign_title,
            poster: data.poster,
            description: data.book_intro || "",
            doubanBookInfo: data
          });
          Jt.success($t$1("获取成功"));
        }
      } catch (error) {
        console.error("获取豆瓣图书数据失败:", error);
        Jt.error(error.message);
      } finally {
        setBookBtnText("获取豆瓣读书简介");
        setBtnDisable(false);
      }
    }, [btnDisable, searchValue, torrentInfo.doubanUrl, updateTorrentInfo]);
    if (!showSearch) return null;
    return /* @__PURE__ */ u$1(preact.Fragment, { children: [
      /* @__PURE__ */ u$1("div", { className: "function-list-item", children: /* @__PURE__ */ u$1("div", { className: "douban-section", children: /* @__PURE__ */ u$1(
        "input",
        {
          type: "text",
          placeholder: $t$1("手动输入豆瓣链接"),
          value: searchValue,
          onChange: (e2) => setSearchValue(e2.target.value)
        }
      ) }) }),
      /* @__PURE__ */ u$1("div", { className: "function-list-item", children: /* @__PURE__ */ u$1("div", { className: "douban-section", children: CURRENT_SITE_NAME !== "SoulVoice" ? /* @__PURE__ */ u$1(
        "button",
        {
          id: "douban-info",
          disabled: btnDisable,
          className: btnDisable ? "is-disabled" : "",
          onClick: getDoubanData,
          children: $t$1(btnText)
        }
      ) : /* @__PURE__ */ u$1(
        "button",
        {
          disabled: btnDisable,
          className: btnDisable ? "is-disabled" : "",
          id: "douban-book-info",
          onClick: getBookData,
          children: $t$1(bookBtnText)
        }
      ) }) })
    ] });
  };
  const IMAGE_HOSTS$1 = {
    imgbox: {
      url: "https://imgbox.com",
      name: "imgbox",
      handler: uploadToImgbox
    },
    imgbb: {
      url: "https://imgbb.com/json",
      name: "imgbb",
      handler: transferImgToCheveretoSite
    },
    gifyu: {
      url: "https://gifyu.com/json",
      name: "gifyu",
      handler: transferImgToCheveretoSite
    },
    pixhost: {
      url: "https://pixhost.to",
      name: "pixhost",
      handler: uploadToPixhost
    },
    HDB: {
      url: "https://img.hdbits.org",
      name: "HDB",
      handler: uploadToHDB
    }
  };
  const Transfer = () => {
    const { torrentInfo, updateTorrentInfo } = useTorrentInfo();
    const [imgHost, setImgHost] = h("imgbox");
    const [btnDisable, setBtnDisable] = h(false);
    const [btnText, setBtnText] = h("转缩略图");
    const transferImgClosed = T$1(
      () => GM_getValue("easy-upload.transfer-img-closed"),
      []
    );
    const getAllImages = q$1(() => {
      const { comparisons = [], screenshots = [] } = torrentInfo;
      const allImgs = [...screenshots];
      comparisons.forEach((comparison) => {
        if (comparison.imgs && Array.isArray(comparison.imgs)) {
          allImgs.push(...comparison.imgs);
        }
      });
      return [...new Set(allImgs)];
    }, [torrentInfo]);
    const updateDescriptionImages = q$1(
      (originalUrls, newBBCodes) => {
        let { description } = torrentInfo;
        originalUrls.forEach((originalUrl, index) => {
          var _a2, _b;
          const newBBCode = newBBCodes[index] || "";
          if (originalUrl.match(/i\.hdbits\.org/)) {
            const imgId = (_b = (_a2 = originalUrl.match(/i\.hdbits\.org\/(.+)\./)) == null ? void 0 : _a2[1]) != null ? _b : "";
            const urlReg = new RegExp(
              `\\[url=https://img.hdbits.org/${imgId}\\].+?\\[\\/url\\]
*`,
              "ig"
            );
            if (description.match(urlReg)) {
              description = description.replace(urlReg, newBBCode);
            }
          } else if (description.includes(originalUrl)) {
            const urlReg = new RegExp(
              `\\[url=${originalUrl}\\].+?\\[\\/url\\]
*`,
              "ig"
            );
            if (description.match(urlReg)) {
              description = description.replace(urlReg, newBBCode);
            } else {
              description = description.replace(
                new RegExp(`\\[img\\]${originalUrl}\\[\\/img\\]
*`, "ig"),
                newBBCode
              );
            }
          }
        });
        return description;
      },
      [torrentInfo]
    );
    const handleThumbnailConversion = q$1(async () => {
      if (btnDisable) return;
      try {
        const images = getAllImages();
        if (images.length < 1) {
          throw new Error($t$1("获取图片列表失败"));
        }
        setBtnText("转换中...");
        setBtnDisable(true);
        const selectedHost = IMAGE_HOSTS$1[imgHost];
        let uploadedImgs = [];
        if (imgHost === "HDB") {
          uploadedImgs = await (await uploadToHDB)(images, torrentInfo.title);
        } else if (imgHost === "imgbb" || imgHost === "gifyu") {
          uploadedImgs = await (await transferImgToCheveretoSite)(images, selectedHost.url);
        } else if (imgHost === "pixhost") {
          uploadedImgs = await (await uploadToPixhost)(images);
        } else if (imgHost === "imgbox") {
          uploadedImgs = await (await uploadToImgbox)(images);
        }
        const imgsBBCodeArray = uploadedImgs.map(
          (img) => `[url=${img.original}][img]${img.thumbnail}[/img][/url]`
        );
        if (uploadedImgs.length) {
          const { screenshots = [] } = torrentInfo;
          const updatedDescription = updateDescriptionImages(
            images,
            imgsBBCodeArray
          );
          updateTorrentInfo({
            screenshots: imgsBBCodeArray.slice(0, screenshots.length),
            description: updatedDescription
          });
          Jt.success($t$1("转换成功！"));
        }
      } catch (error) {
        Jt.error(error.message);
        console.error("缩略图转换失败:", error);
      } finally {
        setBtnText("转缩略图");
        setBtnDisable(false);
      }
    }, [
      btnDisable,
      imgHost,
      getAllImages,
      updateDescriptionImages,
      torrentInfo,
      updateTorrentInfo
    ]);
    if (transferImgClosed || CURRENT_SITE_NAME === "BTN") {
      return null;
    }
    return /* @__PURE__ */ u$1("div", { className: "function-list-item", children: /* @__PURE__ */ u$1("div", { className: "upload-section", children: [
      /* @__PURE__ */ u$1(
        "button",
        {
          className: btnDisable ? "is-disabled" : "",
          onClick: handleThumbnailConversion,
          disabled: btnDisable,
          children: $t$1(btnText)
        }
      ),
      /* @__PURE__ */ u$1(
        "select",
        {
          value: imgHost,
          onChange: (e2) => setImgHost(e2.target.value),
          disabled: btnDisable,
          children: Object.entries(IMAGE_HOSTS$1).map(([key, host]) => /* @__PURE__ */ u$1("option", { value: key, children: host.name }, key))
        }
      )
    ] }) });
  };
  const IMAGE_HOSTS = {
    ptpimg: {
      name: "ptpimg"
    },
    gifyu: {
      name: "gifyu",
      url: "https://gifyu.com/json"
    }
  };
  const UploadImg = () => {
    const { torrentInfo, updateTorrentInfo } = useTorrentInfo();
    const [selectHost, setSelectHost] = h("ptpimg");
    const [btnDisable, setBtnDisable] = h(false);
    const [btnText, setBtnText] = h("转存截图");
    const [canCopy, setCanCopy] = h(false);
    const [screenBBCode, setScreenBBCode] = h([]);
    const [copyText, setCopyText] = h("拷贝");
    const uploadImgClosed = T$1(
      () => GM_getValue("easy-upload.rehost-img-closed", false),
      []
    );
    const handleCopyBBCode = q$1(() => {
      GM_setClipboard(screenBBCode.join(""));
      setCopyText("已拷贝");
    }, [screenBBCode]);
    const extractAndUploadImages = q$1(async () => {
      const { screenshots } = torrentInfo;
      try {
        const originalImgUrlPromises = screenshots.map(
          (img) => getOriginalImgUrl(img)
        );
        const originalImgUrls = await Promise.all(originalImgUrlPromises);
        if (originalImgUrls.length === 0) {
          throw new Error($t$1("图片上传失败"));
        }
        let imgData = [];
        if (selectHost === "ptpimg") {
          imgData = await transferImgsToPtpimg(originalImgUrls);
        } else if (selectHost === "gifyu") {
          imgData = await (await transferImgToCheveretoSite)(originalImgUrls, IMAGE_HOSTS.gifyu.url);
        }
        if (imgData.length === 0) {
          throw new Error($t$1("图片上传失败"));
        }
        return imgData;
      } catch (error) {
        console.error("fail to extract and upload images:", error);
        throw error;
      }
    }, [selectHost, torrentInfo]);
    const updateTorrentWithNewImages = q$1(
      (imgData) => {
        var _a2;
        const { description, originalDescription } = torrentInfo;
        const newScreenshots = imgData.map((img) => {
          return selectHost !== "ptpimg" ? img == null ? void 0 : img.original : img;
        });
        const screenBBcodeArray = imgData.map(
          (img) => typeof img === "string" ? `[img]${img}[/img]` : `[img]${img.original}[/img]`
        );
        const allImages = (_a2 = description.match(
          /(\[url=(http(s)*:\/{2}.+?)\])?\[img\](.+?)\[\/img](\[url\])?/gi
        )) != null ? _a2 : [];
        let updatedDescription = description;
        let updatedOriginalDescription = originalDescription || "";
        if (allImages.length > 0) {
          allImages.forEach((img) => {
            const imgWithUrl = img.match(/\[url=.+?\]/) ? `${img}[/url]` : img;
            updatedOriginalDescription = updatedOriginalDescription.replace(
              imgWithUrl,
              ""
            );
            updatedDescription = updatedDescription.replace(imgWithUrl, "");
          });
        }
        updateTorrentInfo({
          screenshots: newScreenshots,
          originalDescription: `${updatedOriginalDescription}
${screenBBcodeArray.join("")}`,
          description: `${updatedDescription}
${screenBBcodeArray.join("")}`
        });
        return screenBBcodeArray;
      },
      [torrentInfo, selectHost, updateTorrentInfo]
    );
    const handleUploadScreenshots = q$1(async () => {
      if (btnDisable) return;
      setBtnText("上传中，请稍候...");
      setBtnDisable(true);
      setCanCopy(false);
      setCopyText("拷贝");
      try {
        const imgData = await extractAndUploadImages();
        const screenBBcodeArray = updateTorrentWithNewImages(imgData);
        setScreenBBCode(screenBBcodeArray);
        setCanCopy(true);
        Jt.success($t$1("转存成功"));
      } catch (error) {
        const errorMessage = error instanceof Error ? error.message : $t$1("转存失败");
        Jt.error(errorMessage);
        console.error("截图转存失败:", error);
      } finally {
        setBtnText("转存截图");
        setBtnDisable(false);
      }
    }, [btnDisable, extractAndUploadImages, updateTorrentWithNewImages]);
    if (uploadImgClosed || CURRENT_SITE_NAME === "BTN") {
      return null;
    }
    return /* @__PURE__ */ u$1("div", { className: "function-list-item", children: /* @__PURE__ */ u$1("div", { className: "upload-section", children: [
      /* @__PURE__ */ u$1(
        "button",
        {
          disabled: btnDisable,
          className: btnDisable ? "is-disabled" : "",
          onClick: handleUploadScreenshots,
          children: $t$1(btnText)
        }
      ),
      /* @__PURE__ */ u$1(
        "select",
        {
          value: selectHost,
          onChange: (e2) => setSelectHost(e2.target.value),
          disabled: btnDisable,
          children: Object.entries(IMAGE_HOSTS).map(([key, host]) => /* @__PURE__ */ u$1("option", { value: key, children: host.name }, key))
        }
      ),
      canCopy && /* @__PURE__ */ u$1("button", { className: "copy-img", onClick: handleCopyBBCode, children: $t$1(copyText) })
    ] }) });
  };
  const FunctionList = () => {
    return /* @__PURE__ */ u$1("section", { className: "easy-upload-function-list", children: [
      /* @__PURE__ */ u$1(Douban, {}),
      /* @__PURE__ */ u$1(Transfer, {}),
      /* @__PURE__ */ u$1(UploadImg, {})
    ] });
  };
  const SearchList = () => {
    const searchListSetting = GM_getValue(
      "easy-upload.enabled-search-site-list",
      []
    );
    const siteFaviconClosed = GM_getValue(
      "easy-upload.site-favicon-closed",
      false
    );
    const handleSearchClick = q$1((siteName) => {
      const attrUrl = $$2(`.search-list li>a[data-site="${siteName}"]`).data("url");
      const openUrl = attrUrl || getQuickSearchUrl(siteName);
      GM_openInTab(openUrl);
    }, []);
    const searchSites = T$1(() => {
      const commonSites = [];
      const subtitlesSites = [];
      SORTED_SITE_KEYS.forEach((siteName) => {
        const siteInfo = PT_SITE[siteName];
        if (!siteInfo.search) return;
        const isEnabled = searchListSetting.length === 0 || searchListSetting.includes(siteName);
        if (isEnabled) {
          if (siteInfo.siteType === "subtitles") {
            subtitlesSites.push(siteName);
          } else {
            commonSites.push(siteName);
          }
        }
      });
      return { commonSites, subtitlesSites };
    }, [searchListSetting]);
    const handleBatchSearch = q$1(() => {
      const { commonSites, subtitlesSites } = searchSites;
      [...commonSites, ...subtitlesSites].forEach((site) => {
        handleSearchClick(site);
      });
    }, [handleSearchClick, searchSites]);
    const renderSiteList = q$1(
      (category, showBatchSearch = false) => {
        const sites = searchSites[category];
        if (sites.length === 0) return null;
        return /* @__PURE__ */ u$1("ul", { className: "search-list", children: [
          sites.map((siteName) => {
            const siteInfo = PT_SITE[siteName];
            const showIcon = !siteFaviconClosed && siteInfo.icon;
            return /* @__PURE__ */ u$1("li", { children: [
              /* @__PURE__ */ u$1(
                "a",
                {
                  "data-site": siteName,
                  onClick: () => handleSearchClick(siteName),
                  children: [
                    showIcon && /* @__PURE__ */ u$1(
                      "img",
                      {
                        src: siteInfo.icon,
                        className: "site-icon",
                        alt: `${siteName} icon`
                      }
                    ),
                    siteName
                  ]
                }
              ),
              /* @__PURE__ */ u$1("span", { children: "|" })
            ] }, siteName);
          }),
          showBatchSearch && /* @__PURE__ */ u$1(
            "li",
            {
              id: "batch-search-btn",
              onClick: handleBatchSearch,
              title: $t$1("同时打开多个搜索标签页"),
              children: $t$1("批量检索")
            }
          )
        ] });
      },
      [searchSites, siteFaviconClosed, handleSearchClick, handleBatchSearch]
    );
    const hasSites = searchSites.commonSites.length > 0 || searchSites.subtitlesSites.length > 0;
    if (!hasSites) return null;
    return /* @__PURE__ */ u$1("div", { className: "search-lists-container", children: [
      renderSiteList("commonSites", true),
      renderSiteList("subtitlesSites")
    ] });
  };
  /* Common package for dealing with hex/string/uint8 conversions (and sha1 hashing)
  *
  * @author   Jimmy Wärting <jimmy@warting.se> (https://jimmy.warting.se/opensource)
  * @license  MIT
  */
  const alphabet = "0123456789abcdef";
  const encodeLookup = [];
  const decodeLookup = [];
  for (let i = 0; i < 256; i++) {
    encodeLookup[i] = alphabet[i >> 4 & 15] + alphabet[i & 15];
    if (i < 16) {
      if (i < 10) {
        decodeLookup[48 + i] = i;
      } else {
        decodeLookup[97 - 10 + i] = i;
      }
    }
  }
  const arr2hex = (data) => {
    const length = data.length;
    let string2 = "";
    let i = 0;
    while (i < length) {
      string2 += encodeLookup[data[i++]];
    }
    return string2;
  };
  const hex2arr = (str) => {
    const sizeof = str.length >> 1;
    const length = sizeof << 1;
    const array = new Uint8Array(sizeof);
    let n = 0;
    let i = 0;
    while (i < length) {
      array[n++] = decodeLookup[str.charCodeAt(i++)] << 4 | decodeLookup[str.charCodeAt(i++)];
    }
    return array;
  };
  const concat = (chunks, size = 0) => {
    const length = chunks.length || 0;
    if (!size) {
      let i2 = length;
      while (i2--) size += chunks[i2].length;
    }
    const b = new Uint8Array(size);
    let offset = size;
    let i = length;
    while (i--) {
      offset -= chunks[i].length;
      b.set(chunks[i], offset);
    }
    return b;
  };
  var chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  var lookup = typeof Uint8Array === "undefined" ? [] : new Uint8Array(256);
  for (var i = 0; i < chars.length; i++) {
    lookup[chars.charCodeAt(i)] = i;
  }
  var encode$1 = function(arraybuffer) {
    var bytes = new Uint8Array(arraybuffer), i, len = bytes.length, base64 = "";
    for (i = 0; i < len; i += 3) {
      base64 += chars[bytes[i] >> 2];
      base64 += chars[(bytes[i] & 3) << 4 | bytes[i + 1] >> 4];
      base64 += chars[(bytes[i + 1] & 15) << 2 | bytes[i + 2] >> 6];
      base64 += chars[bytes[i + 2] & 63];
    }
    if (len % 3 === 2) {
      base64 = base64.substring(0, base64.length - 1) + "=";
    } else if (len % 3 === 1) {
      base64 = base64.substring(0, base64.length - 2) + "==";
    }
    return base64;
  };
  const decoder = new TextDecoder();
  const arr2text = (data, enc) => {
    return decoder.decode(data);
  };
  const encoder = new TextEncoder();
  const text2arr = (str) => encoder.encode(str);
  const arr2base = (data) => encode$1(data);
  const scope = typeof window !== "undefined" ? window : self;
  const crypto = scope.crypto || scope.msCrypto || {};
  const subtle = crypto.subtle || crypto.webkitSubtle;
  const formatMap = {
    hex: arr2hex,
    base64: arr2base
  };
  const hash = async (data, format2, algo = "sha-1") => {
    if (!subtle) throw new Error("no web crypto support");
    if (typeof data === "string") data = text2arr(data);
    const out = new Uint8Array(await subtle.digest(algo, data));
    return format2 ? formatMap[format2](out) : out;
  };
  function digitCount(value) {
    const sign = value < 0 ? 1 : 0;
    value = Math.abs(Number(value || 1));
    return Math.floor(Math.log10(value)) + 1 + sign;
  }
  function getType(value) {
    if (ArrayBuffer.isView(value)) return "arraybufferview";
    if (Array.isArray(value)) return "array";
    if (value instanceof Number) return "number";
    if (value instanceof Boolean) return "boolean";
    if (value instanceof Set) return "set";
    if (value instanceof Map) return "map";
    if (value instanceof String) return "string";
    if (value instanceof ArrayBuffer) return "arraybuffer";
    return typeof value;
  }
  function encode(data, buffer2, offset) {
    const buffers = [];
    let result = null;
    encode._encode(buffers, data);
    result = concat(buffers);
    encode.bytes = result.length;
    if (ArrayBuffer.isView(buffer2)) {
      buffer2.set(result, offset);
      return buffer2;
    }
    return result;
  }
  encode.bytes = -1;
  encode._floatConversionDetected = false;
  encode._encode = function(buffers, data) {
    if (data == null) {
      return;
    }
    switch (getType(data)) {
      case "object":
        encode.dict(buffers, data);
        break;
      case "map":
        encode.dictMap(buffers, data);
        break;
      case "array":
        encode.list(buffers, data);
        break;
      case "set":
        encode.listSet(buffers, data);
        break;
      case "string":
        encode.string(buffers, data);
        break;
      case "number":
        encode.number(buffers, data);
        break;
      case "boolean":
        encode.number(buffers, data);
        break;
      case "arraybufferview":
        encode.buffer(buffers, new Uint8Array(data.buffer, data.byteOffset, data.byteLength));
        break;
      case "arraybuffer":
        encode.buffer(buffers, new Uint8Array(data));
        break;
    }
  };
  const buffE = new Uint8Array([101]);
  const buffD = new Uint8Array([100]);
  const buffL = new Uint8Array([108]);
  encode.buffer = function(buffers, data) {
    buffers.push(text2arr(data.length + ":"), data);
  };
  encode.string = function(buffers, data) {
    buffers.push(text2arr(text2arr(data).byteLength + ":" + data));
  };
  encode.number = function(buffers, data) {
    if (Number.isInteger(data)) return buffers.push(text2arr("i" + BigInt(data) + "e"));
    const maxLo = 2147483648;
    const hi = data / maxLo << 0;
    const lo = data % maxLo << 0;
    const val = hi * maxLo + lo;
    buffers.push(text2arr("i" + val + "e"));
    if (val !== data && !encode._floatConversionDetected) {
      encode._floatConversionDetected = true;
      console.warn(
        'WARNING: Possible data corruption detected with value "' + data + '":',
        'Bencoding only defines support for integers, value was converted to "' + val + '"'
      );
      console.trace();
    }
  };
  encode.dict = function(buffers, data) {
    buffers.push(buffD);
    let j2 = 0;
    let k2;
    const keys = Object.keys(data).sort();
    const kl = keys.length;
    for (; j2 < kl; j2++) {
      k2 = keys[j2];
      if (data[k2] == null) continue;
      encode.string(buffers, k2);
      encode._encode(buffers, data[k2]);
    }
    buffers.push(buffE);
  };
  encode.dictMap = function(buffers, data) {
    buffers.push(buffD);
    const keys = Array.from(data.keys()).sort();
    for (const key of keys) {
      if (data.get(key) == null) continue;
      ArrayBuffer.isView(key) ? encode._encode(buffers, key) : encode.string(buffers, String(key));
      encode._encode(buffers, data.get(key));
    }
    buffers.push(buffE);
  };
  encode.list = function(buffers, data) {
    let i = 0;
    const c2 = data.length;
    buffers.push(buffL);
    for (; i < c2; i++) {
      if (data[i] == null) continue;
      encode._encode(buffers, data[i]);
    }
    buffers.push(buffE);
  };
  encode.listSet = function(buffers, data) {
    buffers.push(buffL);
    for (const item of data) {
      if (item == null) continue;
      encode._encode(buffers, item);
    }
    buffers.push(buffE);
  };
  const INTEGER_START = 105;
  const STRING_DELIM = 58;
  const DICTIONARY_START = 100;
  const LIST_START = 108;
  const END_OF_TYPE = 101;
  function getIntFromBuffer(buffer2, start, end) {
    let sum = 0;
    let sign = 1;
    for (let i = start; i < end; i++) {
      const num = buffer2[i];
      if (num < 58 && num >= 48) {
        sum = sum * 10 + (num - 48);
        continue;
      }
      if (i === start && num === 43) {
        continue;
      }
      if (i === start && num === 45) {
        sign = -1;
        continue;
      }
      if (num === 46) {
        break;
      }
      throw new Error("not a number: buffer[" + i + "] = " + num);
    }
    return sum * sign;
  }
  function decode$1(data, start, end, encoding) {
    if (data == null || data.length === 0) {
      return null;
    }
    if (typeof start !== "number" && encoding == null) {
      encoding = start;
      start = void 0;
    }
    if (typeof end !== "number" && encoding == null) {
      encoding = end;
      end = void 0;
    }
    decode$1.position = 0;
    decode$1.encoding = encoding || null;
    decode$1.data = !ArrayBuffer.isView(data) ? text2arr(data) : new Uint8Array(data.slice(start, end));
    decode$1.bytes = decode$1.data.length;
    return decode$1.next();
  }
  decode$1.bytes = 0;
  decode$1.position = 0;
  decode$1.data = null;
  decode$1.encoding = null;
  decode$1.next = function() {
    switch (decode$1.data[decode$1.position]) {
      case DICTIONARY_START:
        return decode$1.dictionary();
      case LIST_START:
        return decode$1.list();
      case INTEGER_START:
        return decode$1.integer();
      default:
        return decode$1.buffer();
    }
  };
  decode$1.find = function(chr) {
    let i = decode$1.position;
    const c2 = decode$1.data.length;
    const d2 = decode$1.data;
    while (i < c2) {
      if (d2[i] === chr) return i;
      i++;
    }
    throw new Error(
      'Invalid data: Missing delimiter "' + String.fromCharCode(chr) + '" [0x' + chr.toString(16) + "]"
    );
  };
  decode$1.dictionary = function() {
    decode$1.position++;
    const dict = {};
    while (decode$1.data[decode$1.position] !== END_OF_TYPE) {
      const buffer2 = decode$1.buffer();
      let key = arr2text(buffer2);
      if (key.includes("�")) key = arr2hex(buffer2);
      dict[key] = decode$1.next();
    }
    decode$1.position++;
    return dict;
  };
  decode$1.list = function() {
    decode$1.position++;
    const lst = [];
    while (decode$1.data[decode$1.position] !== END_OF_TYPE) {
      lst.push(decode$1.next());
    }
    decode$1.position++;
    return lst;
  };
  decode$1.integer = function() {
    const end = decode$1.find(END_OF_TYPE);
    const number = getIntFromBuffer(decode$1.data, decode$1.position + 1, end);
    decode$1.position += end + 1 - decode$1.position;
    return number;
  };
  decode$1.buffer = function() {
    let sep = decode$1.find(STRING_DELIM);
    const length = getIntFromBuffer(decode$1.data, decode$1.position, sep);
    const end = ++sep + length;
    decode$1.position = end;
    return decode$1.encoding ? arr2text(decode$1.data.slice(sep, end)) : decode$1.data.slice(sep, end);
  };
  function listLength(list) {
    let length = 1 + 1;
    for (const value of list) {
      length += encodingLength$1(value);
    }
    return length;
  }
  function mapLength(map2) {
    let length = 1 + 1;
    for (const [key, value] of map2) {
      const keyLength = text2arr(key).byteLength;
      length += digitCount(keyLength) + 1 + keyLength;
      length += encodingLength$1(value);
    }
    return length;
  }
  function objectLength(value) {
    let length = 1 + 1;
    const keys = Object.keys(value);
    for (let i = 0; i < keys.length; i++) {
      const keyLength = text2arr(keys[i]).byteLength;
      length += digitCount(keyLength) + 1 + keyLength;
      length += encodingLength$1(value[keys[i]]);
    }
    return length;
  }
  function stringLength(value) {
    const length = text2arr(value).byteLength;
    return digitCount(length) + 1 + length;
  }
  function arrayBufferLength(value) {
    const length = value.byteLength - value.byteOffset;
    return digitCount(length) + 1 + length;
  }
  function encodingLength$1(value) {
    const length = 0;
    if (value == null) return length;
    const type = getType(value);
    switch (type) {
      case "arraybufferview":
        return arrayBufferLength(value);
      case "string":
        return stringLength(value);
      case "array":
      case "set":
        return listLength(value);
      case "number":
        return 1 + digitCount(Math.floor(value)) + 1;
      case "bigint":
        return 1 + value.toString().length + 1;
      case "object":
        return objectLength(value);
      case "map":
        return mapLength(value);
      default:
        throw new TypeError(`Unsupported value of type "${type}"`);
    }
  }
  const encodingLength = encodingLength$1;
  const bencode = { encode, decode: decode$1, byteLength: encodingLength$1, encodingLength };
  const byteTable = [
    255,
    255,
    26,
    27,
    28,
    29,
    30,
    31,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    12,
    13,
    14,
    15,
    16,
    17,
    18,
    19,
    20,
    21,
    22,
    23,
    24,
    25,
    255,
    255,
    255,
    255,
    255,
    255,
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    12,
    13,
    14,
    15,
    16,
    17,
    18,
    19,
    20,
    21,
    22,
    23,
    24,
    25,
    255,
    255,
    255,
    255,
    255
  ];
  const decode = function(encoded) {
    if (!ArrayBuffer.isView(encoded) && typeof encoded !== "string") {
      throw new TypeError("base32.decode only takes Buffer or string as parameter");
    }
    let shiftIndex = 0;
    let plainDigit = 0;
    let plainChar;
    let plainPos = 0;
    if (!ArrayBuffer.isView(encoded)) {
      encoded = text2arr(encoded);
    }
    const decoded = new Uint8Array(Math.ceil(encoded.length * 5 / 8));
    for (let i = 0; i < encoded.length; i++) {
      if (encoded[i] === 61) {
        break;
      }
      const encodedByte = encoded[i] - 48;
      if (encodedByte < byteTable.length) {
        plainDigit = byteTable[encodedByte];
        if (shiftIndex <= 3) {
          shiftIndex = (shiftIndex + 5) % 8;
          if (shiftIndex === 0) {
            plainChar |= plainDigit;
            decoded[plainPos] = plainChar;
            plainPos++;
            plainChar = 0;
          } else {
            plainChar |= 255 & plainDigit << 8 - shiftIndex;
          }
        } else {
          shiftIndex = (shiftIndex + 5) % 8;
          plainChar |= 255 & plainDigit >>> shiftIndex;
          decoded[plainPos] = plainChar;
          plainPos++;
          plainChar = 255 & plainDigit << 8 - shiftIndex;
        }
      } else {
        throw new Error("Invalid input - it is not base32 encoded string");
      }
    }
    return decoded.subarray(0, plainPos);
  };
  function parseRange(range) {
    const generateRange = (start, end = start) => Array.from({ length: end - start + 1 }, (cur, idx) => idx + start);
    return range.reduce((acc, cur, idx, arr) => {
      const r2 = cur.split("-").map((cur2) => parseInt(cur2));
      return acc.concat(generateRange(...r2));
    }, []);
  }
  /*! magnet-uri. MIT License. WebTorrent LLC <https://webtorrent.io/opensource> */
  function magnetURIDecode(uri) {
    const result = {};
    const data = uri.split("magnet:?")[1];
    const params = data && data.length >= 0 ? data.split("&") : [];
    params.forEach((param) => {
      const keyval = param.split("=");
      if (keyval.length !== 2) return;
      const key = keyval[0];
      let val = keyval[1];
      if (key === "dn") val = decodeURIComponent(val).replace(/\+/g, " ");
      if (key === "tr" || key === "xs" || key === "as" || key === "ws") {
        val = decodeURIComponent(val);
      }
      if (key === "kt") val = decodeURIComponent(val).split("+");
      if (key === "ix") val = Number(val);
      if (key === "so") val = parseRange(decodeURIComponent(val).split(","));
      if (result[key]) {
        if (!Array.isArray(result[key])) {
          result[key] = [result[key]];
        }
        result[key].push(val);
      } else {
        result[key] = val;
      }
    });
    let m2;
    if (result.xt) {
      const xts = Array.isArray(result.xt) ? result.xt : [result.xt];
      xts.forEach((xt) => {
        if (m2 = xt.match(/^urn:btih:(.{40})/)) {
          result.infoHash = m2[1].toLowerCase();
        } else if (m2 = xt.match(/^urn:btih:(.{32})/)) {
          result.infoHash = arr2hex(decode(m2[1]));
        } else if (m2 = xt.match(/^urn:btmh:1220(.{64})/)) {
          result.infoHashV2 = m2[1].toLowerCase();
        }
      });
    }
    if (result.xs) {
      const xss = Array.isArray(result.xs) ? result.xs : [result.xs];
      xss.forEach((xs) => {
        if (m2 = xs.match(/^urn:btpk:(.{64})/)) {
          result.publicKey = m2[1].toLowerCase();
        }
      });
    }
    if (result.infoHash) result.infoHashBuffer = hex2arr(result.infoHash);
    if (result.infoHashV2) result.infoHashV2Buffer = hex2arr(result.infoHashV2);
    if (result.publicKey) result.publicKeyBuffer = hex2arr(result.publicKey);
    if (result.dn) result.name = result.dn;
    if (result.kt) result.keywords = result.kt;
    result.announce = [];
    if (typeof result.tr === "string" || Array.isArray(result.tr)) {
      result.announce = result.announce.concat(result.tr);
    }
    result.urlList = [];
    if (typeof result.as === "string" || Array.isArray(result.as)) {
      result.urlList = result.urlList.concat(result.as);
    }
    if (typeof result.ws === "string" || Array.isArray(result.ws)) {
      result.urlList = result.urlList.concat(result.ws);
    }
    result.peerAddresses = [];
    if (typeof result["x.pe"] === "string" || Array.isArray(result["x.pe"])) {
      result.peerAddresses = result.peerAddresses.concat(result["x.pe"]);
    }
    result.announce = Array.from(new Set(result.announce));
    result.urlList = Array.from(new Set(result.urlList));
    result.peerAddresses = Array.from(new Set(result.peerAddresses));
    return result;
  }
  function assertPath(path2) {
    if (typeof path2 !== "string") {
      throw new TypeError("Path must be a string. Received " + JSON.stringify(path2));
    }
  }
  function normalizeStringPosix(path2, allowAboveRoot) {
    var res = "";
    var lastSegmentLength = 0;
    var lastSlash = -1;
    var dots = 0;
    var code2;
    for (var i = 0; i <= path2.length; ++i) {
      if (i < path2.length)
        code2 = path2.charCodeAt(i);
      else if (code2 === 47)
        break;
      else
        code2 = 47;
      if (code2 === 47) {
        if (lastSlash === i - 1 || dots === 1) ;
        else if (lastSlash !== i - 1 && dots === 2) {
          if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 || res.charCodeAt(res.length - 2) !== 46) {
            if (res.length > 2) {
              var lastSlashIndex = res.lastIndexOf("/");
              if (lastSlashIndex !== res.length - 1) {
                if (lastSlashIndex === -1) {
                  res = "";
                  lastSegmentLength = 0;
                } else {
                  res = res.slice(0, lastSlashIndex);
                  lastSegmentLength = res.length - 1 - res.lastIndexOf("/");
                }
                lastSlash = i;
                dots = 0;
                continue;
              }
            } else if (res.length === 2 || res.length === 1) {
              res = "";
              lastSegmentLength = 0;
              lastSlash = i;
              dots = 0;
              continue;
            }
          }
          if (allowAboveRoot) {
            if (res.length > 0)
              res += "/..";
            else
              res = "..";
            lastSegmentLength = 2;
          }
        } else {
          if (res.length > 0)
            res += "/" + path2.slice(lastSlash + 1, i);
          else
            res = path2.slice(lastSlash + 1, i);
          lastSegmentLength = i - lastSlash - 1;
        }
        lastSlash = i;
        dots = 0;
      } else if (code2 === 46 && dots !== -1) {
        ++dots;
      } else {
        dots = -1;
      }
    }
    return res;
  }
  function _format(sep, pathObject) {
    var dir = pathObject.dir || pathObject.root;
    var base = pathObject.base || (pathObject.name || "") + (pathObject.ext || "");
    if (!dir) {
      return base;
    }
    if (dir === pathObject.root) {
      return dir + base;
    }
    return dir + sep + base;
  }
  var posix = {
    // path.resolve([from ...], to)
    resolve: function resolve27() {
      var resolvedPath = "";
      var resolvedAbsolute = false;
      var cwd;
      for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
        var path2;
        if (i >= 0)
          path2 = arguments[i];
        else {
          if (cwd === void 0)
            cwd = process.cwd();
          path2 = cwd;
        }
        assertPath(path2);
        if (path2.length === 0) {
          continue;
        }
        resolvedPath = path2 + "/" + resolvedPath;
        resolvedAbsolute = path2.charCodeAt(0) === 47;
      }
      resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute);
      if (resolvedAbsolute) {
        if (resolvedPath.length > 0)
          return "/" + resolvedPath;
        else
          return "/";
      } else if (resolvedPath.length > 0) {
        return resolvedPath;
      } else {
        return ".";
      }
    },
    normalize: function normalize(path2) {
      assertPath(path2);
      if (path2.length === 0) return ".";
      var isAbsolute2 = path2.charCodeAt(0) === 47;
      var trailingSeparator = path2.charCodeAt(path2.length - 1) === 47;
      path2 = normalizeStringPosix(path2, !isAbsolute2);
      if (path2.length === 0 && !isAbsolute2) path2 = ".";
      if (path2.length > 0 && trailingSeparator) path2 += "/";
      if (isAbsolute2) return "/" + path2;
      return path2;
    },
    isAbsolute: function isAbsolute(path2) {
      assertPath(path2);
      return path2.length > 0 && path2.charCodeAt(0) === 47;
    },
    join: function join() {
      if (arguments.length === 0)
        return ".";
      var joined;
      for (var i = 0; i < arguments.length; ++i) {
        var arg = arguments[i];
        assertPath(arg);
        if (arg.length > 0) {
          if (joined === void 0)
            joined = arg;
          else
            joined += "/" + arg;
        }
      }
      if (joined === void 0)
        return ".";
      return posix.normalize(joined);
    },
    relative: function relative(from, to) {
      assertPath(from);
      assertPath(to);
      if (from === to) return "";
      from = posix.resolve(from);
      to = posix.resolve(to);
      if (from === to) return "";
      var fromStart = 1;
      for (; fromStart < from.length; ++fromStart) {
        if (from.charCodeAt(fromStart) !== 47)
          break;
      }
      var fromEnd = from.length;
      var fromLen = fromEnd - fromStart;
      var toStart = 1;
      for (; toStart < to.length; ++toStart) {
        if (to.charCodeAt(toStart) !== 47)
          break;
      }
      var toEnd = to.length;
      var toLen = toEnd - toStart;
      var length = fromLen < toLen ? fromLen : toLen;
      var lastCommonSep = -1;
      var i = 0;
      for (; i <= length; ++i) {
        if (i === length) {
          if (toLen > length) {
            if (to.charCodeAt(toStart + i) === 47) {
              return to.slice(toStart + i + 1);
            } else if (i === 0) {
              return to.slice(toStart + i);
            }
          } else if (fromLen > length) {
            if (from.charCodeAt(fromStart + i) === 47) {
              lastCommonSep = i;
            } else if (i === 0) {
              lastCommonSep = 0;
            }
          }
          break;
        }
        var fromCode = from.charCodeAt(fromStart + i);
        var toCode = to.charCodeAt(toStart + i);
        if (fromCode !== toCode)
          break;
        else if (fromCode === 47)
          lastCommonSep = i;
      }
      var out = "";
      for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {
        if (i === fromEnd || from.charCodeAt(i) === 47) {
          if (out.length === 0)
            out += "..";
          else
            out += "/..";
        }
      }
      if (out.length > 0)
        return out + to.slice(toStart + lastCommonSep);
      else {
        toStart += lastCommonSep;
        if (to.charCodeAt(toStart) === 47)
          ++toStart;
        return to.slice(toStart);
      }
    },
    _makeLong: function _makeLong(path2) {
      return path2;
    },
    dirname: function dirname(path2) {
      assertPath(path2);
      if (path2.length === 0) return ".";
      var code2 = path2.charCodeAt(0);
      var hasRoot = code2 === 47;
      var end = -1;
      var matchedSlash = true;
      for (var i = path2.length - 1; i >= 1; --i) {
        code2 = path2.charCodeAt(i);
        if (code2 === 47) {
          if (!matchedSlash) {
            end = i;
            break;
          }
        } else {
          matchedSlash = false;
        }
      }
      if (end === -1) return hasRoot ? "/" : ".";
      if (hasRoot && end === 1) return "//";
      return path2.slice(0, end);
    },
    basename: function basename(path2, ext) {
      if (ext !== void 0 && typeof ext !== "string") throw new TypeError('"ext" argument must be a string');
      assertPath(path2);
      var start = 0;
      var end = -1;
      var matchedSlash = true;
      var i;
      if (ext !== void 0 && ext.length > 0 && ext.length <= path2.length) {
        if (ext.length === path2.length && ext === path2) return "";
        var extIdx = ext.length - 1;
        var firstNonSlashEnd = -1;
        for (i = path2.length - 1; i >= 0; --i) {
          var code2 = path2.charCodeAt(i);
          if (code2 === 47) {
            if (!matchedSlash) {
              start = i + 1;
              break;
            }
          } else {
            if (firstNonSlashEnd === -1) {
              matchedSlash = false;
              firstNonSlashEnd = i + 1;
            }
            if (extIdx >= 0) {
              if (code2 === ext.charCodeAt(extIdx)) {
                if (--extIdx === -1) {
                  end = i;
                }
              } else {
                extIdx = -1;
                end = firstNonSlashEnd;
              }
            }
          }
        }
        if (start === end) end = firstNonSlashEnd;
        else if (end === -1) end = path2.length;
        return path2.slice(start, end);
      } else {
        for (i = path2.length - 1; i >= 0; --i) {
          if (path2.charCodeAt(i) === 47) {
            if (!matchedSlash) {
              start = i + 1;
              break;
            }
          } else if (end === -1) {
            matchedSlash = false;
            end = i + 1;
          }
        }
        if (end === -1) return "";
        return path2.slice(start, end);
      }
    },
    extname: function extname(path2) {
      assertPath(path2);
      var startDot = -1;
      var startPart = 0;
      var end = -1;
      var matchedSlash = true;
      var preDotState = 0;
      for (var i = path2.length - 1; i >= 0; --i) {
        var code2 = path2.charCodeAt(i);
        if (code2 === 47) {
          if (!matchedSlash) {
            startPart = i + 1;
            break;
          }
          continue;
        }
        if (end === -1) {
          matchedSlash = false;
          end = i + 1;
        }
        if (code2 === 46) {
          if (startDot === -1)
            startDot = i;
          else if (preDotState !== 1)
            preDotState = 1;
        } else if (startDot !== -1) {
          preDotState = -1;
        }
      }
      if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot
      preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
      preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        return "";
      }
      return path2.slice(startDot, end);
    },
    format: function format(pathObject) {
      if (pathObject === null || typeof pathObject !== "object") {
        throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof pathObject);
      }
      return _format("/", pathObject);
    },
    parse: function parse2(path2) {
      assertPath(path2);
      var ret = { root: "", dir: "", base: "", ext: "", name: "" };
      if (path2.length === 0) return ret;
      var code2 = path2.charCodeAt(0);
      var isAbsolute2 = code2 === 47;
      var start;
      if (isAbsolute2) {
        ret.root = "/";
        start = 1;
      } else {
        start = 0;
      }
      var startDot = -1;
      var startPart = 0;
      var end = -1;
      var matchedSlash = true;
      var i = path2.length - 1;
      var preDotState = 0;
      for (; i >= start; --i) {
        code2 = path2.charCodeAt(i);
        if (code2 === 47) {
          if (!matchedSlash) {
            startPart = i + 1;
            break;
          }
          continue;
        }
        if (end === -1) {
          matchedSlash = false;
          end = i + 1;
        }
        if (code2 === 46) {
          if (startDot === -1) startDot = i;
          else if (preDotState !== 1) preDotState = 1;
        } else if (startDot !== -1) {
          preDotState = -1;
        }
      }
      if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot
      preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
      preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        if (end !== -1) {
          if (startPart === 0 && isAbsolute2) ret.base = ret.name = path2.slice(1, end);
          else ret.base = ret.name = path2.slice(startPart, end);
        }
      } else {
        if (startPart === 0 && isAbsolute2) {
          ret.name = path2.slice(1, startDot);
          ret.base = path2.slice(1, end);
        } else {
          ret.name = path2.slice(startPart, startDot);
          ret.base = path2.slice(startPart, end);
        }
        ret.ext = path2.slice(startDot, end);
      }
      if (startPart > 0) ret.dir = path2.slice(0, startPart - 1);
      else if (isAbsolute2) ret.dir = "/";
      return ret;
    },
    sep: "/",
    delimiter: ":",
    win32: null,
    posix: null
  };
  posix.posix = posix;
  var pathBrowserify = posix;
  const path = /* @__PURE__ */ getDefaultExportFromCjs(pathBrowserify);
  /*! queue-microtask. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
  let promise;
  typeof queueMicrotask === "function" ? queueMicrotask.bind(typeof window !== "undefined" ? window : commonjsGlobal) : (cb) => (promise || (promise = Promise.resolve())).then(cb).catch((err) => setTimeout(() => {
    throw err;
  }, 0));
  /*! parse-torrent. MIT License. WebTorrent LLC <https://webtorrent.io/opensource> */
  async function parseTorrent(torrentId) {
    if (typeof torrentId === "string" && /^(stream-)?magnet:/.test(torrentId)) {
      const torrentObj = magnetURIDecode(torrentId);
      if (!torrentObj.infoHash) {
        throw new Error("Invalid torrent identifier");
      }
      return torrentObj;
    } else if (typeof torrentId === "string" && (/^[a-f0-9]{40}$/i.test(torrentId) || /^[a-z2-7]{32}$/i.test(torrentId))) {
      return magnetURIDecode(`magnet:?xt=urn:btih:${torrentId}`);
    } else if (ArrayBuffer.isView(torrentId) && torrentId.length === 20) {
      return magnetURIDecode(`magnet:?xt=urn:btih:${arr2hex(torrentId)}`);
    } else if (ArrayBuffer.isView(torrentId)) {
      return await decodeTorrentFile(torrentId);
    } else if (torrentId && torrentId.infoHash) {
      torrentId.infoHash = torrentId.infoHash.toLowerCase();
      if (!torrentId.announce) torrentId.announce = [];
      if (typeof torrentId.announce === "string") {
        torrentId.announce = [torrentId.announce];
      }
      if (!torrentId.urlList) torrentId.urlList = [];
      return torrentId;
    } else {
      throw new Error("Invalid torrent identifier");
    }
  }
  async function decodeTorrentFile(torrent) {
    if (ArrayBuffer.isView(torrent)) {
      torrent = bencode.decode(torrent);
    }
    ensure(torrent.info, "info");
    ensure(torrent.info["name.utf-8"] || torrent.info.name, "info.name");
    ensure(torrent.info["piece length"], "info['piece length']");
    ensure(torrent.info.pieces, "info.pieces");
    if (torrent.info.files) {
      torrent.info.files.forEach((file) => {
        ensure(typeof file.length === "number", "info.files[0].length");
        ensure(file["path.utf-8"] || file.path, "info.files[0].path");
      });
    } else {
      ensure(typeof torrent.info.length === "number", "info.length");
    }
    const result = {
      info: torrent.info,
      infoBuffer: bencode.encode(torrent.info),
      name: arr2text(torrent.info["name.utf-8"] || torrent.info.name),
      announce: []
    };
    result.infoHashBuffer = await hash(result.infoBuffer);
    result.infoHash = arr2hex(result.infoHashBuffer);
    if (torrent.info.private !== void 0) result.private = !!torrent.info.private;
    if (torrent["creation date"]) result.created = new Date(torrent["creation date"] * 1e3);
    if (torrent["created by"]) result.createdBy = arr2text(torrent["created by"]);
    if (ArrayBuffer.isView(torrent.comment)) result.comment = arr2text(torrent.comment);
    if (Array.isArray(torrent["announce-list"]) && torrent["announce-list"].length > 0) {
      torrent["announce-list"].forEach((urls) => {
        urls.forEach((url) => {
          result.announce.push(arr2text(url));
        });
      });
    } else if (torrent.announce) {
      result.announce.push(arr2text(torrent.announce));
    }
    if (ArrayBuffer.isView(torrent["url-list"])) {
      torrent["url-list"] = torrent["url-list"].length > 0 ? [torrent["url-list"]] : [];
    }
    result.urlList = (torrent["url-list"] || []).map((url) => arr2text(url));
    result.announce = Array.from(new Set(result.announce));
    result.urlList = Array.from(new Set(result.urlList));
    const files = torrent.info.files || [torrent.info];
    result.files = files.map((file, i) => {
      const parts = [].concat(result.name, file["path.utf-8"] || file.path || []).map((p2) => ArrayBuffer.isView(p2) ? arr2text(p2) : p2);
      return {
        path: path.join.apply(null, [path.sep].concat(parts)).slice(1),
        name: parts[parts.length - 1],
        length: file.length,
        offset: files.slice(0, i).reduce(sumLength, 0)
      };
    });
    result.length = files.reduce(sumLength, 0);
    const lastFile = result.files[result.files.length - 1];
    result.pieceLength = torrent.info["piece length"];
    result.lastPieceLength = (lastFile.offset + lastFile.length) % result.pieceLength || result.pieceLength;
    result.pieces = splitPieces(torrent.info.pieces);
    return result;
  }
  function encodeTorrentFile(parsed) {
    const torrent = {
      info: parsed.info
    };
    torrent["announce-list"] = (parsed.announce || []).map((url) => {
      if (!torrent.announce) torrent.announce = url;
      url = text2arr(url);
      return [url];
    });
    torrent["url-list"] = parsed.urlList || [];
    if (parsed.private !== void 0) {
      torrent.private = Number(parsed.private);
    }
    if (parsed.created) {
      torrent["creation date"] = parsed.created.getTime() / 1e3 | 0;
    }
    if (parsed.createdBy) {
      torrent["created by"] = parsed.createdBy;
    }
    return bencode.encode(torrent);
  }
  function sumLength(sum, file) {
    return sum + file.length;
  }
  function splitPieces(buf) {
    const pieces = [];
    for (let i = 0; i < buf.length; i += 20) {
      pieces.push(arr2hex(buf.slice(i, i + 20)));
    }
    return pieces;
  }
  function ensure(bool, fieldName) {
    if (!bool) throw new Error(`Torrent is missing required field: ${fieldName}`);
  }
  const blobToBase64 = (blob) => {
    return new Promise((resolve28, reject) => {
      const fileReader = new FileReader();
      fileReader.onload = (e2) => {
        var _a2;
        resolve28((_a2 = e2.target) == null ? void 0 : _a2.result);
      };
      fileReader.readAsDataURL(blob);
      fileReader.onerror = () => {
        reject(new Error("blobToBase64 error"));
      };
    });
  };
  const getTorrentFileData = async (selector = "", torrentLink = "", targetSiteName) => {
    var _a2;
    let downloadLink = torrentLink || $$2(selector).attr("href");
    if (!downloadLink) {
      console.warn("Failed to get torrent file download link");
      return null;
    }
    if (!downloadLink.startsWith("http") && !downloadLink.startsWith("/")) {
      downloadLink = `${CURRENT_SITE_INFO.url}/${downloadLink}`;
    } else if (downloadLink.startsWith("/")) {
      downloadLink = `${CURRENT_SITE_INFO.url}${downloadLink}`;
    }
    try {
      const file = await GMFetch(downloadLink, {
        method: "GET",
        responseType: "arraybuffer",
        timeout: 1e4
      });
      const result = await parseTorrent(buffer.Buffer.from(file));
      const siteInfo = PT_SITE[targetSiteName];
      const announceUrl = ((_a2 = siteInfo == null ? void 0 : siteInfo.torrent) == null ? void 0 : _a2.announce) || "tracker.com";
      const buf = encodeTorrentFile(__spreadProps(__spreadValues({}, result), {
        comment: "",
        announce: [announceUrl],
        info: __spreadProps(__spreadValues({}, result.info), {
          source: ""
        })
      }));
      const blob = new Blob([buf], { type: "application/x-bittorrent" });
      const base64 = await blobToBase64(blob);
      return base64;
    } catch (error) {
      Jt.error(`${$t$1("种子文件下载失败")} ${$t$1("请手动下载")}`);
      console.log(error);
      return "";
    }
  };
  const SITE_URL_PROCESSORS = {
    handleCommonSiteUrl: (url, category, sitePattern, categoryMap) => {
      if (url.match(sitePattern)) {
        const path2 = categoryMap[category] || "1";
        return url.replace(
          /\/upload\.php\?category=\d+/,
          `/upload.php?category=${path2}`
        );
      }
      return url;
    },
    handleUnit3dUrl: (url, category) => {
      if (url.match(/hdpost|blutopia|fearnopeer|asiancinema|monikadesign|lst/)) {
        const catMap = {
          movie: "1",
          tv: "2",
          tvPack: "2",
          documentary: "1"
        };
        const path2 = catMap[category] || "1";
        return url.replace(/\/upload\/\d+/, `/upload/${path2}`);
      }
      return url;
    },
    handleAitherUrl: (url, category) => {
      if (url.match(/aither/)) {
        const catMap = {
          movie: "1",
          tv: "2",
          tvPack: "2",
          documentary: "1",
          concert: "1",
          sport: "9",
          cartoon: "1",
          app: "10",
          ebook: "11",
          magazine: "11",
          audioBook: "14"
        };
        const path2 = catMap[category] || "1";
        return url.replace(/\/upload\/\d+/, `/upload/${path2}`);
      }
      return url;
    },
    handleBibliotikUrl: (url, category) => {
      if (url.match(/bibliotik/)) {
        const catMap = {
          ebook: "ebooks",
          magazine: "magazines",
          audioBook: "audiobooks"
        };
        const subPath = catMap[category] || "ebooks";
        return url.replace("/upload", `/upload/${subPath}`);
      }
      return url;
    },
    handleBYRUrl: (url, category) => {
      if (url.match(PT_SITE.BYR.host)) {
        const catMap = {
          movie: "408",
          tv: "401",
          tvPack: "401",
          documentary: "410",
          concert: "402",
          sport: "409",
          cartoon: "404",
          variety: "405"
        };
        const typeId = catMap[category];
        return typeId ? url.replace("/upload.php", `/upload.php?type=${typeId}&ckeditor=1`) : url;
      }
      return url;
    }
  };
  const getPTPGroupId = async (imdbUrl = "") => {
    var _a2;
    if (!imdbUrl) return "";
    try {
      const imdbId = getIdByIMDbUrl(imdbUrl);
      if (!imdbId) return "";
      const url = `${PT_SITE.PTP.url}/torrents.php?searchstr=${imdbId}&grouping=0&json=noredirect`;
      const data = await GMFetch(url, {
        responseType: "json"
      });
      if (((_a2 = data == null ? void 0 : data.Movies) == null ? void 0 : _a2.length) > 0) {
        return data.Movies[0].GroupId;
      }
    } catch (error) {
      console.error("fail to obtain ptp group id:", error);
    }
    return "";
  };
  const getGPWGroupId = async (imdbUrl = "") => {
    var _a2;
    if (!imdbUrl) return "";
    try {
      const imdbId = getIdByIMDbUrl(imdbUrl);
      if (!imdbId) return "";
      const url = `${PT_SITE.GPW.url}/upload.php?action=movie_info&imdbid=${imdbId}&check_only=1`;
      const data = await GMFetch(url, {
        responseType: "json"
      });
      if ((_a2 = data == null ? void 0 : data.response) == null ? void 0 : _a2.GroupID) {
        return data.response.GroupID;
      }
    } catch (error) {
      console.error("fail to obtain gpw group id:", error);
    }
    return "";
  };
  const UploadSiteList = () => {
    const { torrentInfo, updateTorrentInfo } = useTorrentInfo();
    const targetSitesEnabled = T$1(
      () => GM_getValue("easy-upload.enabled-target-sites", []),
      []
    );
    const siteFaviconClosed = T$1(
      () => GM_getValue("easy-upload.site-favicon-closed", false),
      []
    );
    const fetchTorrentData = q$1(
      async (siteName) => {
        if (torrentInfo.torrentData) return torrentInfo.torrentData;
        try {
          const torrentData = await getTorrentFileData(
            CURRENT_SITE_INFO.torrentDownloadLinkSelector,
            CURRENT_SITE_INFO.torrentLink,
            siteName
          );
          if (torrentData) {
            updateTorrentInfo({ torrentData });
            return torrentData;
          }
        } catch (error) {
          console.error("fail to fetch torrent file data:", error);
        }
        return null;
      },
      [torrentInfo.torrentData, updateTorrentInfo]
    );
    const processSiteUrl = q$1(
      async (baseUrl) => {
        if (!torrentInfo) return baseUrl;
        let url = baseUrl;
        const { category, imdbUrl } = torrentInfo;
        url = SITE_URL_PROCESSORS.handleUnit3dUrl(url, category);
        url = SITE_URL_PROCESSORS.handleAitherUrl(url, category);
        url = SITE_URL_PROCESSORS.handleBibliotikUrl(url, category);
        url = SITE_URL_PROCESSORS.handleBYRUrl(url, category);
        if (url.match(PT_SITE.PTP.host) && imdbUrl) {
          const groupId = await getPTPGroupId(imdbUrl);
          if (groupId) {
            url = url.replace(/(upload.php)/, `$1?groupid=${groupId}`);
          }
        }
        if (url.match(PT_SITE.GPW.host) && imdbUrl) {
          const groupId = await getGPWGroupId(imdbUrl);
          if (groupId) {
            url = url.replace(/(upload.php)/, `$1?groupid=${groupId}`);
          }
        }
        return `${url}#timestamp=${Date.now()}`;
      },
      [torrentInfo]
    );
    const handleSiteClick = q$1(
      async (baseUrl, siteName) => {
        try {
          if (!torrentInfo) {
            Jt.error($t$1("请先获取种子信息"));
            return false;
          }
          if (torrentInfo.isForbidden) {
            const result = window.confirm(
              $t$1("本种子可能禁止转载，确定要继续转载么？")
            );
            if (!result) return false;
          }
          await fetchTorrentData(siteName);
          const processedUrl = await processSiteUrl(baseUrl);
          GM_openInTab(processedUrl);
          return true;
        } catch (error) {
          console.error("处理站点点击失败:", error);
          Jt.error($t$1("打开上传页面失败"));
          return false;
        }
      },
      [torrentInfo, fetchTorrentData, processSiteUrl]
    );
    const handleBatchSeed = q$1(async () => {
      try {
        const batchSeedSetting = GM_getValue(
          "easy-upload.enabled-batch-seed-sites",
          []
        );
        if (batchSeedSetting.length === 0) {
          Jt.error($t$1("请先设置群转列表"));
          return;
        }
        if (!torrentInfo.torrentData) {
          await fetchTorrentData(batchSeedSetting[0]);
        }
        const sitesToOpen = SORTED_SITE_KEYS.filter((siteName) => {
          const siteInfo = PT_SITE[siteName];
          return siteInfo.asTarget && batchSeedSetting.includes(siteName);
        });
        for (const siteName of sitesToOpen) {
          const siteInfo = PT_SITE[siteName];
          const baseUrl = `${siteInfo.url}${siteInfo.uploadPath || ""}`;
          const processedUrl = await processSiteUrl(baseUrl);
          GM_openInTab(processedUrl);
          await new Promise((resolve28) => setTimeout(resolve28, 300));
        }
        Jt.success($t$1("转种页面已打开，请前往对应页面操作"));
      } catch (error) {
        console.error("批量转种失败:", error);
        Jt.error($t$1("批量转种失败"));
      }
    }, [torrentInfo, fetchTorrentData, processSiteUrl]);
    const renderSiteItem = q$1(
      (siteName) => {
        const siteInfo = PT_SITE[siteName];
        if (!siteInfo.asTarget) return null;
        const isEnabled = targetSitesEnabled.length === 0 || targetSitesEnabled.includes(siteName);
        if (!isEnabled) return null;
        const { url, uploadPath = "", icon = "" } = siteInfo;
        const baseUrl = `${url}${uploadPath}`;
        const showIcon = !siteFaviconClosed && icon;
        return /* @__PURE__ */ u$1("li", { children: [
          /* @__PURE__ */ u$1(
            "a",
            {
              className: "site-item",
              onClick: () => handleSiteClick(baseUrl, siteName),
              children: [
                showIcon && /* @__PURE__ */ u$1("img", { src: icon, className: "site-icon", alt: `${siteName} icon` }),
                siteName
              ]
            }
          ),
          /* @__PURE__ */ u$1("span", { children: "|" })
        ] }, siteName);
      },
      [handleSiteClick, targetSitesEnabled, siteFaviconClosed]
    );
    return /* @__PURE__ */ u$1("ul", { className: "site-list", children: [
      SORTED_SITE_KEYS.map((siteName) => renderSiteItem(siteName)),
      /* @__PURE__ */ u$1("li", { children: /* @__PURE__ */ u$1("button", { id: "batch-seed-btn", onClick: handleBatchSeed, children: $t$1("一键群转") }) })
    ] });
  };
  const SiteListConfig = [
    {
      name: "enabled-target-sites",
      class: "target-sites-enable-list",
      title: "转种站点启用",
      key: "targetEnabled"
    },
    {
      name: "enabled-search-site-list",
      class: "search-sites-enable-list",
      title: "站点搜索启用",
      key: "searchEnabled"
    },
    {
      name: "enabled-batch-seed-sites",
      class: "batch-seed-sites-enable-list",
      title: "批量转种启用",
      key: "batchEnabled",
      des: "一键批量转发到以下选中的站点"
    }
  ];
  const FeatureSwitchList = [
    {
      name: "quick-search-closed",
      des: "关闭快速检索",
      type: "checkbox",
      key: "quickSearchClosed"
    },
    {
      name: "transfer-img-closed",
      des: "关闭转缩略图功能",
      type: "checkbox",
      key: "transferImgClosed"
    },
    {
      name: "rehost-img-closed",
      des: "关闭转存图片功能",
      type: "checkbox",
      key: "rehostImgClosed"
    },
    {
      name: "site-favicon-closed",
      des: "关闭站点图标显示",
      type: "checkbox",
      key: "siteFaviconClosed"
    },
    {
      name: "thanks-quote-closed",
      des: "不显示致谢内容",
      type: "checkbox",
      key: "thanksQuoteClosed"
    },
    {
      name: "douban-closed",
      des: "不显示豆瓣按钮和豆瓣链接",
      type: "checkbox",
      key: "doubanClosed"
    }
  ];
  const SettingPanel = ({
    closePanel
  }) => {
    const [siteList, setSiteList] = h([]);
    const [featureList, setFeatureList] = h([]);
    const [ptpImgApiKey, setPtpImgApiKey] = h(
      GM_getValue("easy-upload.ptp-img-api-key", "")
    );
    y(() => {
      const targetSitesEnabled = GM_getValue(
        "easy-upload.enabled-target-sites",
        []
      );
      const batchSeedSiteEnabled = GM_getValue(
        "easy-upload.enabled-batch-seed-sites",
        []
      );
      const searchSitesEnabled = GM_getValue(
        "easy-upload.enabled-search-site-list",
        []
      );
      const initialSiteList = SORTED_SITE_KEYS.map((site) => ({
        site,
        targetEnabled: targetSitesEnabled.includes(site),
        batchEnabled: batchSeedSiteEnabled.includes(site),
        searchEnabled: searchSitesEnabled.includes(site)
      }));
      setSiteList(initialSiteList);
      const initialFeatureList = FeatureSwitchList.map((feature) => __spreadProps(__spreadValues({}, feature), {
        checked: GM_getValue(`easy-upload.${feature.name}`, false)
      }));
      setFeatureList(initialFeatureList);
    }, []);
    const saveSetting = q$1(() => {
      try {
        const targetSitesEnabled = [];
        const searchSitesEnabled = [];
        const batchSeedSiteEnabled = [];
        siteList.forEach(
          ({ site, targetEnabled, batchEnabled, searchEnabled }) => {
            if (targetEnabled) targetSitesEnabled.push(site);
            if (searchEnabled) searchSitesEnabled.push(site);
            if (batchEnabled) batchSeedSiteEnabled.push(site);
          }
        );
        GM_setValue("easy-upload.enabled-target-sites", targetSitesEnabled);
        GM_setValue("easy-upload.enabled-search-site-list", searchSitesEnabled);
        GM_setValue("easy-upload.enabled-batch-seed-sites", batchSeedSiteEnabled);
        GM_setValue("easy-upload.ptp-img-api-key", ptpImgApiKey);
        featureList.forEach((feature) => {
          GM_setValue(`easy-upload.${feature.name}`, !!feature.checked);
        });
        Jt.success($t$1("设置已保存，页面将重新加载"));
        setTimeout(() => window.location.reload(), 1e3);
      } catch (error) {
        console.error("保存设置失败:", error);
        Jt.error($t$1("保存本地站点设置失败"));
      }
    }, [siteList, featureList, ptpImgApiKey]);
    const handleSiteCheckChange = q$1(
      (key, index) => {
        setSiteList((prevList) => {
          const newList = [...prevList];
          newList[index] = __spreadProps(__spreadValues({}, newList[index]), {
            [key]: !newList[index][key]
          });
          return newList;
        });
      },
      []
    );
    const handleFeatureChange = q$1((index) => {
      setFeatureList((prevList) => {
        const newList = [...prevList];
        newList[index] = __spreadProps(__spreadValues({}, newList[index]), {
          checked: !newList[index].checked
        });
        return newList;
      });
    }, []);
    const renderSiteConfigSections = T$1(() => {
      return SiteListConfig.map((config) => /* @__PURE__ */ u$1("div", { children: [
        /* @__PURE__ */ u$1("h3", { children: $t$1(config.title) }),
        config.des && /* @__PURE__ */ u$1("p", { children: $t$1(config.des) }),
        /* @__PURE__ */ u$1("section", { className: "site-enable-setting", children: /* @__PURE__ */ u$1("ul", { className: config.class, children: siteList.map((siteInfo, index) => {
          const siteData = PT_SITE[siteInfo.site];
          const shouldRender = siteData.asTarget && config.key !== "searchEnabled" || config.key === "searchEnabled" && siteData.search;
          if (!shouldRender) return null;
          return /* @__PURE__ */ u$1("li", { children: /* @__PURE__ */ u$1("label", { children: [
            /* @__PURE__ */ u$1(
              "input",
              {
                onChange: () => handleSiteCheckChange(
                  config.key,
                  index
                ),
                name: "target-site-enabled",
                type: "checkbox",
                checked: siteInfo[config.key]
              }
            ),
            siteInfo.site
          ] }) }, siteInfo.site);
        }) }) })
      ] }, config.name));
    }, [siteList, handleSiteCheckChange]);
    const renderFeatureSwitches = T$1(() => {
      return /* @__PURE__ */ u$1("div", { className: "feature-list", children: featureList.map((feature, index) => /* @__PURE__ */ u$1("section", { className: "site-enable-setting", children: /* @__PURE__ */ u$1("label", { children: [
        /* @__PURE__ */ u$1(
          "input",
          {
            onChange: () => handleFeatureChange(index),
            name: feature.name,
            type: feature.type,
            checked: feature.checked
          }
        ),
        $t$1(feature.des)
      ] }) }, feature.name)) });
    }, [featureList, handleFeatureChange]);
    return /* @__PURE__ */ u$1("div", { className: "easy-upload-setting-panel", children: /* @__PURE__ */ u$1("div", { className: "panel-content-wrap", children: [
      /* @__PURE__ */ u$1("div", { className: "panel-content", children: [
        renderSiteConfigSections,
        /* @__PURE__ */ u$1("h3", { children: $t$1("图床配置") }),
        /* @__PURE__ */ u$1("section", { className: "site-enable-setting img-upload-setting", children: /* @__PURE__ */ u$1("label", { children: [
          "ptpimg ApiKey:",
          /* @__PURE__ */ u$1(
            "input",
            {
              name: "ptp-img-api-key",
              type: "text",
              value: ptpImgApiKey,
              onChange: (e2) => setPtpImgApiKey(e2.target.value)
            }
          ),
          /* @__PURE__ */ u$1(
            "a",
            {
              target: "_blank",
              href: "https://github.com/techmovie/easy-upload/wiki/%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96ptpimg%E7%9A%84apiKey",
              rel: "noreferrer",
              children: $t$1("如何获取？")
            }
          )
        ] }) }),
        /* @__PURE__ */ u$1("h3", { children: $t$1("额外功能关闭") }),
        renderFeatureSwitches
      ] }),
      /* @__PURE__ */ u$1("div", { className: "confirm-btns", children: [
        /* @__PURE__ */ u$1("button", { onClick: closePanel, children: $t$1("取消") }),
        /* @__PURE__ */ u$1("button", { onClick: saveSetting, className: "save-setting-btn", children: $t$1("保存") })
      ] })
    ] }) });
  };
  const HHLayout = ({
    children,
    quickSearchClosed = false
  }) => /* @__PURE__ */ u$1(preact.Fragment, { children: [
    /* @__PURE__ */ u$1("div", { class: "font-bold leading-6", children: children.title }),
    /* @__PURE__ */ u$1("div", { class: "font-bold leading-6", children: children.upload }),
    /* @__PURE__ */ u$1("div", { class: "font-bold leading-6", children: $t$1("快捷操作") }),
    /* @__PURE__ */ u$1("div", { class: "font-bold leading-6", children: children.functions }),
    !quickSearchClosed && /* @__PURE__ */ u$1(preact.Fragment, { children: [
      /* @__PURE__ */ u$1("div", { class: "font-bold leading-6", onClick: children.onSearchClick, children: $t$1("快速检索") }),
      /* @__PURE__ */ u$1("div", { class: "font-bold leading-6", children: children.search })
    ] })
  ] });
  const MTeamLayout = ({
    children,
    quickSearchClosed = false
  }) => /* @__PURE__ */ u$1(preact.Fragment, { children: [
    /* @__PURE__ */ u$1("tr", { class: "ant-descriptions-row", children: [
      /* @__PURE__ */ u$1(
        "th",
        {
          class: "ant-descriptions-item-label",
          colSpan: 1,
          style: "width: 135px; text-align: right;",
          children: /* @__PURE__ */ u$1("span", { children: /* @__PURE__ */ u$1("div", { class: "font-bold leading-6", children: children.title }) })
        }
      ),
      /* @__PURE__ */ u$1("td", { class: "ant-descriptions-item-content", colSpan: 1, children: children.upload })
    ] }),
    !quickSearchClosed && /* @__PURE__ */ u$1("tr", { class: "ant-descriptions-row", children: [
      /* @__PURE__ */ u$1(
        "th",
        {
          class: "ant-descriptions-item-label",
          colSpan: 1,
          style: "width: 135px; text-align: right;",
          children: /* @__PURE__ */ u$1("span", { children: /* @__PURE__ */ u$1("div", { class: "font-bold leading-6", onClick: children.onSearchClick, children: $t$1("快速检索") }) })
        }
      ),
      /* @__PURE__ */ u$1("td", { class: "ant-descriptions-item-content", colSpan: 1, children: children.search })
    ] })
  ] });
  const NexusPHPLayout = ({
    children,
    quickSearchClosed = false
  }) => {
    const baseTitleClass = ["title-td", "rowhead", "nowrap"];
    const baseContentClass = ["easy-upload-td", "rowfollow"];
    if (CURRENT_SITE_NAME === "HDT") {
      baseTitleClass.push("detailsleft");
      baseContentClass.push("detailshash");
    } else if (CURRENT_SITE_NAME === "HDSpace") {
      baseTitleClass.push("header");
      baseContentClass.push("lista");
    }
    return /* @__PURE__ */ u$1(preact.Fragment, { children: [
      /* @__PURE__ */ u$1("tr", { children: [
        /* @__PURE__ */ u$1("td", { className: baseTitleClass.join(" "), children: children.title }),
        /* @__PURE__ */ u$1("td", { className: baseContentClass.join(" "), children: /* @__PURE__ */ u$1(
          "div",
          {
            id: "seed-dom",
            className: BROWSER_LANGUAGE === "en" ? "use-eng" : "",
            children: children.upload
          }
        ) })
      ] }),
      /* @__PURE__ */ u$1("tr", { children: [
        /* @__PURE__ */ u$1("td", { className: baseTitleClass.join(" "), children: /* @__PURE__ */ u$1("h4", { children: $t$1("快捷操作") }) }),
        /* @__PURE__ */ u$1("td", { className: baseContentClass.join(" "), children: children.functions })
      ] }),
      !quickSearchClosed && /* @__PURE__ */ u$1("tr", { children: [
        /* @__PURE__ */ u$1("td", { className: baseTitleClass.join(" "), children: /* @__PURE__ */ u$1("h4", { className: "quick-search", onClick: children.onSearchClick, children: $t$1("快速检索") }) }),
        /* @__PURE__ */ u$1("td", { className: baseContentClass.join(" "), children: children.search })
      ] })
    ] });
  };
  const TikLayout = ({
    children,
    quickSearchClosed = false
  }) => /* @__PURE__ */ u$1(preact.Fragment, { children: [
    /* @__PURE__ */ u$1("tr", { children: [
      /* @__PURE__ */ u$1("td", { className: "rowhead", children: children.title }),
      /* @__PURE__ */ u$1("td", { children: children.upload })
    ] }),
    /* @__PURE__ */ u$1("tr", { children: [
      /* @__PURE__ */ u$1("td", { className: "rowhead", children: $t$1("快捷操作") }),
      /* @__PURE__ */ u$1("td", { children: children.functions })
    ] }),
    !quickSearchClosed && /* @__PURE__ */ u$1("tr", { children: [
      /* @__PURE__ */ u$1("td", { className: "rowhead", children: /* @__PURE__ */ u$1("h4", { className: "quick-search", onClick: children.onSearchClick, children: $t$1("快速检索") }) }),
      /* @__PURE__ */ u$1("td", { children: children.search })
    ] })
  ] });
  const SpeedAppLayout = ({
    children,
    quickSearchClosed = false
  }) => /* @__PURE__ */ u$1(preact.Fragment, { children: [
    /* @__PURE__ */ u$1("div", { className: "custom-site", children: [
      children.title,
      /* @__PURE__ */ u$1("div", { className: "easy-upload-td", style: { flexWrap: "wrap" }, children: /* @__PURE__ */ u$1(
        "div",
        {
          id: "seed-dom",
          className: BROWSER_LANGUAGE === "en" ? "use-eng" : "",
          children: children.upload
        }
      ) })
    ] }),
    /* @__PURE__ */ u$1("div", { className: "custom-site", children: [
      /* @__PURE__ */ u$1("h4", { children: $t$1("快捷操作") }),
      children.functions
    ] }),
    !quickSearchClosed && /* @__PURE__ */ u$1("div", { className: "custom-site", children: [
      /* @__PURE__ */ u$1("h4", { onClick: children.onSearchClick, children: $t$1("快速检索") }),
      /* @__PURE__ */ u$1("div", { children: children.search })
    ] })
  ] });
  const GazelleLayout = ({
    children,
    quickSearchClosed = false
  }) => /* @__PURE__ */ u$1(
    "div",
    {
      id: "seed-dom",
      className: [
        "movie-page__torrent__panel",
        BROWSER_LANGUAGE === "en" ? "use-eng" : ""
      ].join(" "),
      children: [
        /* @__PURE__ */ u$1("div", { className: "ptp-title-wrapper", children: [
          children.title,
          children.upload
        ] }),
        children.functions,
        /* @__PURE__ */ u$1("div", { class: "ptp-search-list", children: !quickSearchClosed && /* @__PURE__ */ u$1("div", { class: "ptp-title-wrapper", children: [
          /* @__PURE__ */ u$1("h4", { className: "quick-search", onClick: children.onSearchClick, children: $t$1("快速检索") }),
          children.search
        ] }) })
      ]
    }
  );
  const HDBLayout = ({
    children,
    quickSearchClosed = false
  }) => {
    const baseTitleClass = ["rowfollow", "hdb-td"];
    const baseContentClass = ["rowfollow", "hdb-td"];
    return /* @__PURE__ */ u$1(preact.Fragment, { children: [
      /* @__PURE__ */ u$1("tr", { class: "hdb-tr", children: [
        /* @__PURE__ */ u$1("td", { className: baseTitleClass.join(" "), children: children.title }),
        /* @__PURE__ */ u$1("td", { className: baseContentClass.join(" "), children: /* @__PURE__ */ u$1(
          "div",
          {
            id: "seed-dom",
            className: BROWSER_LANGUAGE === "en" ? "use-eng" : "",
            children: children.upload
          }
        ) })
      ] }),
      /* @__PURE__ */ u$1("tr", { class: "hdb-tr", children: [
        /* @__PURE__ */ u$1("td", { className: baseTitleClass.join(" "), children: /* @__PURE__ */ u$1("h4", { children: $t$1("快捷操作") }) }),
        /* @__PURE__ */ u$1("td", { className: baseContentClass.join(" "), children: children.functions })
      ] }),
      !quickSearchClosed && /* @__PURE__ */ u$1("tr", { class: "hdb-tr", children: [
        /* @__PURE__ */ u$1("td", { className: baseTitleClass.join(" "), children: /* @__PURE__ */ u$1("h4", { className: "quick-search", onClick: children.onSearchClick, children: $t$1("快速检索") }) }),
        /* @__PURE__ */ u$1("td", { className: baseContentClass.join(" "), children: children.search })
      ] })
    ] });
  };
  const SvgSetting = (_b, ref) => {
    var _c = _b, {
      title,
      titleId
    } = _c, props = __objRest(_c, [
      "title",
      "titleId"
    ]);
    return /* @__PURE__ */ preact.createElement("svg", __spreadValues({ t: 1638356346192, className: "icon", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", "p-id": 26515, xmlnsXlink: "http://www.w3.org/1999/xlink", width: 200, height: 200, ref, "aria-labelledby": titleId }, props), title ? /* @__PURE__ */ preact.createElement("title", { id: titleId }, title) : null, /* @__PURE__ */ preact.createElement("defs", null, /* @__PURE__ */ preact.createElement("style", { type: "text/css" })), /* @__PURE__ */ preact.createElement("path", { d: "M636.2112 847.7696c5.7344-42.5472 39.8848-76.7488 82.432-82.3808 20.1216-2.6624 39.2192 0.8704 55.6544 9.0112 32.5632 16.0768 72.3456 4.864 92.3136-25.3952 8.1408-12.3392 15.5648-25.1392 22.2208-38.4 16.6912-33.1264 4.8128-72.8064-25.7536-93.8496-1.4336-0.9728-2.816-1.9968-4.1984-3.072-34.2016-26.2656-46.848-73.216-30.2592-113.0496 7.7312-18.6368 20.3264-33.28 35.4816-43.4176 30.3104-20.2752 40.704-60.4672 24.2176-92.9792a383.37536 383.37536 0 0 0-19.3024-33.7408c-20.224-31.5392-60.4672-42.1376-94.5152-26.4192-1.536 0.7168-3.1232 1.3824-4.7616 2.048-39.936 15.9744-86.6304 2.9696-112.4864-31.4368-12.0832-16.0768-18.3296-34.304-19.4048-52.4288-2.1504-36.5056-31.6928-65.6896-68.1472-67.9936a388.59776 388.59776 0 0 0-47.9744-0.0512c-36.9152 2.2528-65.1776 32.2048-68.2496 69.0688-0.1536 1.6896-0.3072 3.3792-0.5632 5.0688-5.7344 42.3936-39.7312 76.4416-82.0736 82.2272-20.0192 2.7136-39.0656-0.7168-55.4496-8.704-32.5632-15.8208-72.192-4.5056-92.0064 25.7536a386.85184 386.85184 0 0 0-22.1696 38.5024c-16.5376 32.9728-4.864 72.3968 25.3952 93.5424 1.3824 0.9728 2.7648 1.9968 4.096 3.0208 33.6896 26.112 46.1312 72.3968 30.1056 111.872-7.6288 18.7904-20.1728 33.6384-35.3792 43.9296-29.952 20.2752-39.8848 60.2112-23.6032 92.4672 5.9392 11.7248 12.3904 23.0912 19.456 34.0992 20.0704 31.3856 59.9552 42.0352 93.9008 26.624 1.536-0.7168 3.1232-1.3824 4.7104-1.9968 39.68-15.6672 85.8624-2.7648 111.6672 31.232 12.288 16.2304 18.6368 34.6112 19.712 52.9408 2.0992 36.352 31.744 65.2288 68.096 67.6864 8.6016 0.5632 17.2544 0.8704 25.9584 0.8704 7.4752 0 14.8992-0.2048 22.3232-0.6656 36.8128-2.1504 65.024-32.1024 68.096-68.864 0.0512-1.6896 0.256-3.4304 0.4608-5.12z", fill: "#FFF7E6", "p-id": 26516 }), /* @__PURE__ */ preact.createElement("path", { d: "M515.7888 514.816m-127.7952 0a127.7952 127.7952 0 1 0 255.5904 0 127.7952 127.7952 0 1 0-255.5904 0Z", fill: "#FD973F", "p-id": 26517 }), /* @__PURE__ */ preact.createElement("path", { d: "M515.7888 668.2112c-84.5824 0-153.3952-68.8128-153.3952-153.3952 0-84.5824 68.8128-153.3952 153.3952-153.3952s153.3952 68.8128 153.3952 153.3952c-0.0512 84.5824-68.8128 153.3952-153.3952 153.3952z m0-255.5392c-56.32 0-102.1952 45.824-102.1952 102.1952s45.824 102.1952 102.1952 102.1952 102.1952-45.824 102.1952-102.1952-45.8752-102.1952-102.1952-102.1952zM886.1696 437.1968c-6.0416 0-12.0832-2.0992-16.9472-6.4a25.6 25.6 0 0 1-2.2016-36.1472c14.8992-16.8448 18.0736-41.5744 7.936-61.5424a388.5568 388.5568 0 0 0-20.224-35.328c-12.4416-19.4048-35.5328-29.0304-58.7776-24.576a25.60512 25.60512 0 0 1-29.952-20.3264 25.60512 25.60512 0 0 1 20.3264-29.952c43.9808-8.3968 87.7056 10.0864 111.5136 47.2064 8.2432 12.8 15.9232 26.2144 22.784 39.8336 19.5584 38.5536 13.4144 86.2208-15.2576 118.6304-5.12 5.6832-12.1344 8.6016-19.2 8.6016z", fill: "#44454A", "p-id": 26518 }), /* @__PURE__ */ preact.createElement("path", { d: "M515.7888 968.448c-10.1888 0-20.48-0.3584-30.6176-1.024-53.7088-3.6352-96.5632-46.3872-99.6352-99.4304-0.9216-16.1792-6.7584-31.6928-16.7936-44.9536-21.9136-28.8768-60.7744-39.7312-94.5152-26.4192-1.3824 0.512-2.7136 1.0752-3.9936 1.6896-50.1248 22.784-107.6224 6.2976-136.704-39.1168a459.9552 459.9552 0 0 1-22.9376-40.2432c-24.064-47.6672-9.1136-105.984 34.816-135.68 13.3632-9.0624 23.7568-21.9648 30.0032-37.3248 13.6192-33.536 3.1744-72.448-25.4976-94.72-1.1776-0.9216-2.3552-1.792-3.5328-2.6112-45.0048-31.4368-60.3648-88.8832-36.5056-136.5504 7.7824-15.5648 16.5888-30.8736 26.1632-45.4656 29.2352-44.6464 87.296-60.8256 135.0144-37.6832 14.4384 7.0144 30.72 9.5232 47.104 7.3216 35.9936-4.9152 64.5632-33.536 69.4784-69.632 0.2048-1.4336 0.3584-2.8672 0.4608-4.3008 4.6592-54.8864 46.6432-97.0752 99.9424-100.352 18.688-1.1264 37.8368-1.1264 56.6272 0.1024 53.76 3.4304 96.6656 46.336 99.7888 99.7888 0.9216 15.9744 6.656 31.3856 16.4864 44.544 14.4384 19.2 37.632 31.232 62.1568 32.2048 14.1312 0.5632 25.1392 12.4928 24.576 26.5728-0.5632 14.1312-12.6976 25.088-26.5728 24.576-40.2944-1.5872-77.1584-20.7872-101.0688-52.6848-15.9232-21.1968-25.1392-46.1824-26.6752-72.2432-1.6384-27.648-23.9616-49.8688-51.9168-51.6608-16.64-1.0752-33.6896-1.0752-50.2272-0.0512-27.6992 1.6896-49.6128 24.1664-52.0704 53.4528-0.2048 2.2528-0.4608 4.608-0.768 6.912-7.9872 58.8288-54.5792 105.472-113.3056 113.5104-26.4192 3.584-52.7872-0.5632-76.3904-11.9808-24.6272-11.9296-54.6816-3.5328-69.8368 19.6608a404.15744 404.15744 0 0 0-23.1936 40.2944c-12.3904 24.7808-3.9936 54.9376 20.0192 71.68 1.8944 1.3312 3.7888 2.7136 5.632 4.1472 46.6432 36.1984 63.744 99.7376 41.472 154.4192-10.0864 24.7808-26.9312 45.6704-48.7424 60.416-22.6304 15.3088-30.2592 45.5168-17.8176 70.2464 6.144 12.1856 13.0048 24.1664 20.3776 35.6864 15.2576 23.808 45.6704 32.256 72.3968 20.1728 2.0992-0.9216 4.2496-1.8432 6.4-2.7136 55.04-21.7088 118.3744-3.9936 154.112 43.1104 16.2304 21.4016 25.6 46.592 27.0848 72.96 1.5872 27.3408 23.9104 49.408 51.968 51.3024 16.6912 1.1264 33.6384 1.2288 50.5344 0.256 27.5456-1.5872 49.3056-24.0128 51.7632-53.248 0.2048-2.3552 0.4608-4.6592 0.768-6.9632 7.9872-59.136 54.784-105.8304 113.8176-113.664 26.5216-3.5328 53.0432 0.768 76.6464 12.4416 24.6272 12.1856 54.784 3.84 70.0416-19.4048 8.4992-12.9024 16.3328-26.4192 23.2448-40.192 12.544-24.8832 3.9936-55.1424-20.3264-71.8848-1.9456-1.3312-3.84-2.7136-5.7344-4.1984-47.5648-36.5568-64.7168-100.7104-41.728-155.9552a25.55904 25.55904 0 0 1 33.4848-13.7728 25.55904 25.55904 0 0 1 13.7728 33.4848c-13.8752 33.3824-3.1232 73.6256 25.6512 95.6928 1.1776 0.9216 2.3552 1.792 3.584 2.6112 45.6192 31.4368 61.184 89.1392 37.0176 137.1136-7.8336 15.5136-16.64 30.72-26.2144 45.312-29.4912 44.7488-87.7056 60.7232-135.4752 37.1712-14.4896-7.168-30.8736-9.7792-47.2576-7.5776-35.6352 4.7104-64.9728 34.048-69.7856 69.7344-0.2048 1.4848-0.3584 2.9696-0.4608 4.4032-4.5568 54.8352-46.5408 96.9728-99.7888 100.0448-8.7552 0.4096-17.6128 0.6656-26.3168 0.6656z", fill: "#44454A", "p-id": 26519 }));
  };
  const ForwardRef = w(SvgSetting);
  const SiteLayouts = {
    HH: HHLayout,
    MTeam: MTeamLayout,
    NexusPHP: NexusPHPLayout,
    Cinematik: TikLayout,
    SpeedApp: SpeedAppLayout,
    Gazelle: GazelleLayout,
    HDBits: HDBLayout
  };
  const Container = () => {
    const [settingPanelOpen, setSettingPanelOpen] = h(false);
    const siteType = useSiteConfig();
    const { checkQuickResult } = useQuickSearch();
    const handleSearchClick = () => {
      checkQuickResult();
    };
    const TitleBar = () => /* @__PURE__ */ u$1("h4", { children: [
      $t$1("一键转种"),
      /* @__PURE__ */ u$1(Te, { position: "top-right", richColors: true }),
      /* @__PURE__ */ u$1("span", { id: "easy-upload-setting", className: "easy-upload-setting-btn" }),
      /* @__PURE__ */ u$1(
        ForwardRef,
        {
          onClick: () => setSettingPanelOpen(true),
          className: "setting-svg"
        }
      )
    ] });
    const LayoutComponent = SiteLayouts[siteType] || SiteLayouts.NexusPHP;
    const quickSearchClosed = GM_getValue(
      "easy-upload.quick-search-closed",
      false
    );
    return /* @__PURE__ */ u$1(preact.Fragment, { children: [
      /* @__PURE__ */ u$1(LayoutComponent, { quickSearchClosed, children: {
        title: /* @__PURE__ */ u$1(TitleBar, {}),
        upload: /* @__PURE__ */ u$1(UploadSiteList, {}),
        functions: /* @__PURE__ */ u$1(FunctionList, {}),
        search: /* @__PURE__ */ u$1(SearchList, {}),
        onSearchClick: handleSearchClick
      } }),
      /* @__PURE__ */ u$1("div", { style: { display: settingPanelOpen ? "block" : "none" }, children: /* @__PURE__ */ u$1(SettingPanel, { closePanel: () => setSettingPanelOpen(false) }) })
    ] });
  };
  const SPECIAL_SITE_CONFIGS = {
    specialSiteNames: [
      "PTP",
      "BTN",
      "GPW",
      "RED",
      "DicMusic",
      "MTV",
      "Orpheus",
      "UHDBits"
    ],
    specialSelectors: {
      GPW: (torrentId) => `#torrent_detail_${torrentId} >td`,
      MTV: (torrentId) => `#torrentinfo${torrentId}>td`,
      GazelleDefault: (torrentId) => `#torrent_${torrentId} >td`
    },
    appendMethods: {
      UHDBits: (app) => {
        var _a2;
        const torrentId = getLocationSearchValueByKey("torrentid");
        $$2(`#torrent_${torrentId} >td`).prepend(
          document.createElement("blockquote")
        );
        (_a2 = $$2(`#torrent_${torrentId} >td blockquote:first`)) == null ? void 0 : _a2.prepend(app);
      },
      GazelleDefault: (app, refNode) => {
        refNode == null ? void 0 : refNode.prepend(app);
      },
      SpeedApp: (app, refNode) => {
        var _a2;
        const div = document.createElement("div");
        div.setAttribute("class", "row col-md-12 mt-5");
        app.setAttribute("class", "card-body card");
        div.appendChild(app);
        (_a2 = refNode == null ? void 0 : refNode.parentNode) == null ? void 0 : _a2.insertBefore(div, refNode);
      },
      MTeam: (app) => {
        setupMTeamObserver(app);
      },
      default: (app, refNode) => {
        Array.from(app.childNodes).forEach((child) => {
          var _a2;
          (_a2 = refNode == null ? void 0 : refNode.parentNode) == null ? void 0 : _a2.insertBefore(child, refNode);
        });
      }
    }
  };
  function setupMTeamObserver(app) {
    const targetNode = document.getElementById("root");
    if (!targetNode) return;
    if (document.querySelector(CURRENT_SITE_INFO.seedDomSelector)) {
      insertScriptDomToMT(app);
      return;
    }
    const config = { childList: true, subtree: true };
    const observer = new MutationObserver((mutationsList, observer2) => {
      for (const mutation of mutationsList) {
        if (mutation.type === "childList") {
          const targetElement = $$2(CURRENT_SITE_INFO.seedDomSelector)[0];
          if (targetElement) {
            observer2.disconnect();
            insertScriptDomToMT(app);
            break;
          }
        }
      }
    });
    observer.observe(targetNode, config);
  }
  function insertScriptDomToMT(app) {
    const refNode = $$2(CURRENT_SITE_INFO.seedDomSelector)[0];
    Array.from(app.childNodes).forEach((child) => {
      var _a2;
      (_a2 = refNode == null ? void 0 : refNode.parentNode) == null ? void 0 : _a2.insertBefore(child, refNode);
    });
  }
  function extractTorrentInfoFromHash() {
    const hash2 = location.hash || "";
    const torrentInfoMatch = hash2.match(/(^|#)torrentInfo=([^#]+)/);
    const torrentInfoRaw = (torrentInfoMatch == null ? void 0 : torrentInfoMatch[2]) || null;
    const timestampMatch = hash2.match(/(^|#)timestamp=([^#]+)/);
    const timestamp2 = (timestampMatch == null ? void 0 : timestampMatch[2]) || null;
    return { torrentInfoRaw, timestamp: timestamp2 };
  }
  async function retrieveTorrentInfo() {
    const { torrentInfoRaw, timestamp: timestamp2 } = extractTorrentInfoFromHash();
    if (torrentInfoRaw) {
      try {
        return JSON.parse(decodeURIComponent(torrentInfoRaw));
      } catch (e2) {
        console.error("fail to parse torrent info", e2);
      }
    } else if (timestamp2) {
      return GM_getValue("cachedTorrentInfo");
    }
    return null;
  }
  function determineReferenceNode() {
    let refNode = $$2(CURRENT_SITE_INFO.seedDomSelector)[0];
    const { specialSelectors, specialSiteNames } = SPECIAL_SITE_CONFIGS;
    if (specialSiteNames.includes(CURRENT_SITE_NAME)) {
      const torrentId = getLocationSearchValueByKey("torrentid");
      if (!torrentId) return refNode;
      const selectorFn = specialSelectors[CURRENT_SITE_NAME] || specialSelectors.GazelleDefault;
      const selector = selectorFn(torrentId);
      refNode = document.querySelector(selector);
    }
    return refNode;
  }
  function renderApp() {
    const app = document.createElement("div");
    preact.render(/* @__PURE__ */ u$1(Container, {}), app);
    const refNode = determineReferenceNode();
    if (!refNode) {
      return;
    }
    const { appendMethods, specialSiteNames } = SPECIAL_SITE_CONFIGS;
    if (specialSiteNames.includes(CURRENT_SITE_NAME)) {
      const appendMethod = appendMethods.GazelleDefault;
      appendMethod(app, refNode);
      return;
    }
    const specialHandler = appendMethods[CURRENT_SITE_NAME];
    if (specialHandler) {
      specialHandler(app, refNode);
      return;
    }
    appendMethods.default(app, refNode);
  }
  function shouldInitialize() {
    if (!CURRENT_SITE_NAME || !CURRENT_SITE_INFO) {
      return false;
    }
    if (CURRENT_SITE_INFO.search && location.pathname.match(CURRENT_SITE_INFO.search.path) && (getLocationSearchValueByKey("imdb") || getLocationSearchValueByKey("name"))) {
      return false;
    }
    if (location.href.match(/upload|offer|create/gi)) {
      return false;
    }
    return true;
  }
  async function initialize() {
    if (!CURRENT_SITE_NAME) return;
    fillSearchImdb();
    if (CURRENT_SITE_INFO.asTarget) {
      const torrentInfo = await retrieveTorrentInfo();
      if (torrentInfo) {
        fillTargetForm(torrentInfo);
      }
    }
    if (CURRENT_SITE_INFO.asSource && shouldInitialize()) {
      try {
        const info = await getTorrentInfo();
        if (info) {
          console.log("torrent info was retrieved", info);
          torrentInfoStore.setInfo(info);
          renderApp();
        }
      } catch (error) {
        console.error("fail to get torrent info", error);
      }
    }
  }
  initialize().catch((error) => {
    console.error("fail to initialize Easy-Upload", error);
  });

})(preact, jQuery);